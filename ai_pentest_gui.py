#!/usr/bin/env python3
"""
AI-Powered Pentesting GUI with Full Orchestrator Integration
Complete GUI for all 8 types of pentesting with AI reasoning and classification
"""

import sys
import os
import asyncio
import json
import threading
import time
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List
import subprocess

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QTextEdit, QPushButton, QLabel, QLineEdit, QSplitter, QTabWidget,
    QProgressBar, QComboBox, QCheckBox, QFrame, QScrollArea, QTreeWidget,
    QTreeWidgetItem, QTableWidget, QTableWidgetItem, QGroupBox, QGridLayout,
    QStatusBar, QDialog, QDialogButtonBox, QListWidget, QListWidgetItem
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer, QEventLoop
from PyQt6.QtGui import QFont, QColor, QTextCursor, QTextCharFormat, QSyntaxHighlighter

# Add current directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))

try:
    from ai_pentest_orchestrator import AIPentestOrchestrator, ExecutionPlan, PentestType
    ORCHESTRATOR_AVAILABLE = True
except ImportError as e:
    print(f"Orchestrator not available: {e}")
    ORCHESTRATOR_AVAILABLE = False

class PentestExecutionWorker(QThread):
    """Worker thread for executing pentesting plans"""
    
    progress_update = pyqtSignal(int, int, str)  # current, total, status
    task_completed = pyqtSignal(str, dict)  # task_id, result
    execution_finished = pyqtSignal(dict)  # final results
    log_message = pyqtSignal(str)
    
    def __init__(self, orchestrator, execution_plan):
        super().__init__()
        self.orchestrator = orchestrator
        self.execution_plan = execution_plan
        self.is_running = True
    
    def run(self):
        """Execute the pentesting plan asynchronously"""
        try:
            # Create event loop for async execution
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            
            def progress_callback(current, total, status):
                if self.is_running:
                    self.progress_update.emit(current, total, status)
                    self.log_message.emit(f"Progress: {current+1}/{total} - {status}")
            
            # Execute the plan
            results = loop.run_until_complete(
                self.orchestrator.execute_plan(self.execution_plan, progress_callback)
            )
            
            if self.is_running:
                self.execution_finished.emit(results)
            
        except Exception as e:
            self.log_message.emit(f"Execution error: {str(e)}")
            self.execution_finished.emit({"status": "failed", "error": str(e)})
    
    def stop(self):
        """Stop the execution"""
        self.is_running = False
        self.terminate()

class PlanAnalysisDialog(QDialog):
    """Dialog for analyzing and approving execution plans"""
    
    def __init__(self, execution_plan: ExecutionPlan, parent=None):
        super().__init__(parent)
        self.execution_plan = execution_plan
        self.approved = False
        self.init_ui()
    
    def init_ui(self):
        """Initialize the dialog UI"""
        self.setWindowTitle("Execution Plan Analysis")
        self.setGeometry(200, 200, 800, 600)
        
        layout = QVBoxLayout(self)
        
        # Plan overview
        overview_group = QGroupBox("Plan Overview")
        overview_layout = QGridLayout(overview_group)
        
        overview_layout.addWidget(QLabel("Plan ID:"), 0, 0)
        overview_layout.addWidget(QLabel(self.execution_plan.plan_id), 0, 1)
        
        overview_layout.addWidget(QLabel("Original Request:"), 1, 0)
        overview_layout.addWidget(QLabel(self.execution_plan.original_request), 1, 1)
        
        targets = list(set(task.target for task in self.execution_plan.tasks))
        overview_layout.addWidget(QLabel("Targets:"), 2, 0)
        overview_layout.addWidget(QLabel(", ".join(targets)), 2, 1)
        
        pentest_types = list(set(task.pentest_type.value for task in self.execution_plan.tasks))
        overview_layout.addWidget(QLabel("Pentest Types:"), 3, 0)
        overview_layout.addWidget(QLabel(", ".join(pentest_types)), 3, 1)
        
        overview_layout.addWidget(QLabel("Estimated Time:"), 4, 0)
        overview_layout.addWidget(QLabel(f"{self.execution_plan.total_estimated_time} seconds"), 4, 1)
        
        overview_layout.addWidget(QLabel("Risk Level:"), 5, 0)
        risk_label = QLabel(self.execution_plan.risk_assessment['level'])
        risk_color = {"LOW": "green", "MEDIUM": "orange", "HIGH": "red", "CRITICAL": "darkred"}
        risk_label.setStyleSheet(f"color: {risk_color.get(self.execution_plan.risk_assessment['level'], 'black')}; font-weight: bold;")
        overview_layout.addWidget(risk_label, 5, 1)
        
        layout.addWidget(overview_group)
        
        # Reasoning chain
        reasoning_group = QGroupBox("AI Reasoning Chain")
        reasoning_layout = QVBoxLayout(reasoning_group)
        
        reasoning_text = QTextEdit()
        reasoning_text.setMaximumHeight(150)
        reasoning_text.setReadOnly(True)
        
        reasoning_content = ""
        for i, reasoning in enumerate(self.execution_plan.reasoning_chain, 1):
            reasoning_content += f"{i}. {reasoning}\n"
        reasoning_text.setPlainText(reasoning_content)
        
        reasoning_layout.addWidget(reasoning_text)
        layout.addWidget(reasoning_group)
        
        # Tasks detail
        tasks_group = QGroupBox("Execution Tasks")
        tasks_layout = QVBoxLayout(tasks_group)
        
        self.tasks_table = QTableWidget()
        self.tasks_table.setColumnCount(6)
        self.tasks_table.setHorizontalHeaderLabels([
            "Task ID", "Type", "Target", "Risk", "Duration", "Reasoning"
        ])
        
        self.tasks_table.setRowCount(len(self.execution_plan.tasks))
        
        for i, task in enumerate(self.execution_plan.tasks):
            self.tasks_table.setItem(i, 0, QTableWidgetItem(task.task_id))
            self.tasks_table.setItem(i, 1, QTableWidgetItem(task.pentest_type.value))
            self.tasks_table.setItem(i, 2, QTableWidgetItem(task.target))
            self.tasks_table.setItem(i, 3, QTableWidgetItem(task.risk_level.value))
            self.tasks_table.setItem(i, 4, QTableWidgetItem(f"{task.estimated_duration}s"))
            self.tasks_table.setItem(i, 5, QTableWidgetItem(task.reasoning))
        
        self.tasks_table.resizeColumnsToContents()
        tasks_layout.addWidget(self.tasks_table)
        layout.addWidget(tasks_group)
        
        # Risk assessment
        risk_group = QGroupBox("Risk Assessment")
        risk_layout = QVBoxLayout(risk_group)
        
        risk_text = QTextEdit()
        risk_text.setMaximumHeight(100)
        risk_text.setReadOnly(True)
        
        risk_content = f"""
Level: {self.execution_plan.risk_assessment['level']}
Mitigation: {self.execution_plan.risk_assessment['mitigation']}
Impact: {self.execution_plan.risk_assessment['estimated_impact']}
        """
        risk_text.setPlainText(risk_content.strip())
        
        risk_layout.addWidget(risk_text)
        layout.addWidget(risk_group)
        
        # Buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        buttons.accepted.connect(self.approve)
        buttons.rejected.connect(self.reject)
        
        layout.addWidget(buttons)
    
    def approve(self):
        """Approve the execution plan"""
        self.approved = True
        self.accept()

class AIPentestGUI(QMainWindow):
    """Main AI-powered pentesting GUI"""
    
    def __init__(self):
        super().__init__()
        self.orchestrator = None
        self.current_plan = None
        self.execution_worker = None
        self.init_ui()
        self.init_orchestrator()
    
    def init_ui(self):
        """Initialize the user interface"""
        self.setWindowTitle("AI-Powered Pentesting Suite - All 8 Types")
        self.setGeometry(100, 100, 1600, 1000)
        
        # Dark theme styling
        self.setStyleSheet("""
            QMainWindow {
                background-color: #1e1e1e;
                color: #ffffff;
            }
            QTextEdit {
                background-color: #000000;
                color: #00ff00;
                border: 1px solid #333333;
                font-family: 'Courier New', monospace;
                font-size: 12px;
                padding: 8px;
            }
            QLineEdit {
                background-color: #2d2d2d;
                color: #ffffff;
                border: 1px solid #555555;
                padding: 8px;
                font-size: 12px;
            }
            QPushButton {
                background-color: #0066cc;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #0080ff;
            }
            QPushButton:disabled {
                background-color: #555555;
                color: #888888;
            }
            QLabel {
                color: #ffffff;
                font-size: 12px;
            }
            QTabWidget::pane {
                border: 1px solid #555555;
                background-color: #2d2d2d;
            }
            QTabBar::tab {
                background-color: #3d3d3d;
                color: #ffffff;
                padding: 8px 16px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #0066cc;
            }
            QGroupBox {
                color: #ffffff;
                border: 2px solid #555555;
                border-radius: 5px;
                margin-top: 1ex;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)
        
        # Create central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        
        # Title
        title_label = QLabel("ü§ñ AI-Powered Pentesting Orchestrator")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet("font-size: 18px; font-weight: bold; color: #00ff41; padding: 10px;")
        main_layout.addWidget(title_label)
        
        # Input section
        input_group = QGroupBox("Natural Language Pentesting Request")
        input_layout = QVBoxLayout(input_group)
        
        self.request_input = QTextEdit()
        self.request_input.setMaximumHeight(80)
        self.request_input.setPlaceholderText(
            "Enter your pentesting request in natural language:\n"
            "Examples:\n"
            "‚Ä¢ 'Perform comprehensive security assessment of example.com'\n"
            "‚Ä¢ 'Test mobile app security.apk for vulnerabilities'\n"
            "‚Ä¢ 'Scan 192.168.1.0/24 for security issues and generate exploits'"
        )
        input_layout.addWidget(self.request_input)
        
        # Control buttons
        control_layout = QHBoxLayout()
        
        self.analyze_btn = QPushButton("üß† Analyze Request")
        self.analyze_btn.clicked.connect(self.analyze_request)
        
        self.execute_btn = QPushButton("üöÄ Execute Plan")
        self.execute_btn.clicked.connect(self.execute_plan)
        self.execute_btn.setEnabled(False)
        
        self.stop_btn = QPushButton("‚èπÔ∏è Stop Execution")
        self.stop_btn.clicked.connect(self.stop_execution)
        self.stop_btn.setEnabled(False)
        
        self.clear_btn = QPushButton("üóëÔ∏è Clear")
        self.clear_btn.clicked.connect(self.clear_all)
        
        control_layout.addWidget(self.analyze_btn)
        control_layout.addWidget(self.execute_btn)
        control_layout.addWidget(self.stop_btn)
        control_layout.addWidget(self.clear_btn)
        control_layout.addStretch()
        
        input_layout.addLayout(control_layout)
        main_layout.addWidget(input_group)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        main_layout.addWidget(self.progress_bar)
        
        # Main content splitter
        splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Left side - Output and logs
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        
        # Output tabs
        output_tabs = QTabWidget()
        
        # Terminal output
        self.terminal_output = QTextEdit()
        self.terminal_output.setFont(QFont("Courier New", 12))
        output_tabs.addTab(self.terminal_output, "üñ•Ô∏è Terminal Output")
        
        # Execution log
        self.execution_log = QTextEdit()
        self.execution_log.setFont(QFont("Courier New", 12))
        output_tabs.addTab(self.execution_log, "üìã Execution Log")
        
        left_layout.addWidget(output_tabs)
        
        # Right side - Analysis and results
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        
        # Analysis tabs
        analysis_tabs = QTabWidget()
        
        # AI Analysis
        ai_analysis_widget = QWidget()
        ai_analysis_layout = QVBoxLayout(ai_analysis_widget)
        
        ai_analysis_layout.addWidget(QLabel("üß† AI Intent Classification:"))
        self.ai_analysis = QTextEdit()
        self.ai_analysis.setMaximumHeight(120)
        self.ai_analysis.setReadOnly(True)
        ai_analysis_layout.addWidget(self.ai_analysis)
        
        ai_analysis_layout.addWidget(QLabel("üî§ NLP Analysis:"))
        self.nlp_analysis = QTextEdit()
        self.nlp_analysis.setMaximumHeight(120)
        self.nlp_analysis.setReadOnly(True)
        ai_analysis_layout.addWidget(self.nlp_analysis)
        
        analysis_tabs.addTab(ai_analysis_widget, "ü§ñ AI Analysis")
        
        # Execution Plan
        plan_widget = QWidget()
        plan_layout = QVBoxLayout(plan_widget)
        
        self.plan_display = QTextEdit()
        self.plan_display.setReadOnly(True)
        plan_layout.addWidget(self.plan_display)
        
        analysis_tabs.addTab(plan_widget, "üìã Execution Plan")
        
        # Results Summary
        results_widget = QWidget()
        results_layout = QVBoxLayout(results_widget)
        
        self.results_display = QTextEdit()
        self.results_display.setReadOnly(True)
        results_layout.addWidget(self.results_display)
        
        analysis_tabs.addTab(results_widget, "üìä Results Summary")
        
        # Findings
        findings_widget = QWidget()
        findings_layout = QVBoxLayout(findings_widget)
        
        self.findings_list = QListWidget()
        findings_layout.addWidget(self.findings_list)
        
        analysis_tabs.addTab(findings_widget, "üîç Security Findings")
        
        right_layout.addWidget(analysis_tabs)
        
        # Add to splitter
        splitter.addWidget(left_widget)
        splitter.addWidget(right_widget)
        splitter.setSizes([800, 600])
        
        main_layout.addWidget(splitter)
        
        # Status bar
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        self.status_bar.showMessage("Ready - Enter a pentesting request above")
        
        # Welcome message
        self.log_message("üéâ AI-Powered Pentesting Suite Ready!")
        self.log_message("üìã Supported Pentest Types:")
        self.log_message("   ‚Ä¢ Reconnaissance & Intelligence Gathering")
        self.log_message("   ‚Ä¢ Vulnerability Scanning & Assessment")
        self.log_message("   ‚Ä¢ Network Infrastructure Testing")
        self.log_message("   ‚Ä¢ Web Application Security Testing")
        self.log_message("   ‚Ä¢ Mobile Application Analysis")
        self.log_message("   ‚Ä¢ Wireless Security Assessment")
        self.log_message("   ‚Ä¢ Cloud Security Evaluation")
        self.log_message("   ‚Ä¢ IoT Device Security Testing")
        self.log_message("   ‚Ä¢ Social Engineering Simulation")
        self.log_message("   ‚Ä¢ Red Team Operations")
        self.log_message("   ‚Ä¢ Payload Generation & Exploitation")
        self.log_message("\\nEnter your request in natural language and click 'Analyze Request'")
    
    def init_orchestrator(self):
        """Initialize the AI orchestrator"""
        try:
            if ORCHESTRATOR_AVAILABLE:
                self.orchestrator = AIPentestOrchestrator()
                self.log_message("‚úÖ AI Orchestrator initialized successfully")
                self.status_bar.showMessage("AI System Ready")
            else:
                self.log_message("‚ö†Ô∏è AI Orchestrator not available - using simulation mode")
                self.status_bar.showMessage("Simulation Mode - AI Orchestrator not available")
        except Exception as e:
            self.log_message(f"‚ùå Failed to initialize AI Orchestrator: {e}")
            self.status_bar.showMessage("Error - AI System failed to initialize")
    
    def log_message(self, message):
        """Add message to execution log"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.execution_log.append(f"[{timestamp}] {message}")
        
        # Auto-scroll to bottom
        cursor = self.execution_log.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.End)
        self.execution_log.setTextCursor(cursor)
    
    def analyze_request(self):
        """Analyze the user's pentesting request"""
        request_text = self.request_input.toPlainText().strip()
        
        if not request_text:
            self.log_message("‚ùå Please enter a pentesting request")
            return
        
        self.log_message(f"üîç Analyzing request: {request_text}")
        self.analyze_btn.setEnabled(False)
        
        try:
            if not self.orchestrator:
                # Simulation mode
                self.log_message("‚öôÔ∏è Running in simulation mode...")
                self.simulate_analysis(request_text)
                return
            
            # Real analysis
            self.status_bar.showMessage("Analyzing request with AI...")
            
            # Process the request
            self.current_plan = self.orchestrator.process_natural_language_request(request_text)
            
            # Update AI analysis display
            self.update_analysis_display()
            
            # Update plan display
            self.update_plan_display()
            
            self.log_message("‚úÖ Request analysis completed")
            self.execute_btn.setEnabled(True)
            self.status_bar.showMessage("Analysis complete - Ready to execute")
            
        except Exception as e:
            self.log_message(f"‚ùå Analysis failed: {e}")
            self.status_bar.showMessage("Analysis failed")
        finally:
            self.analyze_btn.setEnabled(True)
    
    def simulate_analysis(self, request_text):
        """Simulate analysis for demo purposes"""
        import time
        import random
        
        # Simulate AI processing
        self.ai_analysis.setPlainText(f"""
AI Intent Classification:
‚Ä¢ Primary Intent: comprehensive_assessment
‚Ä¢ Confidence: 0.85
‚Ä¢ Secondary Intents: vulnerability_scanning, network_assessment
‚Ä¢ Target Type: web_application
        """)
        
        # Simulate NLP analysis
        self.nlp_analysis.setPlainText(f"""
NLP Processing Results:
‚Ä¢ Command: scan
‚Ä¢ Targets Identified: {', '.join(['example.com', '192.168.1.0/24']) if 'example.com' in request_text else 'localhost'}
‚Ä¢ Modifiers: comprehensive, security
‚Ä¢ Confidence: 0.92
        """)
        
        # Simulate plan
        pentest_types = ["reconnaissance", "vulnerability_scanning", "network_assessment", "web_application"]
        if "mobile" in request_text.lower():
            pentest_types.append("mobile_application")
        if "wireless" in request_text.lower() or "wifi" in request_text.lower():
            pentest_types.append("wireless_security")
        
        plan_text = f"""
Execution Plan (Simulated):
‚Ä¢ Plan ID: sim_plan_{datetime.now().strftime('%Y%m%d_%H%M%S')}
‚Ä¢ Target(s): example.com, localhost
‚Ä¢ Pentest Types: {', '.join(pentest_types)}
‚Ä¢ Estimated Time: {random.randint(600, 1800)} seconds
‚Ä¢ Risk Level: MEDIUM
‚Ä¢ Total Tasks: {len(pentest_types)}

Reasoning Chain:
1. Detected web application target - recommend web security testing
2. AI model suggests comprehensive operations
3. NLP processor identified scan command
4. Determined execution order: {' ‚Üí '.join(pentest_types)}

Tasks:
        """
        
        for i, ptype in enumerate(pentest_types, 1):
            plan_text += f"{i}. {ptype} on example.com (Risk: MEDIUM)\n"
        
        self.plan_display.setPlainText(plan_text)
        
        self.log_message("‚úÖ Simulation analysis completed")
        self.execute_btn.setEnabled(True)
        self.status_bar.showMessage("Simulation ready - Can execute simulated plan")
    
    def update_analysis_display(self):
        """Update the AI analysis display"""
        if not self.current_plan:
            return
        
        # AI analysis
        ai_info = self.current_plan.classified_intent.get("ai_result", {})
        ai_text = f"""
AI Intent Classification:
‚Ä¢ Intent: {ai_info.get('intent', 'unknown')}
‚Ä¢ Confidence: {ai_info.get('confidence', 0):.2f}
‚Ä¢ Alternative intents: {', '.join([alt['intent'] for alt in ai_info.get('alternatives', [])])}
        """
        self.ai_analysis.setPlainText(ai_text.strip())
        
        # NLP analysis  
        nlp_info = self.current_plan.classified_intent.get("nlp_result", {})
        if nlp_info:
            nlp_text = f"""
NLP Processing Results:
‚Ä¢ Primary Command: {nlp_info.get('primary_command', {}).get('value', 'unknown')}
‚Ä¢ Confidence: {nlp_info.get('confidence', 0):.2f}
‚Ä¢ Targets: {', '.join(nlp_info.get('targets', []))}
‚Ä¢ Modifiers: {', '.join(nlp_info.get('modifiers', []))}
            """
            self.nlp_analysis.setPlainText(nlp_text.strip())
    
    def update_plan_display(self):
        """Update the execution plan display"""
        if not self.current_plan:
            return
        
        targets = list(set(task.target for task in self.current_plan.tasks))
        pentest_types = list(set(task.pentest_type.value for task in self.current_plan.tasks))
        
        plan_text = f"""
üìã EXECUTION PLAN DETAILS
{'='*50}

Plan ID: {self.current_plan.plan_id}
Original Request: {self.current_plan.original_request}
Targets: {', '.join(targets)}
Pentest Types: {', '.join(pentest_types)}
Total Tasks: {len(self.current_plan.tasks)}
Estimated Time: {self.current_plan.total_estimated_time} seconds ({self.current_plan.total_estimated_time/60:.1f} minutes)
Risk Level: {self.current_plan.risk_assessment['level']}

üß† REASONING CHAIN:
{'='*30}
"""
        
        for i, reasoning in enumerate(self.current_plan.reasoning_chain, 1):
            plan_text += f"{i}. {reasoning}\n"
        
        plan_text += f"\nüìù INDIVIDUAL TASKS:\n{'='*30}\n"
        
        for i, task in enumerate(self.current_plan.tasks, 1):
            plan_text += f"""
Task {i}: {task.task_id}
  ‚Ä¢ Type: {task.pentest_type.value}
  ‚Ä¢ Target: {task.target}
  ‚Ä¢ Risk Level: {task.risk_level.value}
  ‚Ä¢ Duration: {task.estimated_duration}s
  ‚Ä¢ Reasoning: {task.reasoning}
"""
        
        plan_text += f"\n‚ö†Ô∏è RISK ASSESSMENT:\n{'='*30}\n"
        plan_text += f"Level: {self.current_plan.risk_assessment['level']}\n"
        plan_text += f"Mitigation: {self.current_plan.risk_assessment['mitigation']}\n"
        plan_text += f"Impact: {self.current_plan.risk_assessment['estimated_impact']}\n"
        
        self.plan_display.setPlainText(plan_text)
    
    def execute_plan(self):
        """Execute the current pentesting plan"""
        if not self.current_plan:
            self.log_message("‚ùå No execution plan available")
            return
        
        # Show plan analysis dialog
        dialog = PlanAnalysisDialog(self.current_plan, self)
        if dialog.exec() != QDialog.DialogCode.Accepted or not dialog.approved:
            self.log_message("‚ùå Execution cancelled by user")
            return
        
        self.log_message(f"üöÄ Starting execution of plan {self.current_plan.plan_id}")
        
        # Update UI state
        self.execute_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        self.analyze_btn.setEnabled(False)
        self.progress_bar.setVisible(True)
        self.progress_bar.setRange(0, len(self.current_plan.tasks))
        self.progress_bar.setValue(0)
        
        # Clear previous results
        self.terminal_output.clear()
        self.results_display.clear()
        self.findings_list.clear()
        
        self.status_bar.showMessage("Executing pentesting plan...")
        
        if not self.orchestrator:
            # Simulation mode
            self.simulate_execution()
            return
        
        # Real execution
        self.execution_worker = PentestExecutionWorker(self.orchestrator, self.current_plan)
        self.execution_worker.progress_update.connect(self.update_execution_progress)
        self.execution_worker.log_message.connect(self.log_message)
        self.execution_worker.execution_finished.connect(self.execution_completed)
        self.execution_worker.start()
    
    def simulate_execution(self):
        """Simulate plan execution for demo"""
        self.log_message("üé≠ Running simulated execution...")
        
        # Simulate execution with timer
        self.simulation_step = 0
        self.simulation_timer = QTimer()
        self.simulation_timer.timeout.connect(self.simulate_step)
        self.simulation_timer.start(2000)  # 2 second intervals
    
    def simulate_step(self):
        """Simulate one execution step"""
        if self.simulation_step >= len(self.current_plan.tasks if self.current_plan else [5]):
            self.simulation_timer.stop()
            self.simulate_completion()
            return
        
        if self.current_plan:
            task = self.current_plan.tasks[self.simulation_step]
            task_name = f"{task.pentest_type.value} on {task.target}"
        else:
            task_name = f"Simulated task {self.simulation_step + 1}"
        
        self.log_message(f"‚öôÔ∏è Executing: {task_name}")
        self.terminal_output.append(f"‚ùØ Simulating {task_name}")
        self.terminal_output.append(f"‚úÖ Task completed successfully")
        self.terminal_output.append(f"üìä Found {1 + self.simulation_step} potential findings")
        self.terminal_output.append("‚îÄ" * 50)
        
        self.progress_bar.setValue(self.simulation_step + 1)
        self.simulation_step += 1
    
    def simulate_completion(self):
        """Complete the simulation"""
        self.log_message("‚úÖ Simulated execution completed")
        
        # Simulate results
        results = {
            "status": "completed",
            "completed_tasks": 5,
            "failed_tasks": 0,
            "overall_findings": [
                {"type": "vulnerability", "severity": "MEDIUM", "description": "Simulated SQL injection vulnerability"},
                {"type": "misconfiguration", "severity": "LOW", "description": "Simulated directory listing enabled"},
                {"type": "information_disclosure", "severity": "INFO", "description": "Simulated version information exposed"}
            ]
        }
        
        self.execution_completed(results)
    
    def update_execution_progress(self, current, total, status):
        """Update execution progress"""
        self.progress_bar.setValue(current + 1)
        self.status_bar.showMessage(f"Executing: {status} ({current + 1}/{total})")
        self.terminal_output.append(f"‚öôÔ∏è {status}")
    
    def execution_completed(self, results):
        """Handle execution completion"""
        self.log_message(f"üìä Execution completed with status: {results.get('status', 'unknown')}")
        
        # Update UI state
        self.execute_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.analyze_btn.setEnabled(True)
        self.progress_bar.setVisible(False)
        
        # Display results
        self.display_results(results)
        
        status_msg = "‚úÖ Execution completed successfully" if results.get("status") == "completed" else "‚ùå Execution failed"
        self.status_bar.showMessage(status_msg)
    
    def display_results(self, results):
        """Display execution results"""
        # Results summary
        summary_text = f"""
üìä EXECUTION RESULTS SUMMARY
{'='*50}

Status: {results.get('status', 'unknown').upper()}
Completed Tasks: {results.get('completed_tasks', 0)}
Failed Tasks: {results.get('failed_tasks', 0)}
Total Findings: {len(results.get('overall_findings', []))}
        """
        
        if 'start_time' in results:
            summary_text += f"Start Time: {results['start_time']}\n"
        if 'end_time' in results:
            summary_text += f"End Time: {results['end_time']}\n"
        
        # Add report summary if available
        if 'report' in results:
            report = results['report']
            summary_text += f"""

üìã REPORT SUMMARY:
{'='*30}
Methodology: {', '.join(report.get('methodology', []))}
Targets Tested: {', '.join(report.get('targets_tested', []))}
Risk Level: {report.get('risk_level', 'unknown')}

üîí RECOMMENDATIONS:
{'='*30}
"""
            for i, rec in enumerate(report.get('recommendations', []), 1):
                summary_text += f"{i}. {rec}\n"
        
        self.results_display.setPlainText(summary_text)
        
        # Display findings
        self.findings_list.clear()
        for finding in results.get('overall_findings', []):
            severity = finding.get('severity', 'UNKNOWN')
            description = finding.get('description', 'No description')
            target = finding.get('target', 'Unknown target')
            
            # Color code by severity
            color_map = {
                'CRITICAL': 'darkred',
                'HIGH': 'red', 
                'MEDIUM': 'orange',
                'LOW': 'yellow',
                'INFO': 'lightblue'
            }
            
            item = QListWidgetItem(f"[{severity}] {description} - {target}")
            item.setForeground(QColor(color_map.get(severity, 'white')))
            self.findings_list.addItem(item)
    
    def stop_execution(self):
        """Stop the current execution"""
        if self.execution_worker:
            self.log_message("üõë Stopping execution...")
            self.execution_worker.stop()
            self.execution_worker = None
        
        if hasattr(self, 'simulation_timer'):
            self.simulation_timer.stop()
        
        # Reset UI state
        self.execute_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.analyze_btn.setEnabled(True)
        self.progress_bar.setVisible(False)
        
        self.status_bar.showMessage("Execution stopped by user")
        self.log_message("‚ùå Execution stopped by user")
    
    def clear_all(self):
        """Clear all displays"""
        self.request_input.clear()
        self.terminal_output.clear()
        self.execution_log.clear()
        self.ai_analysis.clear()
        self.nlp_analysis.clear()
        self.plan_display.clear()
        self.results_display.clear()
        self.findings_list.clear()
        self.current_plan = None
        
        self.execute_btn.setEnabled(False)
        self.status_bar.showMessage("Ready - Enter a new pentesting request")
        self.log_message("üóëÔ∏è All displays cleared")

def main():
    """Main application entry point"""
    app = QApplication(sys.argv)
    
    # Set application properties
    app.setApplicationName("AI-Powered Pentesting Suite")
    app.setApplicationVersion("2.0")
    
    # Set dark fusion style
    app.setStyle("Fusion")
    
    # Create and show main window
    window = AIPentestGUI()
    window.show()
    
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
