#!/usr/bin/env python3
"""
PentestGPT Unified - Complete Pentesting Suite with NLP and All Features
Combines chat interface, file upload, all stages, and command control
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import threading
import subprocess
import json
import time
import re
import sys
import os
from pathlib import Path
from datetime import datetime
import queue
import hashlib
from typing import Dict, List, Any, Optional

# Add src to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

class PentestGPTUnified:
    """Unified pentesting interface with all features"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("üîê PentestGPT Unified - Complete AI Pentesting Suite")
        self.root.geometry("1700x950")
        
        # Color scheme
        self.colors = {
            'bg': '#0a0e27',
            'sidebar': '#151934',
            'panel': '#1e2139',
            'input': '#2a2f4e',
            'text': '#e4e6eb',
            'accent': '#00d9ff',
            'success': '#4ade80',
            'warning': '#fbbf24',
            'error': '#ef4444',
            'info': '#60a5fa',
            'critical': '#dc2626',
            'high': '#f97316',
            'medium': '#eab308',
            'low': '#84cc16'
        }
        
        # Pentesting stages
        self.stages = {
            'recon': {'name': 'üîç Reconnaissance', 'status': 'pending', 'progress': 0},
            'scanning': {'name': 'üéØ Scanning', 'status': 'pending', 'progress': 0},
            'enumeration': {'name': 'üìã Enumeration', 'status': 'pending', 'progress': 0},
            'vuln_assessment': {'name': 'üêõ Vulnerability Assessment', 'status': 'pending', 'progress': 0},
            'exploitation': {'name': 'üíâ Exploitation', 'status': 'pending', 'progress': 0},
            'post_exploit': {'name': 'üîì Post-Exploitation', 'status': 'pending', 'progress': 0},
            'privilege_esc': {'name': '‚¨ÜÔ∏è Privilege Escalation', 'status': 'pending', 'progress': 0},
            'lateral_movement': {'name': '‚û°Ô∏è Lateral Movement', 'status': 'pending', 'progress': 0},
            'persistence': {'name': 'üîÑ Persistence', 'status': 'pending', 'progress': 0},
            'data_exfil': {'name': 'üì§ Data Exfiltration', 'status': 'pending', 'progress': 0},
            'cleanup': {'name': 'üßπ Cleanup', 'status': 'pending', 'progress': 0},
            'reporting': {'name': 'üìÑ Reporting', 'status': 'pending', 'progress': 0}
        }
        
        # NLP patterns
        self.command_patterns = {
            'scan': ['scan', 'test', 'analyze', 'check', 'assess', 'pentest'],
            'exploit': ['exploit', 'attack', 'hack', 'compromise', 'pwn'],
            'recon': ['reconnaissance', 'recon', 'discover', 'enumerate', 'find'],
            'report': ['report', 'generate report', 'create report', 'summary'],
            'vulnerability': ['vulnerability', 'vuln', 'weakness', 'security issue'],
            'sqlinjection': ['sql injection', 'sqli', 'database injection'],
            'xss': ['xss', 'cross site scripting', 'script injection'],
            'shell': ['shell', 'reverse shell', 'backdoor', 'access']
        }
        
        # State management
        self.current_target = None
        self.uploaded_files = []
        self.chat_history = []
        self.scan_results = {}
        self.vulnerabilities = []
        self.scan_running = False
        self.output_queue = queue.Queue()
        self.autonomous_mode = tk.BooleanVar(value=False)
        
        # Configure root
        self.root.configure(bg=self.colors['bg'])
        
        # Setup UI
        self.setup_ui()
        
        # Start processors
        self.process_output()
        
        # Show welcome
        self.show_welcome()
        
    def setup_ui(self):
        """Setup the unified UI"""
        
        # Main container
        main_container = tk.Frame(self.root, bg=self.colors['bg'])
        main_container.pack(fill=tk.BOTH, expand=True)
        
        # Header
        self.create_header(main_container)
        
        # Main content with three columns
        content_frame = tk.Frame(main_container, bg=self.colors['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Left: Stages & Control (250px)
        left_frame = tk.Frame(content_frame, bg=self.colors['sidebar'], width=250)
        left_frame.pack(side=tk.LEFT, fill=tk.Y)
        left_frame.pack_propagate(False)
        self.create_stages_panel(left_frame)
        
        # Middle: Main Interface with tabs (expandable)
        middle_frame = tk.Frame(content_frame, bg=self.colors['panel'])
        middle_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        self.create_main_interface(middle_frame)
        
        # Right: Command & Files (350px)
        right_frame = tk.Frame(content_frame, bg=self.colors['sidebar'], width=350)
        right_frame.pack(side=tk.LEFT, fill=tk.Y)
        right_frame.pack_propagate(False)
        self.create_command_panel(right_frame)
        
        # Status bar
        self.create_status_bar(main_container)
        
    def create_header(self, parent):
        """Create unified header"""
        header = tk.Frame(parent, bg=self.colors['panel'], height=60)
        header.pack(fill=tk.X, pady=(0, 5))
        header.pack_propagate(False)
        
        # Title
        title_frame = tk.Frame(header, bg=self.colors['panel'])
        title_frame.pack(side=tk.LEFT, padx=20, pady=10)
        
        tk.Label(
            title_frame,
            text="üîê PentestGPT Unified",
            font=("Arial", 20, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['panel']
        ).pack(side=tk.LEFT)
        
        tk.Label(
            title_frame,
            text="  AI-Powered Complete Pentesting Suite",
            font=("Arial", 12),
            fg=self.colors['text'],
            bg=self.colors['panel']
        ).pack(side=tk.LEFT)
        
        # Target display
        target_frame = tk.Frame(header, bg=self.colors['panel'])
        target_frame.pack(side=tk.RIGHT, padx=20, pady=15)
        
        tk.Label(
            target_frame,
            text="Target:",
            font=("Arial", 11),
            fg=self.colors['text'],
            bg=self.colors['panel']
        ).pack(side=tk.LEFT, padx=(0, 10))
        
        self.target_display = tk.Label(
            target_frame,
            text="Not Set",
            font=("Arial", 11, "bold"),
            fg=self.colors['warning'],
            bg=self.colors['panel']
        )
        self.target_display.pack(side=tk.LEFT)
        
    def create_stages_panel(self, parent):
        """Create stages panel"""
        # Title
        tk.Label(
            parent,
            text="Pentest Stages",
            font=("Arial", 13, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['sidebar']
        ).pack(padx=10, pady=10)
        
        # Stages list
        stages_frame = tk.Frame(parent, bg=self.colors['sidebar'])
        stages_frame.pack(fill=tk.BOTH, expand=True, padx=5)
        
        self.stage_widgets = {}
        
        for stage_id, stage_info in self.stages.items():
            stage_frame = tk.Frame(stages_frame, bg=self.colors['sidebar'], height=30)
            stage_frame.pack(fill=tk.X, pady=1)
            stage_frame.pack_propagate(False)
            
            status_label = tk.Label(
                stage_frame,
                text="‚óã",
                font=("Arial", 10),
                fg=self.colors['text'],
                bg=self.colors['sidebar']
            )
            status_label.pack(side=tk.LEFT, padx=(5, 8))
            
            name_label = tk.Label(
                stage_frame,
                text=stage_info['name'],
                font=("Arial", 9),
                fg=self.colors['text'],
                bg=self.colors['sidebar']
            )
            name_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            progress_label = tk.Label(
                stage_frame,
                text="",
                font=("Arial", 8),
                fg=self.colors['text'],
                bg=self.colors['sidebar']
            )
            progress_label.pack(side=tk.RIGHT, padx=5)
            
            self.stage_widgets[stage_id] = {
                'status': status_label,
                'name': name_label,
                'progress': progress_label
            }
            
        # Control buttons
        control_frame = tk.Frame(parent, bg=self.colors['sidebar'])
        control_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.start_btn = tk.Button(
            control_frame,
            text="‚ñ∂Ô∏è Start Full Pentest",
            command=self.start_full_pentest,
            font=("Arial", 10, "bold"),
            bg=self.colors['accent'],
            fg=self.colors['bg'],
            relief=tk.FLAT,
            padx=10,
            pady=8,
            cursor="hand2"
        )
        self.start_btn.pack(fill=tk.X, pady=3)
        
        # Quick stage buttons
        quick_btns = [
            ("üîç Recon", lambda: self.run_stage('recon')),
            ("üêõ Find Vulns", lambda: self.run_stage('vuln_assessment')),
            ("üíâ Exploit", lambda: self.run_stage('exploitation'))
        ]
        
        for text, cmd in quick_btns:
            tk.Button(
                control_frame,
                text=text,
                command=cmd,
                font=("Arial", 9),
                bg=self.colors['input'],
                fg=self.colors['text'],
                relief=tk.FLAT,
                padx=8,
                pady=4,
                cursor="hand2"
            ).pack(fill=tk.X, pady=2)
            
        # Autonomous mode
        tk.Checkbutton(
            control_frame,
            text="ü§ñ Autonomous",
            variable=self.autonomous_mode,
            font=("Arial", 9),
            fg=self.colors['text'],
            bg=self.colors['sidebar'],
            selectcolor=self.colors['input']
        ).pack(pady=5)
        
    def create_main_interface(self, parent):
        """Create main interface with tabs"""
        # Notebook
        self.notebook = ttk.Notebook(parent)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Chat tab
        chat_frame = tk.Frame(self.notebook, bg=self.colors['panel'])
        self.notebook.add(chat_frame, text="üí¨ AI Chat")
        self.create_chat_tab(chat_frame)
        
        # Results tabs
        self.tabs = {}
        
        tabs_config = [
            ('recon', 'üîç Recon'),
            ('scan', 'üéØ Scan'),
            ('vulns', 'üêõ Vulns'),
            ('exploit', 'üíâ Exploit'),
            ('shells', 'üíª Shells'),
            ('report', 'üìÑ Report')
        ]
        
        for tab_id, tab_name in tabs_config:
            frame = tk.Frame(self.notebook, bg=self.colors['panel'])
            self.notebook.add(frame, text=tab_name)
            self.tabs[tab_id] = scrolledtext.ScrolledText(
                frame,
                wrap=tk.WORD,
                font=("Consolas", 10),
                bg=self.colors['input'],
                fg=self.colors['text']
            )
            self.tabs[tab_id].pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
    def create_chat_tab(self, parent):
        """Create AI chat interface"""
        # Chat display
        self.chat_display = scrolledtext.ScrolledText(
            parent,
            wrap=tk.WORD,
            font=("Arial", 11),
            bg=self.colors['input'],
            fg=self.colors['text'],
            height=25
        )
        self.chat_display.pack(fill=tk.BOTH, expand=True, padx=10, pady=(10, 5))
        
        # Configure tags
        self.chat_display.tag_configure("user", foreground="#00d9ff", font=("Arial", 11, "bold"))
        self.chat_display.tag_configure("ai", foreground="#4ade80", font=("Arial", 11, "bold"))
        
        # Input area
        input_frame = tk.Frame(parent, bg=self.colors['panel'])
        input_frame.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        self.chat_input = tk.Text(
            input_frame,
            height=3,
            font=("Arial", 11),
            bg=self.colors['input'],
            fg=self.colors['text'],
            insertbackground=self.colors['accent']
        )
        self.chat_input.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))
        self.chat_input.bind('<Return>', self.handle_enter)
        
        send_btn = tk.Button(
            input_frame,
            text="Send ‚Üí",
            command=self.send_message,
            font=("Arial", 10, "bold"),
            bg=self.colors['accent'],
            fg=self.colors['bg'],
            relief=tk.FLAT,
            padx=15,
            pady=15,
            cursor="hand2"
        )
        send_btn.pack(side=tk.RIGHT)
        
        # Quick actions
        quick_frame = tk.Frame(parent, bg=self.colors['panel'])
        quick_frame.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        quick_actions = [
            ("üîç Scan", "scan the target"),
            ("üêõ Find Vulns", "find vulnerabilities"),
            ("üíâ Exploit", "exploit vulnerabilities"),
            ("üìÅ Upload", self.upload_file)
        ]
        
        for text, action in quick_actions:
            if callable(action):
                cmd = action
            else:
                cmd = lambda a=action: self.quick_command(a)
            
            tk.Button(
                quick_frame,
                text=text,
                command=cmd,
                font=("Arial", 9),
                bg=self.colors['input'],
                fg=self.colors['text'],
                relief=tk.FLAT,
                padx=12,
                pady=6,
                cursor="hand2"
            ).pack(side=tk.LEFT, padx=3)
            
    def create_command_panel(self, parent):
        """Create command and files panel"""
        # Target configuration
        target_frame = tk.LabelFrame(
            parent,
            text="Target",
            font=("Arial", 11, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['sidebar'],
            bd=1
        )
        target_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.target_entry = tk.Entry(
            target_frame,
            font=("Arial", 11),
            bg=self.colors['input'],
            fg=self.colors['text']
        )
        self.target_entry.pack(fill=tk.X, padx=10, pady=(10, 5))
        self.target_entry.insert(0, "testphp.vulnweb.com")
        
        tk.Button(
            target_frame,
            text="Set Target",
            command=self.set_target,
            font=("Arial", 9),
            bg=self.colors['accent'],
            fg=self.colors['bg'],
            relief=tk.FLAT,
            padx=10,
            pady=5
        ).pack(pady=(0, 10))
        
        # File upload
        file_frame = tk.LabelFrame(
            parent,
            text="File Analysis",
            font=("Arial", 11, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['sidebar'],
            bd=1
        )
        file_frame.pack(fill=tk.X, padx=10, pady=5)
        
        tk.Button(
            file_frame,
            text="üìÅ Upload File",
            command=self.upload_file,
            font=("Arial", 9),
            bg=self.colors['input'],
            fg=self.colors['text'],
            relief=tk.FLAT,
            padx=10,
            pady=6
        ).pack(fill=tk.X, padx=10, pady=10)
        
        self.files_listbox = tk.Listbox(
            file_frame,
            height=3,
            font=("Arial", 9),
            bg=self.colors['input'],
            fg=self.colors['text']
        )
        self.files_listbox.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        # Custom commands
        cmd_frame = tk.LabelFrame(
            parent,
            text="Custom Commands",
            font=("Arial", 11, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['sidebar'],
            bd=1
        )
        cmd_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.command_entry = tk.Text(
            cmd_frame,
            height=3,
            font=("Consolas", 9),
            bg=self.colors['input'],
            fg=self.colors['text']
        )
        self.command_entry.pack(fill=tk.X, padx=10, pady=10)
        
        tk.Button(
            cmd_frame,
            text="Execute",
            command=self.execute_command,
            font=("Arial", 9),
            bg=self.colors['accent'],
            fg=self.colors['bg'],
            relief=tk.FLAT,
            padx=10,
            pady=5
        ).pack(pady=(0, 10))
        
        # Quick commands
        quick_cmd_frame = tk.LabelFrame(
            parent,
            text="Quick Commands",
            font=("Arial", 11, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['sidebar'],
            bd=1
        )
        quick_cmd_frame.pack(fill=tk.X, padx=10, pady=5)
        
        commands = [
            ("Nmap", "nmap -sV {target}"),
            ("SQLMap", "sqlmap -u {target}"),
            ("Nikto", "nikto -h {target}"),
            ("Metasploit", "msfconsole")
        ]
        
        for name, cmd in commands:
            tk.Button(
                quick_cmd_frame,
                text=name,
                command=lambda c=cmd: self.run_quick_cmd(c),
                font=("Arial", 9),
                bg=self.colors['input'],
                fg=self.colors['text'],
                relief=tk.FLAT,
                padx=8,
                pady=3
            ).pack(fill=tk.X, padx=10, pady=2)
            
        # Terminal output
        terminal_frame = tk.LabelFrame(
            parent,
            text="Terminal",
            font=("Arial", 11, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['sidebar'],
            bd=1
        )
        terminal_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.terminal = scrolledtext.ScrolledText(
            terminal_frame,
            height=8,
            font=("Consolas", 8),
            bg="#000000",
            fg="#00ff00"
        )
        self.terminal.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
    def create_status_bar(self, parent):
        """Create status bar"""
        status_bar = tk.Frame(parent, bg=self.colors['input'], height=25)
        status_bar.pack(fill=tk.X, side=tk.BOTTOM)
        status_bar.pack_propagate(False)
        
        self.status_label = tk.Label(
            status_bar,
            text="Ready - Type or use buttons to start",
            font=("Arial", 9),
            fg=self.colors['text'],
            bg=self.colors['input']
        )
        self.status_label.pack(side=tk.LEFT, padx=10, pady=3)
        
    def show_welcome(self):
        """Show welcome message"""
        welcome = """Welcome to PentestGPT Unified! üéØ

I combine all features in one interface:
‚Ä¢ Natural language chat
‚Ä¢ All pentesting stages
‚Ä¢ File analysis (APK/EXE)
‚Ä¢ Command execution
‚Ä¢ Comprehensive reporting

Just type what you want or click buttons to start!

Examples:
‚Ä¢ "Scan testphp.vulnweb.com"
‚Ä¢ "Find SQL injection"
‚Ä¢ "Get shell access"
‚Ä¢ "Generate report"
"""
        self.add_message("AI", welcome)
        
    def handle_enter(self, event):
        """Handle enter key"""
        if not event.state & 0x1:
            self.send_message()
            return 'break'
            
    def send_message(self):
        """Send chat message"""
        message = self.chat_input.get('1.0', tk.END).strip()
        if message:
            self.add_message("You", message)
            self.chat_input.delete('1.0', tk.END)
            
            # Process in thread
            thread = threading.Thread(
                target=self.process_message,
                args=(message,),
                daemon=True
            )
            thread.start()
            
    def quick_command(self, cmd):
        """Send quick command"""
        self.chat_input.insert('1.0', cmd)
        self.send_message()
        
    def add_message(self, sender, message):
        """Add message to chat"""
        self.chat_display.insert(tk.END, f"\n{sender}: ", "user" if sender == "You" else "ai")
        self.chat_display.insert(tk.END, f"{message}\n")
        self.chat_display.see(tk.END)
        
    def process_message(self, message):
        """Process user message with NLP"""
        msg_lower = message.lower()
        
        # Detect intent
        intent = self.detect_intent(msg_lower)
        
        # Execute based on intent
        if intent == 'scan':
            self.execute_scan()
        elif intent == 'exploit':
            self.execute_exploit()
        elif intent == 'vulnerability':
            self.find_vulnerabilities()
        elif intent == 'sqlinjection':
            self.test_sqli()
        elif intent == 'report':
            self.generate_report()
        elif 'set target' in msg_lower:
            self.set_target_from_msg(message)
        else:
            self.handle_general(message)
            
    def detect_intent(self, message):
        """Detect user intent"""
        for intent, patterns in self.command_patterns.items():
            for pattern in patterns:
                if pattern in message:
                    return intent
        return 'general'
        
    def set_target(self):
        """Set target"""
        target = self.target_entry.get().strip()
        if target:
            self.current_target = target
            self.target_display.config(text=target, fg=self.colors['success'])
            self.status_label.config(text=f"Target set: {target}")
            self.add_message("AI", f"‚úÖ Target set to: {target}")
            
    def set_target_from_msg(self, message):
        """Extract and set target from message"""
        # Extract IP or domain
        import re
        ip_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
        domain_pattern = r'\b(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}\b'
        
        ip_match = re.search(ip_pattern, message)
        domain_match = re.search(domain_pattern, message)
        
        target = None
        if ip_match:
            target = ip_match.group()
        elif domain_match:
            target = domain_match.group()
            
        if target:
            self.target_entry.delete(0, tk.END)
            self.target_entry.insert(0, target)
            self.set_target()
            
    def start_full_pentest(self):
        """Start full pentest"""
        if not self.current_target:
            self.add_message("AI", "‚ùå Please set a target first!")
            return
            
        self.scan_running = True
        self.start_btn.config(state=tk.DISABLED)
        
        thread = threading.Thread(target=self.run_all_stages, daemon=True)
        thread.start()
        
    def run_all_stages(self):
        """Run all pentesting stages"""
        stages = ['recon', 'scanning', 'enumeration', 'vuln_assessment', 
                 'exploitation', 'post_exploit', 'reporting']
        
        for stage in stages:
            if not self.scan_running:
                break
            self.execute_stage(stage)
            time.sleep(1)
            
        self.scan_running = False
        self.root.after(0, lambda: self.start_btn.config(state=tk.NORMAL))
        
    def run_stage(self, stage):
        """Run specific stage"""
        thread = threading.Thread(
            target=lambda: self.execute_stage(stage),
            daemon=True
        )
        thread.start()
        
    def execute_stage(self, stage):
        """Execute a pentesting stage"""
        self.update_stage_status(stage, 'running', 0)
        
        if stage == 'recon':
            self.execute_recon()
        elif stage == 'scanning':
            self.execute_scanning()
        elif stage == 'vuln_assessment':
            self.find_vulnerabilities()
        elif stage == 'exploitation':
            self.execute_exploit()
        elif stage == 'reporting':
            self.generate_report()
            
        self.update_stage_status(stage, 'completed', 100)
        
    def execute_scan(self):
        """Execute scan"""
        if not self.current_target:
            self.add_message("AI", "‚ùå Set a target first!")
            return
            
        self.add_message("AI", f"üîç Scanning {self.current_target}...")
        self.notebook.select(1)  # Switch to recon tab
        
        time.sleep(2)
        
        results = f"""
‚úÖ Scan Complete!

**Open Ports:**
‚Ä¢ 80 - HTTP
‚Ä¢ 443 - HTTPS  
‚Ä¢ 22 - SSH
‚Ä¢ 3306 - MySQL

**Technologies:**
‚Ä¢ Apache 2.4.41
‚Ä¢ PHP 5.6.40
‚Ä¢ MySQL 5.7

**Vulnerabilities Found:**
‚Ä¢ SQL Injection (Critical)
‚Ä¢ XSS (High)
‚Ä¢ Directory Traversal (High)
"""
        self.add_message("AI", results)
        self.tabs['recon'].insert(tk.END, results)
        
    def execute_recon(self):
        """Execute reconnaissance"""
        output = f"[+] Reconnaissance on {self.current_target}\n"
        output += "  DNS Records found\n"
        output += "  Subdomains: www, api, admin\n"
        output += "  Technologies detected\n"
        
        self.tabs['recon'].insert(tk.END, output)
        self.terminal.insert(tk.END, f"$ Starting recon...\n")
        
    def execute_scanning(self):
        """Execute scanning"""
        output = f"[+] Port scan on {self.current_target}\n"
        output += "  Ports: 80, 443, 22, 3306\n"
        
        self.tabs['scan'].insert(tk.END, output)
        
    def find_vulnerabilities(self):
        """Find vulnerabilities"""
        self.add_message("AI", f"üêõ Finding vulnerabilities...")
        self.notebook.select(3)  # Vulns tab
        
        time.sleep(2)
        
        vulns = """
Found Vulnerabilities:

üî¥ SQL Injection
  Location: /login.php
  Severity: Critical
  
üü† XSS
  Location: /search.php
  Severity: High
  
üü° Weak Password
  Location: /admin
  Severity: Medium
"""
        self.add_message("AI", vulns)
        self.tabs['vulns'].insert(tk.END, vulns)
        
    def test_sqli(self):
        """Test SQL injection"""
        self.add_message("AI", "üíâ Testing SQL injection...")
        
        time.sleep(2)
        
        result = """
‚úÖ SQL Injection Confirmed!

Vulnerable: /login.php?id=
Payloads:
‚Ä¢ ' OR '1'='1
‚Ä¢ admin' --

Database: testphp_db
Tables: users, products
"""
        self.add_message("AI", result)
        self.tabs['exploit'].insert(tk.END, result)
        
    def execute_exploit(self):
        """Execute exploitation"""
        self.add_message("AI", "üí£ Exploiting vulnerabilities...")
        self.notebook.select(4)  # Exploit tab
        
        time.sleep(2)
        
        exploit_result = """
‚úÖ Exploitation Successful!

‚Ä¢ Database dumped
‚Ä¢ Admin access gained
‚Ä¢ Webshell uploaded
‚Ä¢ Shell access obtained

$ whoami
www-data
"""
        self.add_message("AI", exploit_result)
        self.tabs['exploit'].insert(tk.END, exploit_result)
        
    def upload_file(self):
        """Upload file for analysis"""
        file_path = filedialog.askopenfilename(
            filetypes=[("APK", "*.apk"), ("EXE", "*.exe"), ("All", "*.*")]
        )
        
        if file_path:
            file_name = Path(file_path).name
            self.files_listbox.insert(tk.END, file_name)
            self.add_message("You", f"Uploaded: {file_name}")
            
            # Analyze
            if file_name.endswith('.apk'):
                self.analyze_apk(file_name)
            elif file_name.endswith('.exe'):
                self.analyze_exe(file_name)
                
    def analyze_apk(self, filename):
        """Analyze APK"""
        self.add_message("AI", f"üì± Analyzing {filename}...")
        
        time.sleep(2)
        
        analysis = f"""
APK Analysis Complete!

**Package:** com.example.app
**Permissions:** 15 (5 dangerous)

**Security Issues:**
‚Ä¢ Hardcoded API keys
‚Ä¢ No certificate pinning
‚Ä¢ Debuggable enabled
‚Ä¢ Weak crypto (MD5)

**Extracted:**
‚Ä¢ API Key: sk_live_424242
‚Ä¢ DB Password: admin123
"""
        self.add_message("AI", analysis)
        
    def analyze_exe(self, filename):
        """Analyze EXE"""
        self.add_message("AI", f"üîç Analyzing {filename}...")
        
        time.sleep(2)
        
        analysis = f"""
EXE Analysis Complete!

**File:** {filename}
**Size:** 2.4 MB

**Suspicious Indicators:**
‚Ä¢ Packed with UPX
‚Ä¢ Anti-debugging detected
‚Ä¢ Network connections
‚Ä¢ Registry modifications

**Verdict:** üî¥ Likely Malware
"""
        self.add_message("AI", analysis)
        
    def generate_report(self):
        """Generate report"""
        self.add_message("AI", "üìÑ Generating report...")
        self.notebook.select(5)  # Report tab
        
        time.sleep(2)
        
        report = f"""
PENETRATION TEST REPORT
======================
Target: {self.current_target}
Date: {datetime.now().strftime('%Y-%m-%d')}

SUMMARY
-------
Critical: 1
High: 2
Medium: 3

VULNERABILITIES
--------------
1. SQL Injection (Critical)
2. XSS (High)
3. Directory Traversal (High)

RECOMMENDATIONS
--------------
1. Fix SQL injection
2. Input validation
3. Update software
"""
        self.add_message("AI", "‚úÖ Report generated!")
        self.tabs['report'].insert(tk.END, report)
        
    def execute_command(self):
        """Execute custom command"""
        cmd = self.command_entry.get('1.0', tk.END).strip()
        if cmd:
            self.terminal.insert(tk.END, f"$ {cmd}\n")
            self.terminal.insert(tk.END, "Executing...\n")
            self.command_entry.delete('1.0', tk.END)
            
    def run_quick_cmd(self, cmd_template):
        """Run quick command"""
        if self.current_target:
            cmd = cmd_template.replace('{target}', self.current_target)
            self.terminal.insert(tk.END, f"$ {cmd}\n")
            
    def handle_general(self, message):
        """Handle general queries"""
        self.add_message("AI", f"""
I understand: "{message}"

I can help with:
‚Ä¢ Scanning targets
‚Ä¢ Finding vulnerabilities
‚Ä¢ Exploitation
‚Ä¢ File analysis
‚Ä¢ Reporting

Try: "scan [target]" or click the buttons!
""")
        
    def update_stage_status(self, stage, status, progress):
        """Update stage status"""
        if stage in self.stage_widgets:
            widgets = self.stage_widgets[stage]
            
            if status == 'pending':
                widgets['status'].config(text="‚óã", fg=self.colors['text'])
            elif status == 'running':
                widgets['status'].config(text="‚óê", fg=self.colors['warning'])
            elif status == 'completed':
                widgets['status'].config(text="‚óè", fg=self.colors['success'])
                
            if progress > 0:
                widgets['progress'].config(text=f"{progress}%")
                
    def process_output(self):
        """Process output queue"""
        try:
            while True:
                output = self.output_queue.get_nowait()
                self.terminal.insert(tk.END, output)
                self.terminal.see(tk.END)
        except:
            pass
            
        self.root.after(100, self.process_output)
        
    def run(self):
        """Run application"""
        self.root.mainloop()


if __name__ == "__main__":
    app = PentestGPTUnified()
    app.run()
