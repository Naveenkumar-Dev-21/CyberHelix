#!/usr/bin/env python3
"""
Automatic Pentesting Tool - GUI Interface
A beginner-friendly graphical interface for automated penetration testing
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import threading
import queue
import json
import sys
import os
from pathlib import Path
from datetime import datetime
import subprocess
from typing import Dict, Any, Optional, List

# Add src to path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Import pentesting modules
from src.config import Config
from src.reconnaissance import ReconnaissanceModule
from src.vulnerability_scanner import VulnerabilityScanner
from src.payload_generator import PayloadGenerator
from src.target_classifier import TargetClassifier
from src.service_analyzer import ServiceAnalyzer
from src.network_assessor import NetworkAssessor
from src.web_assessor import WebAssessor
from src.wireless_assessor import WirelessAssessor
from src.mobile_assessor import MobileAssessor
from src.cloud_assessor import CloudAssessor
from src.report_generator import ReportGenerator
from src.agentic_ai import AgenticPentestAI
from src.nlp_processor import AdvancedNLPProcessor
from src.utils import is_valid_domain, is_valid_ip, is_valid_url


class PentestingGUI:
    """Main GUI Application for Automatic Pentesting Tool"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("ğŸ”’ Automatic Pentesting Tool - Professional Edition")
        self.root.geometry("1400x900")
        
        # Set theme colors
        self.bg_color = "#1e1e1e"
        self.fg_color = "#ffffff"
        self.accent_color = "#00ff41"
        self.button_bg = "#2d2d2d"
        self.entry_bg = "#2d2d2d"
        
        self.root.configure(bg=self.bg_color)
        
        # Initialize modules
        self.init_modules()
        
        # Queue for thread communication
        self.output_queue = queue.Queue()
        
        # Current operation thread
        self.current_thread = None
        
        # Scan results storage
        self.scan_results = {}
        
        # Setup GUI
        self.setup_gui()
        
        # Start output monitor
        self.monitor_output()
        
    def init_modules(self):
        """Initialize all pentesting modules"""
        try:
            self.recon_module = ReconnaissanceModule()
            self.vuln_scanner = VulnerabilityScanner()
            self.payload_gen = PayloadGenerator()
            self.target_classifier = TargetClassifier()
            self.service_analyzer = ServiceAnalyzer()
            self.network_assessor = NetworkAssessor()
            self.web_assessor = WebAssessor()
            self.wireless_assessor = WirelessAssessor()
            self.mobile_assessor = MobileAssessor()
            self.cloud_assessor = CloudAssessor()
            self.report_gen = ReportGenerator()
            self.ai_agent = AgenticPentestAI()
            self.nlp_processor = AdvancedNLPProcessor()
        except Exception as e:
            messagebox.showerror("Initialization Error", f"Failed to initialize modules: {str(e)}")
            
    def setup_gui(self):
        """Setup the GUI layout"""
        # Create main container
        main_container = ttk.Frame(self.root)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title Section
        self.create_title_section(main_container)
        
        # Create notebook for tabs
        self.notebook = ttk.Notebook(main_container)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Create tabs
        self.create_quick_scan_tab()
        self.create_advanced_scan_tab()
        self.create_ai_assistant_tab()
        self.create_payload_generator_tab()
        self.create_results_tab()
        
    def create_title_section(self, parent):
        """Create title section with logo and description"""
        title_frame = tk.Frame(parent, bg=self.bg_color)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        # ASCII Art Logo
        logo_text = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â•‘
â•‘ â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•‘
â•‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â•‘
â•‘ â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•‘
â•‘ â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•‘
â•‘ â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•    â•šâ•â•    â•šâ•â•â•â•â•â•     â•šâ•â•     â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """
        
        logo_label = tk.Label(title_frame, text=logo_text, font=("Courier", 8), 
                             fg=self.accent_color, bg=self.bg_color)
        logo_label.pack()
        
        subtitle = tk.Label(title_frame, 
                           text="Professional Automated Penetration Testing Framework",
                           font=("Arial", 14, "bold"), 
                           fg=self.fg_color, bg=self.bg_color)
        subtitle.pack()
        
    def create_quick_scan_tab(self):
        """Create the quick scan tab for beginners"""
        quick_frame = ttk.Frame(self.notebook)
        self.notebook.add(quick_frame, text="ğŸš€ Quick Scan")
        
        # Instructions
        instructions = tk.Label(quick_frame, 
                               text="Enter a target (URL, IP, or Domain) and click Scan to begin automated testing",
                               font=("Arial", 11), fg="#666666")
        instructions.pack(pady=10)
        
        # Target input section
        target_frame = tk.Frame(quick_frame)
        target_frame.pack(pady=20)
        
        tk.Label(target_frame, text="Target:", font=("Arial", 12)).pack(side=tk.LEFT, padx=5)
        self.target_entry = tk.Entry(target_frame, width=50, font=("Arial", 11))
        self.target_entry.pack(side=tk.LEFT, padx=5)
        
        # File input button
        self.file_button = tk.Button(target_frame, text="ğŸ“ Load from File", 
                                     command=self.load_targets_from_file,
                                     bg=self.button_bg, fg=self.fg_color,
                                     font=("Arial", 10))
        self.file_button.pack(side=tk.LEFT, padx=5)
        
        # Scan options
        options_frame = tk.LabelFrame(quick_frame, text="Scan Options", font=("Arial", 11))
        options_frame.pack(pady=10, padx=20, fill=tk.X)
        
        # Checkboxes for scan types
        self.scan_options = {
            'reconnaissance': tk.BooleanVar(value=True),
            'vulnerability': tk.BooleanVar(value=True),
            'service_analysis': tk.BooleanVar(value=True),
            'payload_generation': tk.BooleanVar(value=False),
            'stealth_mode': tk.BooleanVar(value=False)
        }
        
        option_labels = {
            'reconnaissance': 'ğŸ” Reconnaissance & Discovery',
            'vulnerability': 'ğŸ› Vulnerability Scanning',
            'service_analysis': 'ğŸ”§ Service Analysis',
            'payload_generation': 'ğŸ’£ Payload Generation',
            'stealth_mode': 'ğŸ¥· Stealth Mode (Slower)'
        }
        
        for i, (key, var) in enumerate(self.scan_options.items()):
            cb = tk.Checkbutton(options_frame, text=option_labels[key], 
                               variable=var, font=("Arial", 10))
            cb.grid(row=i//2, column=i%2, sticky=tk.W, padx=10, pady=5)
        
        # Scan button
        self.scan_button = tk.Button(quick_frame, text="ğŸš€ START SCAN", 
                                    command=self.start_quick_scan,
                                    bg="#00ff41", fg="#000000",
                                    font=("Arial", 14, "bold"),
                                    height=2, width=20)
        self.scan_button.pack(pady=20)
        
        # Progress bar
        self.progress_var = tk.StringVar(value="Ready")
        self.progress_label = tk.Label(quick_frame, textvariable=self.progress_var,
                                      font=("Arial", 10))
        self.progress_label.pack()
        
        self.progress_bar = ttk.Progressbar(quick_frame, mode='indeterminate')
        self.progress_bar.pack(fill=tk.X, padx=20, pady=5)
        
        # Output display
        output_label = tk.Label(quick_frame, text="Scan Output:", font=("Arial", 11))
        output_label.pack(anchor=tk.W, padx=20)
        
        self.output_text = scrolledtext.ScrolledText(quick_frame, height=15, 
                                                     bg="#1a1a1a", fg="#00ff41",
                                                     font=("Courier", 10))
        self.output_text.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
    def create_advanced_scan_tab(self):
        """Create advanced scan tab for experienced users"""
        advanced_frame = ttk.Frame(self.notebook)
        self.notebook.add(advanced_frame, text="âš™ï¸ Advanced Scan")
        
        # Left panel - Configuration
        left_panel = tk.Frame(advanced_frame)
        left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Target configuration
        target_config = tk.LabelFrame(left_panel, text="Target Configuration", 
                                     font=("Arial", 11))
        target_config.pack(fill=tk.X, pady=5)
        
        tk.Label(target_config, text="Target(s):", font=("Arial", 10)).grid(row=0, column=0, sticky=tk.W, padx=5)
        self.adv_target_text = tk.Text(target_config, height=3, width=40)
        self.adv_target_text.grid(row=0, column=1, padx=5, pady=5)
        
        tk.Label(target_config, text="Port Range:", font=("Arial", 10)).grid(row=1, column=0, sticky=tk.W, padx=5)
        self.port_entry = tk.Entry(target_config, width=20)
        self.port_entry.insert(0, "1-1000")
        self.port_entry.grid(row=1, column=1, sticky=tk.W, padx=5, pady=5)
        
        # Scan modules selection
        modules_frame = tk.LabelFrame(left_panel, text="Select Modules", font=("Arial", 11))
        modules_frame.pack(fill=tk.X, pady=10)
        
        self.modules = {
            'nmap': tk.BooleanVar(value=True),
            'nuclei': tk.BooleanVar(value=True),
            'nikto': tk.BooleanVar(value=False),
            'sqlmap': tk.BooleanVar(value=False),
            'metasploit': tk.BooleanVar(value=False),
            'custom_exploits': tk.BooleanVar(value=False)
        }
        
        for module, var in self.modules.items():
            cb = tk.Checkbutton(modules_frame, text=module.upper(), variable=var)
            cb.pack(anchor=tk.W, padx=10, pady=2)
        
        # Timing and performance
        timing_frame = tk.LabelFrame(left_panel, text="Timing & Performance", font=("Arial", 11))
        timing_frame.pack(fill=tk.X, pady=10)
        
        tk.Label(timing_frame, text="Scan Speed:", font=("Arial", 10)).pack(anchor=tk.W, padx=5)
        self.speed_var = tk.StringVar(value="normal")
        speeds = [("Paranoid (0)", "paranoid"), ("Sneaky (1)", "sneaky"), 
                 ("Polite (2)", "polite"), ("Normal (3)", "normal"),
                 ("Aggressive (4)", "aggressive"), ("Insane (5)", "insane")]
        
        for text, value in speeds:
            rb = tk.Radiobutton(timing_frame, text=text, variable=self.speed_var, 
                              value=value, font=("Arial", 9))
            rb.pack(anchor=tk.W, padx=20)
        
        # Advanced scan button
        self.adv_scan_button = tk.Button(left_panel, text="âš¡ EXECUTE ADVANCED SCAN",
                                        command=self.start_advanced_scan,
                                        bg="#ff6b00", fg="#ffffff",
                                        font=("Arial", 12, "bold"),
                                        height=2)
        self.adv_scan_button.pack(pady=20)
        
        # Right panel - Command preview
        right_panel = tk.Frame(advanced_frame)
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        tk.Label(right_panel, text="Command Preview:", font=("Arial", 11)).pack(anchor=tk.W)
        self.command_preview = scrolledtext.ScrolledText(right_panel, height=10,
                                                        bg="#1a1a1a", fg="#00ff41",
                                                        font=("Courier", 9))
        self.command_preview.pack(fill=tk.X, pady=5)
        
        tk.Label(right_panel, text="Advanced Output:", font=("Arial", 11)).pack(anchor=tk.W)
        self.adv_output_text = scrolledtext.ScrolledText(right_panel, height=20,
                                                        bg="#1a1a1a", fg="#00ff41",
                                                        font=("Courier", 9))
        self.adv_output_text.pack(fill=tk.BOTH, expand=True)
        
    def create_ai_assistant_tab(self):
        """Create AI Assistant tab for natural language commands"""
        ai_frame = ttk.Frame(self.notebook)
        self.notebook.add(ai_frame, text="ğŸ¤– AI Assistant")
        
        # Instructions
        instructions = tk.Label(ai_frame,
                              text="Type your pentesting request in natural language",
                              font=("Arial", 12))
        instructions.pack(pady=10)
        
        # Examples
        examples_frame = tk.LabelFrame(ai_frame, text="Example Commands", font=("Arial", 11))
        examples_frame.pack(fill=tk.X, padx=20, pady=10)
        
        examples = [
            "â€¢ Scan example.com for vulnerabilities",
            "â€¢ Find all open ports on 192.168.1.1",
            "â€¢ Generate a reverse shell payload for Windows",
            "â€¢ Check if the target is vulnerable to SQL injection",
            "â€¢ Perform a stealth scan on the network 10.0.0.0/24"
        ]
        
        for example in examples:
            tk.Label(examples_frame, text=example, font=("Arial", 10),
                    fg="#666666").pack(anchor=tk.W, padx=10, pady=2)
        
        # Chat interface
        chat_frame = tk.Frame(ai_frame)
        chat_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        # Chat history
        self.chat_history = scrolledtext.ScrolledText(chat_frame, height=20,
                                                     bg="#1a1a1a", fg="#ffffff",
                                                     font=("Courier", 10))
        self.chat_history.pack(fill=tk.BOTH, expand=True)
        
        # Input area
        input_frame = tk.Frame(chat_frame)
        input_frame.pack(fill=tk.X, pady=10)
        
        self.ai_input = tk.Entry(input_frame, font=("Arial", 11))
        self.ai_input.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.ai_input.bind("<Return>", lambda e: self.send_ai_command())
        
        self.ai_send_button = tk.Button(input_frame, text="Send ğŸ“¤",
                                       command=self.send_ai_command,
                                       bg=self.accent_color, fg="#000000",
                                       font=("Arial", 11, "bold"))
        self.ai_send_button.pack(side=tk.RIGHT)
        
        # Add initial message
        self.add_chat_message("AI", "Hello! I'm your AI pentesting assistant. How can I help you today?")
        
    def create_payload_generator_tab(self):
        """Create payload generator tab"""
        payload_frame = ttk.Frame(self.notebook)
        self.notebook.add(payload_frame, text="ğŸ’£ Payload Generator")
        
        # Payload configuration
        config_frame = tk.LabelFrame(payload_frame, text="Payload Configuration", 
                                    font=("Arial", 11))
        config_frame.pack(fill=tk.X, padx=20, pady=10)
        
        # Payload type
        tk.Label(config_frame, text="Payload Type:", font=("Arial", 10)).grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        self.payload_type = ttk.Combobox(config_frame, values=["reverse_shell", "bind_shell", "web_shell", "meterpreter"])
        self.payload_type.set("reverse_shell")
        self.payload_type.grid(row=0, column=1, padx=5, pady=5)
        
        # Platform
        tk.Label(config_frame, text="Platform:", font=("Arial", 10)).grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)
        self.platform = ttk.Combobox(config_frame, values=["windows", "linux", "android", "web"])
        self.platform.set("windows")
        self.platform.grid(row=1, column=1, padx=5, pady=5)
        
        # LHOST
        tk.Label(config_frame, text="LHOST:", font=("Arial", 10)).grid(row=2, column=0, sticky=tk.W, padx=5, pady=5)
        self.lhost_entry = tk.Entry(config_frame)
        self.lhost_entry.insert(0, "127.0.0.1")
        self.lhost_entry.grid(row=2, column=1, padx=5, pady=5)
        
        # LPORT
        tk.Label(config_frame, text="LPORT:", font=("Arial", 10)).grid(row=3, column=0, sticky=tk.W, padx=5, pady=5)
        self.lport_entry = tk.Entry(config_frame)
        self.lport_entry.insert(0, "4444")
        self.lport_entry.grid(row=3, column=1, padx=5, pady=5)
        
        # Evasion options
        evasion_frame = tk.LabelFrame(payload_frame, text="Evasion Options", font=("Arial", 11))
        evasion_frame.pack(fill=tk.X, padx=20, pady=10)
        
        self.evasion_options = {
            'encoding': tk.BooleanVar(value=False),
            'encryption': tk.BooleanVar(value=False),
            'obfuscation': tk.BooleanVar(value=False),
            'sandbox_bypass': tk.BooleanVar(value=False)
        }
        
        for option, var in self.evasion_options.items():
            cb = tk.Checkbutton(evasion_frame, text=option.replace('_', ' ').title(),
                              variable=var, font=("Arial", 10))
            cb.pack(anchor=tk.W, padx=10, pady=2)
        
        # Generate button
        self.generate_button = tk.Button(payload_frame, text="ğŸ”¨ GENERATE PAYLOAD",
                                        command=self.generate_payload,
                                        bg="#9b59b6", fg="#ffffff",
                                        font=("Arial", 12, "bold"),
                                        height=2)
        self.generate_button.pack(pady=20)
        
        # Payload output
        tk.Label(payload_frame, text="Generated Payload:", font=("Arial", 11)).pack(anchor=tk.W, padx=20)
        self.payload_output = scrolledtext.ScrolledText(payload_frame, height=15,
                                                       bg="#1a1a1a", fg="#00ff41",
                                                       font=("Courier", 10))
        self.payload_output.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
    def create_results_tab(self):
        """Create results and reporting tab"""
        results_frame = ttk.Frame(self.notebook)
        self.notebook.add(results_frame, text="ğŸ“Š Results & Reports")
        
        # Results tree view
        tree_frame = tk.Frame(results_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        tk.Label(tree_frame, text="Scan Results:", font=("Arial", 11)).pack(anchor=tk.W)
        
        # Create treeview with scrollbar
        tree_scroll = tk.Scrollbar(tree_frame)
        tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.results_tree = ttk.Treeview(tree_frame, yscrollcommand=tree_scroll.set)
        tree_scroll.config(command=self.results_tree.yview)
        
        # Define columns
        self.results_tree['columns'] = ('Type', 'Severity', 'Details')
        self.results_tree.column('#0', width=200, minwidth=100)
        self.results_tree.column('Type', width=150, minwidth=100)
        self.results_tree.column('Severity', width=100, minwidth=80)
        self.results_tree.column('Details', width=400, minwidth=200)
        
        # Create headings
        self.results_tree.heading('#0', text='Target', anchor=tk.W)
        self.results_tree.heading('Type', text='Type', anchor=tk.W)
        self.results_tree.heading('Severity', text='Severity', anchor=tk.W)
        self.results_tree.heading('Details', text='Details', anchor=tk.W)
        
        self.results_tree.pack(fill=tk.BOTH, expand=True)
        
        # Export buttons
        export_frame = tk.Frame(results_frame)
        export_frame.pack(fill=tk.X, padx=20, pady=10)
        
        tk.Button(export_frame, text="ğŸ“„ Export as JSON",
                 command=lambda: self.export_results('json'),
                 bg=self.button_bg, fg=self.fg_color).pack(side=tk.LEFT, padx=5)
        
        tk.Button(export_frame, text="ğŸ“„ Export as HTML",
                 command=lambda: self.export_results('html'),
                 bg=self.button_bg, fg=self.fg_color).pack(side=tk.LEFT, padx=5)
        
        tk.Button(export_frame, text="ğŸ“„ Export as PDF",
                 command=lambda: self.export_results('pdf'),
                 bg=self.button_bg, fg=self.fg_color).pack(side=tk.LEFT, padx=5)
        
        tk.Button(export_frame, text="ğŸ”„ Refresh Results",
                 command=self.refresh_results,
                 bg=self.button_bg, fg=self.fg_color).pack(side=tk.LEFT, padx=5)
        
    def load_targets_from_file(self):
        """Load targets from a file"""
        filename = filedialog.askopenfilename(
            title="Select targets file",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if filename:
            try:
                with open(filename, 'r') as f:
                    targets = f.read().strip()
                    self.target_entry.delete(0, tk.END)
                    self.target_entry.insert(0, targets.replace('\n', ', '))
                    self.output_text.insert(tk.END, f"âœ… Loaded targets from {filename}\n")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load file: {str(e)}")
    
    def start_quick_scan(self):
        """Start a quick scan with selected options"""
        target = self.target_entry.get().strip()
        
        if not target:
            messagebox.showwarning("Input Required", "Please enter a target!")
            return
        
        # Validate target
        if not (is_valid_domain(target) or is_valid_ip(target) or is_valid_url(target)):
            messagebox.showerror("Invalid Target", "Please enter a valid URL, IP address, or domain!")
            return
        
        # Disable scan button
        self.scan_button.config(state=tk.DISABLED)
        self.progress_bar.start()
        self.progress_var.set("Scanning in progress...")
        
        # Clear output
        self.output_text.delete(1.0, tk.END)
        self.output_text.insert(tk.END, f"ğŸš€ Starting scan on: {target}\n")
        self.output_text.insert(tk.END, "="*60 + "\n\n")
        
        # Start scan in separate thread
        self.current_thread = threading.Thread(target=self.run_quick_scan, args=(target,))
        self.current_thread.daemon = True
        self.current_thread.start()
    
    def run_quick_scan(self, target):
        """Run the actual quick scan (in thread)"""
        try:
            results = {}
            
            # Phase 1: Target Classification
            if True:  # Always run
                self.output_queue.put(("info", "ğŸ¯ Phase 1: Target Classification\n"))
                classification = self.target_classifier.classify_target(target)
                results['classification'] = classification
                self.output_queue.put(("success", f"Target Type: {classification.get('type', 'Unknown')}\n"))
                self.output_queue.put(("info", f"Recommended Scans: {', '.join(classification.get('recommended_scans', []))}\n\n"))
            
            # Phase 2: Reconnaissance
            if self.scan_options['reconnaissance'].get():
                self.output_queue.put(("info", "ğŸ” Phase 2: Reconnaissance\n"))
                recon_results = self.recon_module.scan_target(target)
                results['reconnaissance'] = recon_results
                
                # Display key findings
                if 'nmap_scan' in recon_results:
                    ports = recon_results['nmap_scan'].get('open_ports', [])
                    self.output_queue.put(("success", f"Found {len(ports)} open ports\n"))
                
                if 'subdomains' in recon_results:
                    subs = recon_results.get('subdomains', [])
                    self.output_queue.put(("success", f"Found {len(subs)} subdomains\n"))
                
                self.output_queue.put(("info", "\n"))
            
            # Phase 3: Service Analysis
            if self.scan_options['service_analysis'].get():
                self.output_queue.put(("info", "ğŸ”§ Phase 3: Service Analysis\n"))
                
                # Get open ports from recon
                open_ports = {}
                if 'reconnaissance' in results:
                    nmap_data = results['reconnaissance'].get('nmap_scan', {})
                    if 'hosts' in nmap_data:
                        for host, host_data in nmap_data['hosts'].items():
                            if 'protocols' in host_data:
                                for protocol, ports in host_data['protocols'].items():
                                    if protocol == 'tcp':
                                        open_ports = ports
                                        break
                
                if open_ports:
                    service_results = self.service_analyzer.analyze_services(target, open_ports)
                    results['services'] = service_results
                    self.output_queue.put(("success", f"Analyzed {len(open_ports)} services\n"))
                    
                    # Show vulnerable services
                    if 'service_analyses' in service_results:
                        vuln_count = sum(1 for s in service_results['service_analyses'].values() 
                                       if s.get('vulnerabilities'))
                        if vuln_count > 0:
                            self.output_queue.put(("warning", f"âš ï¸ Found {vuln_count} potentially vulnerable services\n"))
                
                self.output_queue.put(("info", "\n"))
            
            # Phase 4: Vulnerability Scanning
            if self.scan_options['vulnerability'].get():
                self.output_queue.put(("info", "ğŸ› Phase 4: Vulnerability Scanning\n"))
                vuln_results = self.vuln_scanner.scan_target(target, scan_type='quick')
                results['vulnerabilities'] = vuln_results
                
                # Display vulnerability summary
                total_vulns = vuln_results.get('summary', {}).get('total_vulnerabilities', 0)
                critical = vuln_results.get('summary', {}).get('severity_breakdown', {}).get('critical', 0)
                high = vuln_results.get('summary', {}).get('severity_breakdown', {}).get('high', 0)
                
                self.output_queue.put(("success", f"Total Vulnerabilities: {total_vulns}\n"))
                if critical > 0:
                    self.output_queue.put(("error", f"ğŸš¨ Critical: {critical}\n"))
                if high > 0:
                    self.output_queue.put(("warning", f"âš ï¸ High: {high}\n"))
                
                self.output_queue.put(("info", "\n"))
            
            # Phase 5: Payload Generation
            if self.scan_options['payload_generation'].get():
                self.output_queue.put(("info", "ğŸ’£ Phase 5: Payload Generation\n"))
                
                # Gather vulnerabilities for payload generation
                all_vulns = []
                if 'vulnerabilities' in results:
                    for source in ['nuclei_results', 'nikto_results']:
                        if source in results['vulnerabilities']:
                            all_vulns.extend(results['vulnerabilities'][source])
                
                payload_results = self.payload_gen.generate_payloads(
                    results.get('reconnaissance', {}),
                    all_vulns
                )
                results['payloads'] = payload_results
                
                payload_count = len(payload_results.get('payloads', []))
                self.output_queue.put(("success", f"Generated {payload_count} payloads\n"))
                self.output_queue.put(("info", "\n"))
            
            # Save results
            self.scan_results[target] = results
            
            # Generate summary
            self.output_queue.put(("info", "="*60 + "\n"))
            self.output_queue.put(("success", "âœ… SCAN COMPLETE\n"))
            self.output_queue.put(("info", "="*60 + "\n\n"))
            
            # Save to file
            output_file = Path(Config.OUTPUT_DIR) / f"scan_{target.replace('.', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            with open(output_file, 'w') as f:
                json.dump(results, f, indent=2, default=str)
            
            self.output_queue.put(("success", f"ğŸ“ Results saved to: {output_file}\n"))
            
            # Update results tree
            self.update_results_tree(target, results)
            
        except Exception as e:
            self.output_queue.put(("error", f"âŒ Error during scan: {str(e)}\n"))
        finally:
            self.output_queue.put(("complete", None))
    
    def start_advanced_scan(self):
        """Start an advanced scan with custom configuration"""
        targets = self.adv_target_text.get(1.0, tk.END).strip()
        
        if not targets:
            messagebox.showwarning("Input Required", "Please enter at least one target!")
            return
        
        # Build command preview
        command_parts = []
        
        # Add module commands
        if self.modules['nmap'].get():
            command_parts.append(f"nmap -sV -sC -p{self.port_entry.get()} {targets}")
        if self.modules['nuclei'].get():
            command_parts.append(f"nuclei -u {targets}")
        if self.modules['nikto'].get():
            command_parts.append(f"nikto -h {targets}")
        
        # Update command preview
        self.command_preview.delete(1.0, tk.END)
        for cmd in command_parts:
            self.command_preview.insert(tk.END, cmd + "\n")
        
        # Clear output
        self.adv_output_text.delete(1.0, tk.END)
        
        # Disable button
        self.adv_scan_button.config(state=tk.DISABLED)
        
        # Start scan in thread
        self.current_thread = threading.Thread(target=self.run_advanced_scan, args=(targets,))
        self.current_thread.daemon = True
        self.current_thread.start()
    
    def run_advanced_scan(self, targets):
        """Run advanced scan with selected modules"""
        try:
            target_list = [t.strip() for t in targets.split('\n') if t.strip()]
            
            for target in target_list:
                self.output_queue.put(("adv_info", f"\nğŸ¯ Scanning: {target}\n"))
                self.output_queue.put(("adv_info", "="*50 + "\n"))
                
                # Run selected modules
                if self.modules['nmap'].get():
                    self.output_queue.put(("adv_info", "\n[NMAP]\n"))
                    # Run actual nmap scan
                    recon_results = self.recon_module.scan_target(target)
                    if 'nmap_scan' in recon_results:
                        self.output_queue.put(("adv_success", f"Open ports: {recon_results['nmap_scan'].get('open_ports', [])}\n"))
                
                if self.modules['nuclei'].get():
                    self.output_queue.put(("adv_info", "\n[NUCLEI]\n"))
                    # Run nuclei scan
                    vuln_results = self.vuln_scanner.scan_target(target)
                    if 'nuclei_results' in vuln_results:
                        for vuln in vuln_results['nuclei_results'][:5]:  # Show first 5
                            self.output_queue.put(("adv_warning", f"Found: {vuln.get('name', 'Unknown')}\n"))
                
                if self.modules['nikto'].get():
                    self.output_queue.put(("adv_info", "\n[NIKTO]\n"))
                    # Would run nikto scan here
                    self.output_queue.put(("adv_info", "Nikto scan would run here...\n"))
                
        except Exception as e:
            self.output_queue.put(("adv_error", f"Error: {str(e)}\n"))
        finally:
            self.output_queue.put(("adv_complete", None))
    
    def send_ai_command(self):
        """Send command to AI assistant"""
        command = self.ai_input.get().strip()
        
        if not command:
            return
        
        # Add user message to chat
        self.add_chat_message("You", command)
        
        # Clear input
        self.ai_input.delete(0, tk.END)
        
        # Disable send button
        self.ai_send_button.config(state=tk.DISABLED)
        
        # Process in thread
        threading.Thread(target=self.process_ai_command, args=(command,), daemon=True).start()
    
    def process_ai_command(self, command):
        """Process AI command using NLP and agentic AI"""
        try:
            # Show thinking message
            self.output_queue.put(("ai_thinking", "AI is thinking..."))
            
            # Process with NLP
            intent = self.nlp_processor.parse_request(command)
            
            # Process with agentic AI
            result = self.ai_agent.process_request(command)
            
            # Format response
            response = self.format_ai_response(intent, result)
            
            # Add AI response to chat
            self.output_queue.put(("ai_response", response))
            
            # Execute if action was determined
            if hasattr(intent, 'targets') and intent.targets:
                self.output_queue.put(("ai_response", f"\nğŸ¯ Executing on targets: {', '.join(intent.targets)}"))
                
                # Run appropriate scans based on intent
                for target in intent.targets:
                    if hasattr(intent, 'intent_type'):
                        if 'recon' in str(intent.intent_type).lower():
                            results = self.recon_module.scan_target(target)
                            self.output_queue.put(("ai_response", f"\nâœ… Reconnaissance complete for {target}"))
                        elif 'vuln' in str(intent.intent_type).lower():
                            results = self.vuln_scanner.scan_target(target)
                            self.output_queue.put(("ai_response", f"\nâœ… Vulnerability scan complete for {target}"))
            
        except Exception as e:
            self.output_queue.put(("ai_error", f"Error: {str(e)}"))
        finally:
            self.output_queue.put(("ai_complete", None))
    
    def format_ai_response(self, intent, result):
        """Format AI response for display"""
        response = []
        
        # Add intent understanding
        if hasattr(intent, 'intent_type'):
            response.append(f"Understood: {intent.intent_type.value}")
        
        # Add targets if found
        if hasattr(intent, 'targets') and intent.targets:
            response.append(f"Targets identified: {', '.join(intent.targets)}")
        
        # Add recommendations from AI
        if isinstance(result, dict):
            if 'recommended_actions' in result:
                response.append("\nRecommended actions:")
                for action in result['recommended_actions'][:3]:
                    response.append(f"â€¢ {action}")
            
            if 'execution_plan' in result:
                response.append("\nExecution plan:")
                for step in result['execution_plan'][:5]:
                    response.append(f"â€¢ {step}")
        
        return '\n'.join(response) if response else "I'll help you with that pentesting task."
    
    def add_chat_message(self, sender, message):
        """Add a message to the chat history"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        # Format message
        if sender == "AI":
            formatted = f"[{timestamp}] ğŸ¤– AI: {message}\n\n"
            self.chat_history.insert(tk.END, formatted, "ai")
            self.chat_history.tag_config("ai", foreground="#00ff41")
        elif sender == "You":
            formatted = f"[{timestamp}] ğŸ‘¤ You: {message}\n\n"
            self.chat_history.insert(tk.END, formatted, "user")
            self.chat_history.tag_config("user", foreground="#00bfff")
        else:
            formatted = f"[{timestamp}] {sender}: {message}\n\n"
            self.chat_history.insert(tk.END, formatted)
        
        # Auto-scroll to bottom
        self.chat_history.see(tk.END)
    
    def generate_payload(self):
        """Generate payload with selected options"""
        payload_type = self.payload_type.get()
        platform = self.platform.get()
        lhost = self.lhost_entry.get()
        lport = self.lport_entry.get()
        
        # Clear output
        self.payload_output.delete(1.0, tk.END)
        self.payload_output.insert(tk.END, f"Generating {payload_type} payload for {platform}...\n\n")
        
        # Disable button
        self.generate_button.config(state=tk.DISABLED)
        
        # Generate in thread
        threading.Thread(target=self.run_payload_generation, 
                        args=(payload_type, platform, lhost, lport),
                        daemon=True).start()
    
    def run_payload_generation(self, payload_type, platform, lhost, lport):
        """Run actual payload generation"""
        try:
            options = {'LHOST': lhost, 'LPORT': int(lport)}
            
            # Generate payloads
            result = self.payload_gen.generate_payloads(
                {'target': f"{platform}_target"},
                []  # No specific vulnerabilities
            )
            
            # Display generated payloads
            if result.get('payloads'):
                for payload in result['payloads']:
                    self.output_queue.put(("payload", f"âœ… Generated: {payload.get('payload_type', 'Unknown')}\n"))
                    if 'command' in payload:
                        self.output_queue.put(("payload", f"Command: {payload['command']}\n"))
                    if 'output_file' in payload:
                        self.output_queue.put(("payload", f"Saved to: {payload['output_file']}\n"))
                    self.output_queue.put(("payload", "\n"))
            
            # Show recommendations
            if result.get('recommendations'):
                self.output_queue.put(("payload", "\nğŸ“‹ Recommendations:\n"))
                for rec in result['recommendations']:
                    self.output_queue.put(("payload", f"â€¢ {rec}\n"))
            
        except Exception as e:
            self.output_queue.put(("payload_error", f"Error: {str(e)}\n"))
        finally:
            self.output_queue.put(("payload_complete", None))
    
    def update_results_tree(self, target, results):
        """Update the results tree with scan findings"""
        # Clear existing items for this target
        for item in self.results_tree.get_children():
            if self.results_tree.item(item, 'text') == target:
                self.results_tree.delete(item)
        
        # Add new results
        target_item = self.results_tree.insert('', 'end', text=target)
        
        # Add reconnaissance results
        if 'reconnaissance' in results:
            recon_item = self.results_tree.insert(target_item, 'end', text='Reconnaissance',
                                                 values=('Recon', 'Info', 'Complete'))
            
            # Add open ports
            if 'nmap_scan' in results['reconnaissance']:
                ports = results['reconnaissance']['nmap_scan'].get('open_ports', [])
                for port in ports[:10]:  # Show first 10
                    self.results_tree.insert(recon_item, 'end', text=f'Port {port}',
                                           values=('Port', 'Open', f'TCP/{port}'))
        
        # Add vulnerabilities
        if 'vulnerabilities' in results:
            vuln_item = self.results_tree.insert(target_item, 'end', text='Vulnerabilities',
                                                values=('Vuln Scan', 'Various', 'Complete'))
            
            # Add specific vulnerabilities
            summary = results['vulnerabilities'].get('summary', {})
            severity_breakdown = summary.get('severity_breakdown', {})
            
            for severity, count in severity_breakdown.items():
                if count > 0:
                    self.results_tree.insert(vuln_item, 'end', text=f'{severity.title()} Vulnerabilities',
                                           values=('Vulnerability', severity.title(), f'Count: {count}'))
        
        # Expand the tree
        self.results_tree.item(target_item, open=True)
    
    def refresh_results(self):
        """Refresh the results display"""
        # Clear tree
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        
        # Re-populate from saved results
        for target, results in self.scan_results.items():
            self.update_results_tree(target, results)
    
    def export_results(self, format_type):
        """Export results in specified format"""
        if not self.scan_results:
            messagebox.showwarning("No Results", "No scan results to export!")
            return
        
        # Get save location
        if format_type == 'json':
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
            )
        elif format_type == 'html':
            filename = filedialog.asksaveasfilename(
                defaultextension=".html",
                filetypes=[("HTML files", "*.html"), ("All files", "*.*")]
            )
        else:  # PDF
            filename = filedialog.asksaveasfilename(
                defaultextension=".pdf",
                filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")]
            )
        
        if filename:
            try:
                if format_type == 'json':
                    with open(filename, 'w') as f:
                        json.dump(self.scan_results, f, indent=2, default=str)
                elif format_type == 'html':
                    # Generate HTML report
                    for target, results in self.scan_results.items():
                        report_data = self.report_gen.generate_comprehensive_report(
                            target,
                            results.get('reconnaissance', {}),
                            results.get('vulnerabilities', {}),
                            results.get('payloads', {})
                        )
                        self.report_gen.save_report(report_data, Path(filename).parent, 'html')
                
                messagebox.showinfo("Export Complete", f"Results exported to {filename}")
            except Exception as e:
                messagebox.showerror("Export Error", f"Failed to export: {str(e)}")
    
    def monitor_output(self):
        """Monitor the output queue and update GUI"""
        try:
            while True:
                msg_type, message = self.output_queue.get_nowait()
                
                if msg_type == "info":
                    self.output_text.insert(tk.END, message)
                elif msg_type == "success":
                    self.output_text.insert(tk.END, message, "success")
                    self.output_text.tag_config("success", foreground="#00ff41")
                elif msg_type == "warning":
                    self.output_text.insert(tk.END, message, "warning")
                    self.output_text.tag_config("warning", foreground="#ffaa00")
                elif msg_type == "error":
                    self.output_text.insert(tk.END, message, "error")
                    self.output_text.tag_config("error", foreground="#ff0000")
                elif msg_type == "complete":
                    self.scan_button.config(state=tk.NORMAL)
                    self.progress_bar.stop()
                    self.progress_var.set("Scan Complete")
                
                # Advanced output
                elif msg_type.startswith("adv_"):
                    if msg_type == "adv_info":
                        self.adv_output_text.insert(tk.END, message)
                    elif msg_type == "adv_success":
                        self.adv_output_text.insert(tk.END, message, "success")
                        self.adv_output_text.tag_config("success", foreground="#00ff41")
                    elif msg_type == "adv_warning":
                        self.adv_output_text.insert(tk.END, message, "warning")
                        self.adv_output_text.tag_config("warning", foreground="#ffaa00")
                    elif msg_type == "adv_error":
                        self.adv_output_text.insert(tk.END, message, "error")
                        self.adv_output_text.tag_config("error", foreground="#ff0000")
                    elif msg_type == "adv_complete":
                        self.adv_scan_button.config(state=tk.NORMAL)
                
                # AI output
                elif msg_type == "ai_thinking":
                    self.add_chat_message("AI", message)
                elif msg_type == "ai_response":
                    self.add_chat_message("AI", message)
                elif msg_type == "ai_error":
                    self.add_chat_message("AI", f"âŒ {message}")
                elif msg_type == "ai_complete":
                    self.ai_send_button.config(state=tk.NORMAL)
                
                # Payload output
                elif msg_type == "payload":
                    self.payload_output.insert(tk.END, message)
                elif msg_type == "payload_error":
                    self.payload_output.insert(tk.END, message, "error")
                    self.payload_output.tag_config("error", foreground="#ff0000")
                elif msg_type == "payload_complete":
                    self.generate_button.config(state=tk.NORMAL)
                
                # Auto-scroll outputs
                self.output_text.see(tk.END)
                self.adv_output_text.see(tk.END)
                self.payload_output.see(tk.END)
                
        except queue.Empty:
            pass
        finally:
            # Schedule next check
            self.root.after(100, self.monitor_output)


def main():
    """Main entry point for the GUI application"""
    # Create output directory if it doesn't exist
    Config.create_output_dirs()
    
    # Create and run the GUI
    root = tk.Tk()
    app = PentestingGUI(root)
    
    # Set window icon (optional)
    try:
        root.iconbitmap('icon.ico')
    except:
        pass
    
    # Start the GUI
    root.mainloop()


if __name__ == "__main__":
    main()
