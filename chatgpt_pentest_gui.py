#!/usr/bin/env python3
"""
ChatGPT-Style AI Penetration Testing Interface
Simple, clean interface with chat functionality, file uploads, and integrated terminal
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import threading
import subprocess
import sys
import os
import json
import time
from datetime import datetime
from pathlib import Path
import tempfile

# Add src to Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

class ChatGPTPentestGUI:
    def __init__(self, root):
        self.root = root
        self.setup_window()
        
        # Application state
        self.conversation_history = []
        self.uploaded_files = []
        self.ai_agent = None
        self.nlp_processor = None
        self.terminal_process = None
        
        # Create interface
        self.create_widgets()
        
        # Initialize AI
        self.initialize_ai()
        
    def setup_window(self):
        """Setup main window"""
        self.root.title("ü§ñ AI Penetration Testing Assistant")
        self.root.geometry("1200x800")
        self.root.minsize(800, 600)
        
        # Configure style
        style = ttk.Style()
        style.theme_use('clam')
        
        # Custom colors (ChatGPT-like)
        self.colors = {
            'bg_primary': '#f7f7f8',
            'bg_secondary': '#ffffff', 
            'user_msg': '#0084ff',
            'ai_msg': '#444654',
            'border': '#e5e5e7',
            'text': '#374151',
            'text_light': '#6b7280'
        }
        
    def create_widgets(self):
        """Create the main interface components"""
        # Main container
        main_container = ttk.Frame(self.root)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Header
        self.create_header(main_container)
        
        # Main content area with splitter
        content_paned = ttk.PanedWindow(main_container, orient=tk.HORIZONTAL)
        content_paned.pack(fill=tk.BOTH, expand=True, pady=(10, 0))
        
        # Left side - Chat interface
        chat_frame = ttk.Frame(content_paned)
        content_paned.add(chat_frame, weight=2)
        
        # Right side - Terminal
        terminal_frame = ttk.Frame(content_paned)
        content_paned.add(terminal_frame, weight=1)
        
        # Create chat interface
        self.create_chat_interface(chat_frame)
        
        # Create terminal interface
        self.create_terminal_interface(terminal_frame)
        
    def create_header(self, parent):
        """Create header with title and status"""
        header_frame = ttk.Frame(parent)
        header_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Title
        title_frame = ttk.Frame(header_frame)
        title_frame.pack(side=tk.LEFT)
        
        title_label = ttk.Label(title_frame, text="ü§ñ AI Penetration Testing Assistant", 
                               font=('Arial', 16, 'bold'))
        title_label.pack()
        
        subtitle_label = ttk.Label(title_frame, text="Ask me anything about penetration testing", 
                                  font=('Arial', 10), foreground='#6b7280')
        subtitle_label.pack()
        
        # Status
        self.status_var = tk.StringVar(value="üî¥ Initializing AI...")
        status_label = ttk.Label(header_frame, textvariable=self.status_var, 
                                font=('Arial', 10))
        status_label.pack(side=tk.RIGHT)
        
    def create_chat_interface(self, parent):
        """Create ChatGPT-like chat interface"""
        chat_container = ttk.Frame(parent)
        chat_container.pack(fill=tk.BOTH, expand=True)
        
        # Chat messages area
        self.create_chat_messages(chat_container)
        
        # Input area
        self.create_input_area(chat_container)
        
    def create_chat_messages(self, parent):
        """Create scrollable chat messages area"""
        # Frame for messages
        messages_frame = ttk.LabelFrame(parent, text="üí¨ Conversation", padding="5")
        messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Scrollable text widget for messages
        self.chat_display = scrolledtext.ScrolledText(
            messages_frame, 
            wrap=tk.WORD,
            font=('Arial', 11),
            bg='#f7f7f8',
            relief=tk.FLAT,
            padx=10,
            pady=10
        )
        self.chat_display.pack(fill=tk.BOTH, expand=True)
        
        # Configure tags for styling
        self.chat_display.tag_configure("user", foreground="#0084ff", font=('Arial', 11, 'bold'))
        self.chat_display.tag_configure("ai", foreground="#444654", font=('Arial', 11, 'bold'))
        self.chat_display.tag_configure("system", foreground="#6b7280", font=('Arial', 10, 'italic'))
        self.chat_display.tag_configure("result", foreground="#059669", font=('Arial', 10))
        self.chat_display.tag_configure("error", foreground="#dc2626", font=('Arial', 10))
        
        # Add welcome message
        self.add_message("system", "üëã Welcome to AI Penetration Testing Assistant!\n\n"
                                  "I can help you with:\n"
                                  "‚Ä¢ üîç Target reconnaissance and analysis\n"
                                  "‚Ä¢ üõ°Ô∏è Vulnerability assessment\n" 
                                  "‚Ä¢ ‚öîÔ∏è Penetration testing guidance\n"
                                  "‚Ä¢ üìä Security report generation\n"
                                  "‚Ä¢ ü§ñ Automated AI-driven assessments\n\n"
                                  "You can also upload files for analysis. Just ask me anything!")
        
    def create_input_area(self, parent):
        """Create input area with file upload"""
        input_frame = ttk.Frame(parent)
        input_frame.pack(fill=tk.X)
        
        # File upload area
        file_frame = ttk.Frame(input_frame)
        file_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Uploaded files display
        self.files_frame = ttk.Frame(file_frame)
        self.files_frame.pack(fill=tk.X)
        
        # File upload button
        upload_frame = ttk.Frame(file_frame)
        upload_frame.pack(fill=tk.X)
        
        ttk.Button(upload_frame, text="üìé Upload Files", 
                  command=self.upload_files).pack(side=tk.LEFT)
        
        ttk.Label(upload_frame, text="Supported: .txt, .csv, .json, .apk, .py, .sh, .conf", 
                 foreground='#6b7280', font=('Arial', 9)).pack(side=tk.LEFT, padx=(10, 0))
        
        # Message input area
        message_frame = ttk.Frame(input_frame)
        message_frame.pack(fill=tk.X)
        
        # Text input
        input_container = ttk.Frame(message_frame)
        input_container.pack(fill=tk.X)
        
        self.message_entry = tk.Text(
            input_container,
            height=3,
            font=('Arial', 11),
            relief=tk.SOLID,
            borderwidth=1,
            padx=10,
            pady=10
        )
        self.message_entry.pack(fill=tk.X, side=tk.LEFT, expand=True)
        
        # Send button
        send_button = ttk.Button(
            input_container,
            text="Send\nüöÄ",
            command=self.send_message,
            width=8
        )
        send_button.pack(side=tk.RIGHT, padx=(5, 0), fill=tk.Y)
        
        # Bind Enter key
        self.message_entry.bind('<Control-Return>', self.send_message)
        
        # Quick action buttons
        quick_frame = ttk.Frame(input_frame)
        quick_frame.pack(fill=tk.X, pady=(10, 0))
        
        quick_buttons = [
            ("üîç Analyze Target", "analyze target"),
            ("üõ°Ô∏è Vulnerability Scan", "scan for vulnerabilities"),
            ("üìä Generate Report", "generate security report"),
            ("ü§ñ AI Assessment", "perform automated AI assessment")
        ]
        
        for text, command in quick_buttons:
            btn = ttk.Button(quick_frame, text=text, 
                           command=lambda cmd=command: self.quick_command(cmd))
            btn.pack(side=tk.LEFT, padx=(0, 5))
    
    def create_terminal_interface(self, parent):
        """Create integrated terminal interface"""
        terminal_container = ttk.LabelFrame(parent, text="üñ•Ô∏è System Terminal", padding="5")
        terminal_container.pack(fill=tk.BOTH, expand=True)
        
        # Terminal display
        self.terminal_display = scrolledtext.ScrolledText(
            terminal_container,
            font=('Consolas', 10),
            bg='#1e1e1e',
            fg='#ffffff',
            insertbackground='#ffffff',
            selectbackground='#404040'
        )
        self.terminal_display.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Terminal input
        terminal_input_frame = ttk.Frame(terminal_container)
        terminal_input_frame.pack(fill=tk.X)
        
        ttk.Label(terminal_input_frame, text="$").pack(side=tk.LEFT)
        
        self.terminal_entry = ttk.Entry(terminal_input_frame, font=('Consolas', 10))
        self.terminal_entry.pack(fill=tk.X, side=tk.LEFT, expand=True, padx=(5, 5))
        self.terminal_entry.bind('<Return>', self.execute_terminal_command)
        
        ttk.Button(terminal_input_frame, text="Execute", 
                  command=self.execute_terminal_command).pack(side=tk.RIGHT)
        
        # Terminal controls
        terminal_controls = ttk.Frame(terminal_container)
        terminal_controls.pack(fill=tk.X, pady=(5, 0))
        
        ttk.Button(terminal_controls, text="Clear", 
                  command=self.clear_terminal).pack(side=tk.LEFT)
        ttk.Button(terminal_controls, text="Save Output", 
                  command=self.save_terminal_output).pack(side=tk.LEFT, padx=(5, 0))
        
        # Initialize terminal
        self.add_terminal_output("AI Penetration Testing Assistant Terminal\n")
        self.add_terminal_output(f"Working directory: {os.getcwd()}\n")
        self.add_terminal_output("Type commands to execute on the system\n\n")
    
    def initialize_ai(self):
        """Initialize AI components in background"""
        def init():
            try:
                self.root.after(0, lambda: self.status_var.set("üü° Loading AI models..."))
                
                # Import AI components
                from src.agentic_ai import AgenticPentestAI
                from src.enhanced_nlp_processor import EnhancedNLPProcessor
                
                self.ai_agent = AgenticPentestAI()
                self.nlp_processor = EnhancedNLPProcessor()
                
                self.root.after(0, lambda: self.status_var.set("üü¢ AI Ready"))
                self.root.after(0, lambda: self.add_message("system", 
                    "‚úÖ AI systems initialized successfully! Ready for penetration testing assistance."))
                
            except Exception as e:
                self.root.after(0, lambda: self.status_var.set("üî¥ AI Error"))
                self.root.after(0, lambda: self.add_message("system", 
                    f"‚ö†Ô∏è AI initialization warning: Some features may be limited.\nError: {str(e)}"))
        
        threading.Thread(target=init, daemon=True).start()
    
    def upload_files(self):
        """Handle file uploads"""
        files = filedialog.askopenfilenames(
            title="Select files to upload",
            filetypes=[
                ("All supported", "*.txt *.csv *.json *.apk *.py *.sh *.conf *.xml *.yaml"),
                ("Text files", "*.txt"),
                ("Data files", "*.csv *.json *.xml *.yaml"),
                ("Mobile apps", "*.apk *.ipa"),
                ("Scripts", "*.py *.sh *.bat"),
                ("Config files", "*.conf *.cfg *.ini"),
                ("All files", "*.*")
            ]
        )
        
        for file_path in files:
            self.add_uploaded_file(file_path)
    
    def add_uploaded_file(self, file_path):
        """Add uploaded file to the interface"""
        if file_path not in self.uploaded_files:
            self.uploaded_files.append(file_path)
            
            # Create file display widget
            file_widget = ttk.Frame(self.files_frame, relief=tk.RAISED, borderwidth=1)
            file_widget.pack(fill=tk.X, pady=2)
            
            # File info
            file_name = os.path.basename(file_path)
            file_size = os.path.getsize(file_path)
            
            info_label = ttk.Label(file_widget, text=f"üìÅ {file_name} ({file_size} bytes)")
            info_label.pack(side=tk.LEFT, padx=5, pady=2)
            
            # Remove button
            remove_btn = ttk.Button(file_widget, text="‚ùå", width=3,
                                  command=lambda fp=file_path, fw=file_widget: self.remove_file(fp, fw))
            remove_btn.pack(side=tk.RIGHT, padx=5, pady=2)
            
            self.add_message("system", f"üìé File uploaded: {file_name}")
    
    def remove_file(self, file_path, widget):
        """Remove uploaded file"""
        if file_path in self.uploaded_files:
            self.uploaded_files.remove(file_path)
            widget.destroy()
            self.add_message("system", f"üóëÔ∏è File removed: {os.path.basename(file_path)}")
    
    def send_message(self, event=None):
        """Send message to AI"""
        message = self.message_entry.get("1.0", tk.END).strip()
        if not message:
            return
        
        # Clear input
        self.message_entry.delete("1.0", tk.END)
        
        # Add user message
        self.add_message("user", message)
        
        # Process message in background
        threading.Thread(target=self.process_message, args=(message,), daemon=True).start()
    
    def process_message(self, message):
        """Process user message with AI"""
        try:
            self.root.after(0, lambda: self.add_message("system", "ü§ñ AI is thinking..."))
            
            # Prepare context with uploaded files
            context = {
                "message": message,
                "uploaded_files": self.uploaded_files,
                "conversation_history": self.conversation_history
            }
            
            # Process with AI
            if self.ai_agent:
                # Use agentic AI for complex requests
                result = self.ai_agent.process_request(message)
                
                # Format AI response
                ai_response = self.format_ai_response(result)
                self.root.after(0, lambda: self.add_message("ai", ai_response))
                
                # Execute any commands if needed
                if "command" in result.get("intent", {}):
                    command = result["intent"]["command"]
                    self.root.after(0, lambda: self.execute_ai_command(command))
                
            elif self.nlp_processor:
                # Use NLP processor for simpler analysis
                intent = self.nlp_processor.process_request(message)
                
                ai_response = f"I understand you want to: {intent.primary_command.value}\n"
                ai_response += f"Confidence: {intent.confidence:.2%}\n"
                
                if intent.targets:
                    ai_response += f"Targets identified: {', '.join(intent.targets)}\n"
                
                ai_response += "\nI can help you with this request. Would you like me to proceed?"
                
                self.root.after(0, lambda: self.add_message("ai", ai_response))
            else:
                # Fallback response
                self.root.after(0, lambda: self.add_message("ai", 
                    "I'm still initializing my AI systems. Please try again in a moment."))
            
            # Store in conversation history
            self.conversation_history.append({
                "user": message,
                "timestamp": datetime.now().isoformat(),
                "files": self.uploaded_files.copy()
            })
            
        except Exception as e:
            error_msg = str(e)
            self.root.after(0, lambda: self.add_message("error", 
                f"Error processing your request: {error_msg}"))
    
    def format_ai_response(self, result):
        """Format AI response for display"""
        response = f"üéØ Intent: {result.get('intent', {}).get('primary', 'Analysis')}\n"
        response += f"üìä Success Rate: {result.get('success_rate', 0):.1%}\n"
        response += f"üîÑ AI Iterations: {result.get('iterations', 0)}\n\n"
        
        if result.get('knowledge_gained'):
            response += "üß† Knowledge Gained:\n"
            for knowledge in result.get('knowledge_gained', [])[:3]:  # Show top 3
                response += f"  ‚Ä¢ {knowledge}\n"
            response += "\n"
        
        if result.get('adaptations'):
            response += "üîß Adaptations Made:\n"
            for adaptation in result.get('adaptations', []):
                response += f"  ‚Ä¢ {adaptation}\n"
            response += "\n"
        
        response += f"‚è±Ô∏è Processing Time: {result.get('total_time', 0):.2f}s\n\n"
        response += "The AI assessment has been completed. Check the terminal for any executed commands."
        
        return response
    
    def execute_ai_command(self, command):
        """Execute AI-generated command in terminal"""
        self.add_terminal_output(f"# AI-generated command:\n")
        self.add_terminal_output(f"$ {command}\n")
        self.execute_command(command)
    
    def quick_command(self, command):
        """Execute quick command"""
        self.message_entry.insert("1.0", command)
        self.send_message()
    
    def add_message(self, sender, content):
        """Add message to chat display"""
        timestamp = datetime.now().strftime("%H:%M")
        
        if sender == "user":
            prefix = f"üë§ You ({timestamp}):\n"
            self.chat_display.insert(tk.END, prefix, "user")
        elif sender == "ai":
            prefix = f"ü§ñ AI Assistant ({timestamp}):\n"
            self.chat_display.insert(tk.END, prefix, "ai")
        elif sender == "system":
            prefix = f"‚ÑπÔ∏è System ({timestamp}):\n"
            self.chat_display.insert(tk.END, prefix, "system")
        elif sender == "error":
            prefix = f"‚ùå Error ({timestamp}):\n"
            self.chat_display.insert(tk.END, prefix, "error")
        
        self.chat_display.insert(tk.END, f"{content}\n\n")
        self.chat_display.see(tk.END)
    
    def execute_terminal_command(self, event=None):
        """Execute command in terminal"""
        command = self.terminal_entry.get().strip()
        if not command:
            return
        
        self.terminal_entry.delete(0, tk.END)
        self.add_terminal_output(f"$ {command}\n")
        
        # Execute command
        self.execute_command(command)
    
    def execute_command(self, command):
        """Execute system command"""
        try:
            # Execute command in background
            def run_command():
                try:
                    # Change to project directory
                    os.chdir('/home/naveen/Documents/Projects/automatic-pentesting')
                    
                    # Execute command
                    result = subprocess.run(
                        command,
                        shell=True,
                        capture_output=True,
                        text=True,
                        timeout=30
                    )
                    
                    # Display output
                    if result.stdout:
                        self.root.after(0, lambda: self.add_terminal_output(result.stdout))
                    if result.stderr:
                        self.root.after(0, lambda: self.add_terminal_output(f"ERROR: {result.stderr}", "error"))
                    
                    # Add command completion
                    exit_code = result.returncode
                    if exit_code == 0:
                        self.root.after(0, lambda: self.add_terminal_output(f"‚úÖ Command completed successfully\n"))
                    else:
                        self.root.after(0, lambda: self.add_terminal_output(f"‚ùå Command failed (exit code: {exit_code})\n"))
                        
                except subprocess.TimeoutExpired:
                    self.root.after(0, lambda: self.add_terminal_output("‚è∞ Command timed out (30s limit)\n"))
                except Exception as e:
                    self.root.after(0, lambda: self.add_terminal_output(f"Error executing command: {str(e)}\n"))
            
            threading.Thread(target=run_command, daemon=True).start()
            
        except Exception as e:
            self.add_terminal_output(f"Error: {str(e)}\n")
    
    def add_terminal_output(self, text, style="normal"):
        """Add output to terminal display"""
        if style == "error":
            # Red color for errors
            self.terminal_display.insert(tk.END, text)
        else:
            self.terminal_display.insert(tk.END, text)
        
        self.terminal_display.see(tk.END)
    
    def clear_terminal(self):
        """Clear terminal display"""
        self.terminal_display.delete(1.0, tk.END)
        self.add_terminal_output("Terminal cleared\n\n")
    
    def save_terminal_output(self):
        """Save terminal output to file"""
        content = self.terminal_display.get(1.0, tk.END)
        
        file_path = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if file_path:
            try:
                with open(file_path, 'w') as f:
                    f.write(content)
                self.add_message("system", f"Terminal output saved to: {file_path}")
            except Exception as e:
                self.add_message("error", f"Failed to save terminal output: {str(e)}")

def main():
    """Main application entry point"""
    root = tk.Tk()
    app = ChatGPTPentestGUI(root)
    
    # Handle window close
    def on_closing():
        if messagebox.askokcancel("Quit", "Do you want to quit the AI Penetration Testing Assistant?"):
            root.destroy()
    
    root.protocol("WM_DELETE_WINDOW", on_closing)
    
    # Start the application
    root.mainloop()

if __name__ == "__main__":
    main()
