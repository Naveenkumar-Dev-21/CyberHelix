#!/usr/bin/env python3
"""
PentestGPT - AI Penetration Testing Assistant
Enhanced with modern UI and better functionality
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import threading
import subprocess
import sys
import os
import json
import time
import re
from datetime import datetime
from pathlib import Path
import queue

# Add src to Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

class ModernPentestGUI:
    """Modern ChatGPT-style interface for AI-driven penetration testing"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("PentestGPT - AI Penetration Testing Assistant")
        self.root.geometry("1400x900")
        
        # Apply dark theme
        self.setup_dark_theme()
        
        # Variables
        self.uploaded_files = []
        self.chat_messages = []
        self.running_processes = []
        self.stop_requested = False
        self.output_queue = queue.Queue()
        
        # Setup UI
        self.setup_ui()
        
        # Initialize AI components
        self.ai_backend = None
        self.initialize_ai_backend()
        
        # Center window
        self.center_window()
        
    def setup_dark_theme(self):
        """Setup modern dark theme"""
        self.colors = {
            'bg_primary': '#1e1e1e',
            'bg_secondary': '#2d2d30',
            'bg_tertiary': '#252526',
            'text_primary': '#ffffff',
            'text_secondary': '#cccccc',
            'text_muted': '#969696',
            'accent': '#007ACC',
            'success': '#4EC9B0',
            'warning': '#CE9178',
            'error': '#F44747',
            'user_msg': '#264F78',
            'ai_msg': '#3C3C3C',
            'border': '#464647'
        }
        
        # Configure root
        self.root.configure(bg=self.colors['bg_primary'])
        
        # Configure ttk style
        self.style = ttk.Style()
        self.style.theme_use('clam')
        
        # Configure widgets
        self.style.configure('Dark.TFrame', background=self.colors['bg_primary'])
        self.style.configure('Dark.TLabel', background=self.colors['bg_primary'], 
                           foreground=self.colors['text_primary'])
        self.style.configure('Dark.TButton', background=self.colors['bg_secondary'],
                           foreground=self.colors['text_primary'])
        self.style.map('Dark.TButton',
                      background=[('active', self.colors['accent']),
                                ('pressed', self.colors['accent'])])
        
    def center_window(self):
        """Center the window on screen"""
        self.root.update_idletasks()
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f'{width}x{height}+{x}+{y}')
        
    def setup_ui(self):
        """Setup the modern UI"""
        # Main container
        main_container = ttk.Frame(self.root, style='Dark.TFrame')
        main_container.pack(fill=tk.BOTH, expand=True)
        
        # Header
        self.create_header(main_container)
        
        # Content area with chat and terminal
        content_area = ttk.Frame(main_container, style='Dark.TFrame')
        content_area.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Chat area (left side)
        chat_frame = ttk.Frame(content_area, style='Dark.TFrame')
        chat_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
        
        self.create_chat_area(chat_frame)
        
        # Terminal area (right side)
        terminal_frame = ttk.Frame(content_area, style='Dark.TFrame')
        terminal_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))
        
        self.create_terminal_area(terminal_frame)
        
    def create_header(self, parent):
        """Create modern header with branding"""
        header = tk.Frame(parent, bg=self.colors['bg_secondary'], height=60)
        header.pack(fill=tk.X, padx=10, pady=(10, 5))
        header.pack_propagate(False)
        
        # Logo and title
        title_frame = tk.Frame(header, bg=self.colors['bg_secondary'])
        title_frame.pack(side=tk.LEFT, padx=20)
        
        logo_label = tk.Label(title_frame, text="üîí", font=('Arial', 24),
                            bg=self.colors['bg_secondary'])
        logo_label.pack(side=tk.LEFT, padx=(0, 10))
        
        title_label = tk.Label(title_frame, text="PentestGPT", 
                             font=('Arial', 20, 'bold'),
                             bg=self.colors['bg_secondary'],
                             fg=self.colors['text_primary'])
        title_label.pack(side=tk.LEFT)
        
        subtitle = tk.Label(title_frame, text="AI Penetration Testing Assistant",
                          font=('Arial', 12),
                          bg=self.colors['bg_secondary'],
                          fg=self.colors['text_muted'])
        subtitle.pack(side=tk.LEFT, padx=(10, 0))
        
        # Status indicator
        self.status_label = tk.Label(header, text="‚óè Ready",
                                   font=('Arial', 10),
                                   bg=self.colors['bg_secondary'],
                                   fg=self.colors['success'])
        self.status_label.pack(side=tk.RIGHT, padx=20)
        
    def create_chat_area(self, parent):
        """Create the chat interface"""
        # Chat header
        chat_header = tk.Frame(parent, bg=self.colors['bg_secondary'], height=40)
        chat_header.pack(fill=tk.X)
        chat_header.pack_propagate(False)
        
        tk.Label(chat_header, text="üí¨ Chat Assistant",
                font=('Arial', 14, 'bold'),
                bg=self.colors['bg_secondary'],
                fg=self.colors['text_primary']).pack(side=tk.LEFT, padx=10, pady=5)
        
        # Quick actions
        quick_frame = tk.Frame(chat_header, bg=self.colors['bg_secondary'])
        quick_frame.pack(side=tk.RIGHT, padx=10)
        
        quick_actions = [
            ("üîç Scan Network", "scan the network 192.168.1.0/24"),
            ("üåê Test Website", "test the website"),
            ("üì± Analyze APK", "analyze this APK file")
        ]
        
        for text, cmd in quick_actions:
            btn = tk.Button(quick_frame, text=text,
                          bg=self.colors['bg_tertiary'],
                          fg=self.colors['text_secondary'],
                          relief=tk.FLAT,
                          padx=10,
                          command=lambda c=cmd: self.quick_action(c))
            btn.pack(side=tk.LEFT, padx=2)
        
        # Chat display area
        self.create_chat_display(parent)
        
        # Input area
        self.create_input_area(parent)
        
    def create_chat_display(self, parent):
        """Create scrollable chat display"""
        # Create canvas and scrollbar for chat messages
        self.chat_canvas = tk.Canvas(parent, bg=self.colors['bg_primary'],
                                   highlightthickness=0)
        chat_scrollbar = ttk.Scrollbar(parent, orient="vertical",
                                     command=self.chat_canvas.yview)
        self.scrollable_frame = ttk.Frame(self.chat_canvas, style='Dark.TFrame')
        
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.chat_canvas.configure(scrollregion=self.chat_canvas.bbox("all"))
        )
        
        self.chat_canvas.create_window((0, 0), window=self.scrollable_frame,
                                     anchor="nw")
        self.chat_canvas.configure(yscrollcommand=chat_scrollbar.set)
        
        self.chat_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        chat_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Welcome message
        self.add_welcome_message()
        
    def create_input_area(self, parent):
        """Create message input area"""
        input_frame = tk.Frame(parent, bg=self.colors['bg_secondary'])
        input_frame.pack(fill=tk.X, pady=(5, 0))
        
        # File upload button
        upload_btn = tk.Button(input_frame, text="üìé",
                             bg=self.colors['bg_tertiary'],
                             fg=self.colors['text_primary'],
                             relief=tk.FLAT,
                             font=('Arial', 16),
                             command=self.upload_files)
        upload_btn.pack(side=tk.LEFT, padx=(10, 5), pady=5)
        
        # Message input
        self.message_entry = tk.Text(input_frame, height=3,
                                   bg=self.colors['bg_tertiary'],
                                   fg=self.colors['text_primary'],
                                   insertbackground=self.colors['text_primary'],
                                   relief=tk.FLAT,
                                   font=('Arial', 11),
                                   wrap=tk.WORD)
        self.message_entry.pack(side=tk.LEFT, fill=tk.BOTH, expand=True,
                              padx=5, pady=5)
        
        # Send button
        send_btn = tk.Button(input_frame, text="Send ‚û§",
                           bg=self.colors['accent'],
                           fg=self.colors['text_primary'],
                           relief=tk.FLAT,
                           font=('Arial', 12, 'bold'),
                           padx=20,
                           command=self.send_message)
        send_btn.pack(side=tk.RIGHT, padx=(5, 10), pady=5)
        
        # Bind Enter key
        self.message_entry.bind('<Return>', lambda e: self.send_message() if not e.state & 0x1 else None)
        self.message_entry.bind('<Shift-Return>', lambda e: None)
        
        # File display area
        self.files_frame = tk.Frame(parent, bg=self.colors['bg_primary'])
        self.files_frame.pack(fill=tk.X, pady=(5, 0))
        
    def create_terminal_area(self, parent):
        """Create terminal output area"""
        # Terminal header
        terminal_header = tk.Frame(parent, bg=self.colors['bg_secondary'], height=40)
        terminal_header.pack(fill=tk.X)
        terminal_header.pack_propagate(False)
        
        tk.Label(terminal_header, text="üñ•Ô∏è Terminal Output",
                font=('Arial', 14, 'bold'),
                bg=self.colors['bg_secondary'],
                fg=self.colors['text_primary']).pack(side=tk.LEFT, padx=10, pady=5)
        
        # Control buttons
        control_frame = tk.Frame(terminal_header, bg=self.colors['bg_secondary'])
        control_frame.pack(side=tk.RIGHT, padx=10)
        
        self.clear_btn = tk.Button(control_frame, text="Clear",
                                 bg=self.colors['bg_tertiary'],
                                 fg=self.colors['text_secondary'],
                                 relief=tk.FLAT,
                                 command=self.clear_terminal)
        self.clear_btn.pack(side=tk.LEFT, padx=2)
        
        self.stop_btn = tk.Button(control_frame, text="Stop",
                                bg=self.colors['error'],
                                fg=self.colors['text_primary'],
                                relief=tk.FLAT,
                                state="disabled",
                                command=self.stop_execution)
        self.stop_btn.pack(side=tk.LEFT, padx=2)
        
        # Terminal output
        self.terminal_output = scrolledtext.ScrolledText(
            parent,
            bg=self.colors['bg_tertiary'],
            fg=self.colors['success'],
            insertbackground=self.colors['success'],
            font=('Consolas', 10),
            wrap=tk.WORD,
            height=20
        )
        self.terminal_output.pack(fill=tk.BOTH, expand=True, pady=(5, 0))
        
        # Configure tags for colored output
        self.terminal_output.tag_config('error', foreground=self.colors['error'])
        self.terminal_output.tag_config('warning', foreground=self.colors['warning'])
        self.terminal_output.tag_config('info', foreground=self.colors['accent'])
        self.terminal_output.tag_config('success', foreground=self.colors['success'])
        
    def add_welcome_message(self):
        """Add welcome message to chat"""
        welcome_msg = {
            'sender': 'ai',
            'content': """üëã **Welcome to PentestGPT!**

I'm your AI-powered penetration testing assistant. I can help you with:

‚Ä¢ üîç Network scanning and enumeration
‚Ä¢ üõ°Ô∏è Vulnerability assessment
‚Ä¢ üåê Web application testing
‚Ä¢ üì± Mobile app security analysis
‚Ä¢ üì° Wireless network testing
‚Ä¢ üîì Exploitation and payload generation

Simply tell me what you want to test, or upload files for analysis. 

**Example commands:**
- "Scan the network 192.168.1.0/24"
- "Test the website https://example.com"
- "Analyze this APK file for vulnerabilities"

How can I assist you today?""",
            'timestamp': datetime.now()
        }
        self.add_chat_message(welcome_msg)
        
    def initialize_ai_backend(self):
        """Initialize AI backend components"""
        try:
            # Try to import the chat AI backend
            from src.chat_ai_backend import ChatAIBackend
            self.ai_backend = ChatAIBackend()
            self.add_terminal_output("‚úÖ AI Backend initialized successfully\n", 'success')
        except ImportError as e:
            self.add_terminal_output(f"‚ö†Ô∏è AI Backend not available: {e}\n", 'warning')
            self.add_terminal_output("Using basic command execution mode\n", 'info')
        except Exception as e:
            self.add_terminal_output(f"‚ùå Error initializing AI Backend: {e}\n", 'error')
            
    def send_message(self):
        """Send user message"""
        message = self.message_entry.get("1.0", tk.END).strip()
        if not message:
            return
            
        # Clear input
        self.message_entry.delete("1.0", tk.END)
        
        # Add user message to chat
        user_msg = {
            'sender': 'user',
            'content': message,
            'timestamp': datetime.now()
        }
        self.add_chat_message(user_msg)
        
        # Process message in thread
        threading.Thread(target=self.process_message, args=(message,), daemon=True).start()
        
    def process_message(self, message):
        """Process user message and generate response"""
        try:
            # Update status
            self.update_status("Processing...", self.colors['warning'])
            
            # Check if it's a direct command
            if message.startswith('$'):
                command = message[1:].strip()
                self.execute_command(command)
                return
                
            # Process with AI backend if available
            if self.ai_backend:
                response = self.process_with_ai(message)
            else:
                response = self.process_with_patterns(message)
                
            # Add AI response
            ai_msg = {
                'sender': 'ai',
                'content': response['text'],
                'timestamp': datetime.now(),
                'commands': response.get('commands', [])
            }
            self.root.after(0, lambda: self.add_chat_message(ai_msg))
            
            # Execute commands if any
            if response.get('commands'):
                for cmd in response['commands']:
                    self.execute_command(cmd)
                    
            # Update status
            self.update_status("Ready", self.colors['success'])
            
        except Exception as e:
            error_msg = {
                'sender': 'ai',
                'content': f"‚ùå Error: {str(e)}",
                'timestamp': datetime.now()
            }
            self.root.after(0, lambda: self.add_chat_message(error_msg))
            self.update_status("Error", self.colors['error'])
            
    def process_with_ai(self, message):
        """Process message using AI backend"""
        try:
            # Get AI response
            result = self.ai_backend.process_query(message, self.uploaded_files)
            
            response = {
                'text': result.get('response', 'Processing your request...'),
                'commands': []
            }
            
            # Extract commands from actions
            if 'actions' in result:
                for action in result['actions']:
                    if action['type'] == 'command':
                        response['commands'].append(action['command'])
                        
            return response
            
        except Exception as e:
            # Fallback to pattern matching
            return self.process_with_patterns(message)
            
    def process_with_patterns(self, message):
        """Process message using pattern matching"""
        message_lower = message.lower()
        response = {
            'text': '',
            'commands': []
        }
        
        # Network scanning patterns
        if any(word in message_lower for word in ['scan', 'nmap', 'network', 'port']):
            # Extract IP/network from message
            ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}(?:/\d{1,2})?\b'
            ips = re.findall(ip_pattern, message)
            
            if ips:
                target = ips[0]
                response['text'] = f"üîç Starting network scan on {target}..."
                response['commands'] = [
                    f"nmap -sn {target}",  # Ping scan
                    f"nmap -sS -sV -T4 -p- {target}"  # Full port scan
                ]
            else:
                response['text'] = "Please specify a target IP or network (e.g., 192.168.1.0/24)"
                
        # Web testing patterns
        elif any(word in message_lower for word in ['web', 'website', 'http', 'url']):
            # Extract URLs
            url_pattern = r'https?://[^\s]+'
            urls = re.findall(url_pattern, message)
            
            if urls:
                target = urls[0]
                response['text'] = f"üåê Testing web application: {target}"
                response['commands'] = [
                    f"whatweb {target}",
                    f"nikto -h {target}",
                    f"gobuster dir -u {target} -w /usr/share/wordlists/dirb/common.txt"
                ]
            else:
                response['text'] = "Please specify a target URL (e.g., https://example.com)"
                
        # File analysis
        elif any(word in message_lower for word in ['analyze', 'check', 'examine']) and self.uploaded_files:
            response['text'] = "üìÑ Analyzing uploaded files..."
            for file_path in self.uploaded_files:
                if file_path.endswith('.apk'):
                    response['commands'].extend([
                        f"file '{file_path}'",
                        f"aapt dump badging '{file_path}' 2>/dev/null | head -20",
                        f"strings '{file_path}' | grep -i 'api\\|key\\|password' | head -10"
                    ])
                else:
                    response['commands'].extend([
                        f"file '{file_path}'",
                        f"strings '{file_path}' | head -20"
                    ])
                    
        # Help/info
        elif any(word in message_lower for word in ['help', 'what can you do', 'how to']):
            response['text'] = """I can help you with:

**Network Scanning:**
- "Scan network 192.168.1.0/24"
- "Port scan 192.168.1.100"

**Web Testing:**
- "Test website https://example.com"
- "Find vulnerabilities in http://target.com"

**File Analysis:**
- Upload files and say "analyze the uploaded file"

**Direct Commands:**
- Start messages with $ to run commands directly
- Example: "$ nmap -sV 192.168.1.1"
"""
        else:
            response['text'] = "I'm not sure what you want me to do. Try asking me to scan a network, test a website, or analyze a file."
            
        return response
        
    def execute_command(self, command):
        """Execute system command safely"""
        def run():
            process = None  # Initialize process variable
            try:
                # Update status
                self.update_status("Executing...", self.colors['warning'])
                self.root.after(0, lambda: self.stop_btn.config(state="normal"))
                
                # Add command to terminal
                self.add_terminal_output(f"\n$ {command}\n", 'info')
                
                # Remove sudo from commands - we'll run without elevated privileges
                if command.strip().startswith('sudo '):
                    command = command.replace('sudo ', '', 1)
                    self.add_terminal_output("‚ÑπÔ∏è Running without sudo privileges\n", 'warning')
                
                # Execute command
                process = subprocess.Popen(
                    command,
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,
                    universal_newlines=True
                )
                
                self.running_processes.append(process)
                
                # Read output in real-time
                while True:
                    if self.stop_requested:
                        process.terminate()
                        self.add_terminal_output("\n‚èπÔ∏è Execution stopped by user\n", 'warning')
                        break
                        
                    output = process.stdout.readline()
                    if output:
                        self.add_terminal_output(output)
                        
                    error = process.stderr.readline()
                    if error:
                        self.add_terminal_output(error, 'error')
                        
                    if output == '' and error == '' and process.poll() is not None:
                        break
                        
                # Get return code
                return_code = process.poll()
                if return_code != 0 and not self.stop_requested:
                    self.add_terminal_output(f"\n‚ùå Command failed with exit code: {return_code}\n", 'error')
                elif return_code == 0:
                    self.add_terminal_output(f"\n‚úÖ Command completed successfully\n", 'success')
                    
            except FileNotFoundError:
                self.add_terminal_output(f"\n‚ùå Command not found: {command.split()[0]}\n", 'error')
            except Exception as e:
                self.add_terminal_output(f"\n‚ùå Error: {str(e)}\n", 'error')
            finally:
                self.stop_requested = False
                if process and process in self.running_processes:
                    self.running_processes.remove(process)
                self.root.after(0, lambda: self.stop_btn.config(state="disabled"))
                self.update_status("Ready", self.colors['success'])
                
        threading.Thread(target=run, daemon=True).start()
        
    def add_chat_message(self, message):
        """Add message to chat display"""
        # Create message container
        msg_container = tk.Frame(self.scrollable_frame, bg=self.colors['bg_primary'])
        msg_container.pack(fill=tk.X, padx=10, pady=5)
        
        if message['sender'] == 'user':
            # User message (right aligned)
            msg_frame = tk.Frame(msg_container, bg=self.colors['user_msg'])
            msg_frame.pack(side=tk.RIGHT, anchor=tk.E)
            
            msg_label = tk.Label(msg_frame, text=message['content'],
                               bg=self.colors['user_msg'],
                               fg=self.colors['text_primary'],
                               font=('Arial', 11),
                               wraplength=400,
                               justify=tk.LEFT,
                               padx=15, pady=10)
            msg_label.pack()
            
            time_label = tk.Label(msg_container,
                                text=f"You ‚Ä¢ {message['timestamp'].strftime('%H:%M')}",
                                bg=self.colors['bg_primary'],
                                fg=self.colors['text_muted'],
                                font=('Arial', 9))
            time_label.pack(side=tk.RIGHT, anchor=tk.E, pady=(5, 0))
            
        else:
            # AI message (left aligned)
            msg_frame = tk.Frame(msg_container, bg=self.colors['ai_msg'])
            msg_frame.pack(side=tk.LEFT, anchor=tk.W)
            
            # Parse markdown-style formatting
            content = message['content']
            content = re.sub(r'\*\*(.*?)\*\*', r'\1', content)  # Remove bold markers
            
            msg_label = tk.Label(msg_frame, text=content,
                               bg=self.colors['ai_msg'],
                               fg=self.colors['text_primary'],
                               font=('Arial', 11),
                               wraplength=500,
                               justify=tk.LEFT,
                               padx=15, pady=10)
            msg_label.pack()
            
            # Add command buttons if any
            if message.get('commands'):
                cmd_frame = tk.Frame(msg_frame, bg=self.colors['ai_msg'])
                cmd_frame.pack(fill=tk.X, padx=15, pady=(0, 10))
                
                tk.Label(cmd_frame, text="üìã Commands to execute:",
                        bg=self.colors['ai_msg'],
                        fg=self.colors['text_muted'],
                        font=('Arial', 10)).pack(anchor=tk.W)
                
                for cmd in message['commands'][:3]:  # Show max 3 commands
                    cmd_display = cmd if len(cmd) < 50 else cmd[:47] + "..."
                    cmd_btn = tk.Button(cmd_frame, text=cmd_display,
                                      bg=self.colors['bg_tertiary'],
                                      fg=self.colors['text_secondary'],
                                      font=('Consolas', 9),
                                      relief=tk.FLAT,
                                      anchor=tk.W,
                                      command=lambda c=cmd: self.execute_command(c))
                    cmd_btn.pack(fill=tk.X, pady=1)
            
            time_label = tk.Label(msg_container,
                                text=f"AI Assistant ‚Ä¢ {message['timestamp'].strftime('%H:%M')}",
                                bg=self.colors['bg_primary'],
                                fg=self.colors['text_muted'],
                                font=('Arial', 9))
            time_label.pack(side=tk.LEFT, anchor=tk.W, pady=(5, 0))
        
        # Auto-scroll to bottom
        self.root.after(100, lambda: self.chat_canvas.yview_moveto(1.0))
        
    def add_terminal_output(self, text, tag=None):
        """Add text to terminal output"""
        def add():
            self.terminal_output.insert(tk.END, text, tag)
            self.terminal_output.see(tk.END)
            
        self.root.after(0, add)
        
    def upload_files(self):
        """Handle file upload"""
        files = filedialog.askopenfilenames(
            title="Upload files for analysis",
            filetypes=[
                ("All supported", "*.txt *.pdf *.apk *.py *.sh *.conf *.xml *.json"),
                ("Mobile apps", "*.apk *.ipa"),
                ("Scripts", "*.py *.sh *.bat"),
                ("Config files", "*.conf *.cfg *.xml *.json"),
                ("All files", "*.*")
            ]
        )
        
        if files:
            for file_path in files:
                if file_path not in self.uploaded_files:
                    self.uploaded_files.append(file_path)
                    self.display_uploaded_file(file_path)
                    
                    # Add notification to chat
                    msg = {
                        'sender': 'ai',
                        'content': f"üìé File uploaded: **{os.path.basename(file_path)}**\n\nWhat would you like me to do with this file?",
                        'timestamp': datetime.now()
                    }
                    self.add_chat_message(msg)
                    
    def display_uploaded_file(self, file_path):
        """Display uploaded file in UI"""
        file_widget = tk.Frame(self.files_frame, bg=self.colors['bg_secondary'])
        file_widget.pack(fill=tk.X, padx=10, pady=2)
        
        # File icon
        ext = os.path.splitext(file_path)[1].lower()
        icon = "üì±" if ext == ".apk" else "üìÑ" if ext in [".txt", ".pdf"] else "üìÅ"
        
        # File info
        file_size = os.path.getsize(file_path)
        size_str = f"{file_size / 1024:.1f} KB" if file_size < 1024*1024 else f"{file_size / (1024*1024):.1f} MB"
        
        info_label = tk.Label(file_widget,
                            text=f"{icon} {os.path.basename(file_path)} ({size_str})",
                            bg=self.colors['bg_secondary'],
                            fg=self.colors['text_primary'],
                            font=('Arial', 10))
        info_label.pack(side=tk.LEFT, padx=10, pady=5)
        
        # Remove button
        remove_btn = tk.Button(file_widget, text="‚úï",
                             bg=self.colors['bg_secondary'],
                             fg=self.colors['error'],
                             relief=tk.FLAT,
                             command=lambda: self.remove_file(file_path, file_widget))
        remove_btn.pack(side=tk.RIGHT, padx=10)
        
    def remove_file(self, file_path, widget):
        """Remove uploaded file"""
        if file_path in self.uploaded_files:
            self.uploaded_files.remove(file_path)
            widget.destroy()
            
    def quick_action(self, command):
        """Execute quick action"""
        self.message_entry.delete("1.0", tk.END)
        self.message_entry.insert("1.0", command)
        self.send_message()
        
    def clear_terminal(self):
        """Clear terminal output"""
        self.terminal_output.delete("1.0", tk.END)
        
    def stop_execution(self):
        """Stop running commands"""
        self.stop_requested = True
        for process in self.running_processes:
            try:
                process.terminate()
            except:
                pass
                
    def update_status(self, text, color):
        """Update status indicator"""
        def update():
            self.status_label.config(text=f"‚óè {text}", fg=color)
        self.root.after(0, update)
        
    def run(self):
        """Start the application"""
        self.root.mainloop()


def main():
    """Main entry point"""
    app = ModernPentestGUI()
    app.run()


if __name__ == "__main__":
    main()
