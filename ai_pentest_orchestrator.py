#!/usr/bin/env python3
"""
AI-Powered Pentesting Orchestrator
Advanced LLM-driven system for comprehensive penetration testing
Supports all 8 types of pentesting with intelligent reasoning and classification
"""

import sys
import os
import json
import asyncio
import threading
import time
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
import logging

# Add src to path
src_path = Path(__file__).parent / "src"
sys.path.insert(0, str(src_path))

try:
    from ai_model import IntentClassifierModel
    from enhanced_nlp_processor import EnhancedNLPProcessor
    from config import Config
    
    # Import all pentesting modules
    from reconnaissance import ReconnaissanceModule
    from vulnerability_scanner import VulnerabilityScanner
    from payload_generator import PayloadGenerator
    from network_assessor import NetworkAssessor
    from web_assessor import WebAssessor
    from mobile_assessor import MobileAssessor
    from wireless_assessor import WirelessAssessor
    from cloud_assessor import CloudAssessor
    from iot_assessor import IoTAssessor
    from social_engineering import SocialEngineer
    from red_team import RedTeamPlanner
    from report_generator import ReportGenerator
    
    MODULES_AVAILABLE = True
except ImportError as e:
    print(f"Some modules not available: {e}")
    MODULES_AVAILABLE = False

class PentestType(Enum):
    """All supported penetration testing types"""
    RECONNAISSANCE = "reconnaissance"
    VULNERABILITY_SCANNING = "vulnerability_scanning"
    NETWORK_ASSESSMENT = "network_assessment"
    WEB_APPLICATION = "web_application"
    MOBILE_APPLICATION = "mobile_application"
    WIRELESS_SECURITY = "wireless_security"
    CLOUD_SECURITY = "cloud_security"
    IOT_SECURITY = "iot_security"
    SOCIAL_ENGINEERING = "social_engineering"
    RED_TEAM_OPERATIONS = "red_team_operations"
    PAYLOAD_GENERATION = "payload_generation"

class RiskLevel(Enum):
    """Risk levels for different operations"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class PentestTask:
    """Individual penetration testing task"""
    task_id: str
    pentest_type: PentestType
    target: str
    parameters: Dict[str, Any]
    priority: int
    risk_level: RiskLevel
    dependencies: List[str]
    estimated_duration: int
    reasoning: str
    
@dataclass
class ExecutionPlan:
    """Complete execution plan for penetration testing"""
    plan_id: str
    original_request: str
    classified_intent: Dict[str, Any]
    tasks: List[PentestTask]
    execution_order: List[str]
    total_estimated_time: int
    risk_assessment: Dict[str, Any]
    reasoning_chain: List[str]

class AIReasoningEngine:
    """Advanced reasoning engine for penetration testing decisions"""
    
    def __init__(self):
        self.knowledge_base = self._load_pentesting_knowledge()
        self.reasoning_rules = self._load_reasoning_rules()
        
    def _load_pentesting_knowledge(self) -> Dict[str, Any]:
        """Load pentesting domain knowledge"""
        return {
            "reconnaissance": {
                "description": "Information gathering and target enumeration",
                "typical_tools": ["nmap", "amass", "subfinder", "theharvester", "shodan"],
                "common_targets": ["domains", "ip_ranges", "organizations"],
                "output_types": ["subdomains", "open_ports", "services", "technologies"],
                "prerequisites": [],
                "risk_level": RiskLevel.LOW
            },
            "vulnerability_scanning": {
                "description": "Automated vulnerability identification",
                "typical_tools": ["nuclei", "nikto", "openvas", "nessus"],
                "common_targets": ["web_applications", "network_services", "systems"],
                "output_types": ["vulnerabilities", "cve_ids", "risk_ratings"],
                "prerequisites": ["reconnaissance"],
                "risk_level": RiskLevel.MEDIUM
            },
            "network_assessment": {
                "description": "Network infrastructure security testing",
                "typical_tools": ["nmap", "masscan", "netcat", "hping3"],
                "common_targets": ["ip_ranges", "individual_hosts", "network_segments"],
                "output_types": ["open_ports", "services", "os_fingerprint", "network_topology"],
                "prerequisites": ["reconnaissance"],
                "risk_level": RiskLevel.MEDIUM
            },
            "web_application": {
                "description": "Web application and API security testing",
                "typical_tools": ["burp", "zap", "sqlmap", "gobuster", "ffuf"],
                "common_targets": ["web_applications", "apis", "web_services"],
                "output_types": ["web_vulnerabilities", "injection_points", "authentication_flaws"],
                "prerequisites": ["reconnaissance", "vulnerability_scanning"],
                "risk_level": RiskLevel.HIGH
            },
            "mobile_application": {
                "description": "Mobile application security assessment",
                "typical_tools": ["mobsf", "frida", "apktool", "drozer"],
                "common_targets": ["apk_files", "ios_apps", "mobile_apis"],
                "output_types": ["app_vulnerabilities", "insecure_storage", "api_issues"],
                "prerequisites": ["reconnaissance"],
                "risk_level": RiskLevel.MEDIUM
            },
            "wireless_security": {
                "description": "Wireless network security testing",
                "typical_tools": ["aircrack-ng", "kismet", "bettercap", "wifite"],
                "common_targets": ["wifi_networks", "bluetooth_devices", "wireless_infrastructure"],
                "output_types": ["network_keys", "device_information", "wireless_vulnerabilities"],
                "prerequisites": [],
                "risk_level": RiskLevel.HIGH
            },
            "cloud_security": {
                "description": "Cloud infrastructure security assessment",
                "typical_tools": ["scoutsuite", "pacu", "cloudsploit", "prowler"],
                "common_targets": ["aws_accounts", "azure_subscriptions", "gcp_projects"],
                "output_types": ["misconfigurations", "iam_issues", "storage_problems"],
                "prerequisites": ["reconnaissance"],
                "risk_level": RiskLevel.CRITICAL
            },
            "iot_security": {
                "description": "Internet of Things device security testing",
                "typical_tools": ["binwalk", "firmadyne", "iot-inspector"],
                "common_targets": ["iot_devices", "firmware_images", "embedded_systems"],
                "output_types": ["firmware_vulnerabilities", "device_exploits", "communication_flaws"],
                "prerequisites": ["reconnaissance", "network_assessment"],
                "risk_level": RiskLevel.HIGH
            },
            "social_engineering": {
                "description": "Human factor security assessment",
                "typical_tools": ["setoolkit", "gophish", "king_phisher"],
                "common_targets": ["employees", "organizations", "domains"],
                "output_types": ["phishing_success_rate", "awareness_level", "human_vulnerabilities"],
                "prerequisites": ["reconnaissance"],
                "risk_level": RiskLevel.MEDIUM
            },
            "payload_generation": {
                "description": "Exploitation payload creation",
                "typical_tools": ["msfvenom", "veil", "fatrat", "empire"],
                "common_targets": ["vulnerabilities", "systems", "applications"],
                "output_types": ["executables", "shellcode", "exploits"],
                "prerequisites": ["vulnerability_scanning"],
                "risk_level": RiskLevel.CRITICAL
            }
        }
    
    def _load_reasoning_rules(self) -> Dict[str, Any]:
        """Load reasoning rules for decision making"""
        return {
            "target_analysis": {
                "domain_patterns": [
                    r"^https?://.*",  # Web applications
                    r".*\.com$|.*\.org$|.*\.net$",  # Domains
                ],
                "ip_patterns": [
                    r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$",  # Single IP
                    r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/\d{1,2}$",  # IP range
                ],
                "file_patterns": [
                    r".*\.apk$",  # Android APK
                    r".*\.ipa$",  # iOS IPA
                    r".*\.bin$|.*\.img$",  # Firmware
                ]
            },
            "dependency_chains": {
                "web_application": ["reconnaissance", "vulnerability_scanning"],
                "mobile_application": ["reconnaissance"],
                "network_assessment": ["reconnaissance"],
                "cloud_security": ["reconnaissance"],
                "iot_security": ["reconnaissance", "network_assessment"],
                "payload_generation": ["vulnerability_scanning"],
                "social_engineering": ["reconnaissance"]
            },
            "risk_escalation": {
                "low_to_medium": ["detailed_scanning", "service_enumeration"],
                "medium_to_high": ["exploitation_attempts", "privilege_escalation"],
                "high_to_critical": ["lateral_movement", "persistence", "data_exfiltration"]
            }
        }
    
    def analyze_target(self, target: str) -> Dict[str, Any]:
        """Analyze target to determine appropriate testing types"""
        analysis = {
            "target": target,
            "target_type": "unknown",
            "suggested_pentests": [],
            "risk_factors": [],
            "reasoning": []
        }
        
        import re
        
        # Web application detection
        if re.match(r"^https?://.*", target):
            analysis["target_type"] = "web_application"
            analysis["suggested_pentests"].extend([
                PentestType.RECONNAISSANCE,
                PentestType.WEB_APPLICATION,
                PentestType.VULNERABILITY_SCANNING
            ])
            analysis["reasoning"].append("Target is a web application - recommend web security testing")
        
        # IP or network detection
        elif re.match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}", target):
            if "/" in target:
                analysis["target_type"] = "network_range"
                analysis["suggested_pentests"].extend([
                    PentestType.RECONNAISSANCE,
                    PentestType.NETWORK_ASSESSMENT,
                    PentestType.VULNERABILITY_SCANNING
                ])
                analysis["reasoning"].append("Target is a network range - recommend network security testing")
            else:
                analysis["target_type"] = "single_host"
                analysis["suggested_pentests"].extend([
                    PentestType.RECONNAISSANCE,
                    PentestType.NETWORK_ASSESSMENT,
                    PentestType.VULNERABILITY_SCANNING
                ])
                analysis["reasoning"].append("Target is a single host - recommend host security testing")
        
        # Mobile application detection
        elif target.endswith(('.apk', '.ipa')):
            analysis["target_type"] = "mobile_application"
            analysis["suggested_pentests"].extend([
                PentestType.MOBILE_APPLICATION,
                PentestType.RECONNAISSANCE
            ])
            analysis["reasoning"].append("Target is a mobile application - recommend mobile security testing")
        
        # Domain detection
        elif re.match(r".*\.[a-zA-Z]{2,}", target) and not target.startswith("http"):
            analysis["target_type"] = "domain"
            analysis["suggested_pentests"].extend([
                PentestType.RECONNAISSANCE,
                PentestType.WEB_APPLICATION,
                PentestType.NETWORK_ASSESSMENT,
                PentestType.SOCIAL_ENGINEERING
            ])
            analysis["reasoning"].append("Target is a domain - recommend comprehensive testing")
        
        return analysis
    
    def reason_about_execution_order(self, pentest_types: List[PentestType]) -> List[PentestType]:
        """Determine optimal execution order based on dependencies"""
        ordered = []
        remaining = pentest_types.copy()
        
        # Always start with reconnaissance if available
        if PentestType.RECONNAISSANCE in remaining:
            ordered.append(PentestType.RECONNAISSANCE)
            remaining.remove(PentestType.RECONNAISSANCE)
        
        # Add based on dependencies
        dependency_order = [
            PentestType.NETWORK_ASSESSMENT,
            PentestType.VULNERABILITY_SCANNING,
            PentestType.WEB_APPLICATION,
            PentestType.MOBILE_APPLICATION,
            PentestType.WIRELESS_SECURITY,
            PentestType.CLOUD_SECURITY,
            PentestType.IOT_SECURITY,
            PentestType.SOCIAL_ENGINEERING,
            PentestType.PAYLOAD_GENERATION,
            PentestType.RED_TEAM_OPERATIONS
        ]
        
        for pentest_type in dependency_order:
            if pentest_type in remaining:
                ordered.append(pentest_type)
                remaining.remove(pentest_type)
        
        # Add any remaining
        ordered.extend(remaining)
        
        return ordered

class AIPentestOrchestrator:
    """Main AI-powered pentesting orchestrator"""
    
    def __init__(self):
        self.ai_model = None
        self.nlp_processor = None
        self.reasoning_engine = AIReasoningEngine()
        self.execution_history = []
        self.knowledge_graph = {}
        
        # Initialize AI components
        self._init_ai_components()
        
        # Initialize pentesting modules
        self.modules = self._init_pentest_modules()
        
        # Setup logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def _init_ai_components(self):
        """Initialize AI and NLP components"""
        try:
            self.ai_model = IntentClassifierModel()
            if not self.ai_model.load_model():
                self.logger.warning("AI model not loaded - some features may be limited")
            
            self.nlp_processor = EnhancedNLPProcessor()
            self.logger.info("AI components initialized successfully")
        except Exception as e:
            self.logger.error(f"Failed to initialize AI components: {e}")
    
    def _init_pentest_modules(self) -> Dict[PentestType, Any]:
        """Initialize all pentesting modules"""
        modules = {}
        
        if not MODULES_AVAILABLE:
            self.logger.warning("Pentesting modules not available - using simulation mode")
            return modules
        
        try:
            modules[PentestType.RECONNAISSANCE] = ReconnaissanceModule()
            modules[PentestType.VULNERABILITY_SCANNING] = VulnerabilityScanner()
            modules[PentestType.NETWORK_ASSESSMENT] = NetworkAssessor()
            modules[PentestType.WEB_APPLICATION] = WebAssessor()
            modules[PentestType.MOBILE_APPLICATION] = MobileAssessor()
            modules[PentestType.WIRELESS_SECURITY] = WirelessAssessor()
            modules[PentestType.CLOUD_SECURITY] = CloudAssessor()
            modules[PentestType.IOT_SECURITY] = IoTAssessor()
            modules[PentestType.SOCIAL_ENGINEERING] = SocialEngineer()
            modules[PentestType.PAYLOAD_GENERATION] = PayloadGenerator()
            modules[PentestType.RED_TEAM_OPERATIONS] = RedTeamPlanner()
            
            self.logger.info(f"Initialized {len(modules)} pentesting modules")
        except Exception as e:
            self.logger.error(f"Failed to initialize pentesting modules: {e}")
        
        return modules
    
    def process_natural_language_request(self, request: str) -> ExecutionPlan:
        """Process natural language request and create execution plan"""
        self.logger.info(f"Processing request: {request}")
        
        # Step 1: AI intent classification
        ai_result = None
        if self.ai_model:
            ai_result = self.ai_model.predict(request)
            self.logger.info(f"AI classified intent as: {ai_result['intent']} (confidence: {ai_result['confidence']:.2f})")
        
        # Step 2: NLP processing
        nlp_result = None
        if self.nlp_processor:
            nlp_result = self.nlp_processor.process_request(request)
            self.logger.info(f"NLP extracted command: {nlp_result.primary_command.value}")
        
        # Step 3: Target analysis
        targets = self._extract_targets(request, nlp_result)
        target_analyses = [self.reasoning_engine.analyze_target(target) for target in targets]
        
        # Step 4: Reasoning and planning
        execution_plan = self._create_execution_plan(request, ai_result, nlp_result, target_analyses)
        
        return execution_plan
    
    def _extract_targets(self, request: str, nlp_result=None) -> List[str]:
        """Extract targets from the request"""
        targets = []
        
        if nlp_result and nlp_result.targets:
            targets.extend(nlp_result.targets)
        
        # Fallback: regex-based extraction
        import re
        
        # Extract URLs
        url_pattern = r'https?://[^\s]+'
        urls = re.findall(url_pattern, request)
        targets.extend(urls)
        
        # Extract IP addresses
        ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}(?:/\d{1,2})?\b'
        ips = re.findall(ip_pattern, request)
        targets.extend(ips)
        
        # Extract domains
        domain_pattern = r'\b[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*\.[a-zA-Z]{2,}\b'
        domains = re.findall(domain_pattern, request)
        targets.extend(domains)
        
        # Extract file names
        file_pattern = r'\b\w+\.(apk|ipa|bin|img|exe|jar|war)\b'
        files = re.findall(file_pattern, request)
        targets.extend(files)
        
        # Remove duplicates while preserving order
        unique_targets = []
        for target in targets:
            if target not in unique_targets:
                unique_targets.append(target)
        
        return unique_targets or ["localhost"]  # Default target if none found
    
    def _create_execution_plan(self, request: str, ai_result: Dict, nlp_result, target_analyses: List[Dict]) -> ExecutionPlan:
        """Create detailed execution plan with reasoning"""
        
        plan_id = f"plan_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        reasoning_chain = []
        
        # Determine pentest types needed
        all_suggested_types = set()
        for analysis in target_analyses:
            all_suggested_types.update(analysis["suggested_pentests"])
            reasoning_chain.extend(analysis["reasoning"])
        
        # Add AI-suggested types
        if ai_result:
            ai_suggested = self._map_ai_intent_to_pentest_types(ai_result["intent"])
            all_suggested_types.update(ai_suggested)
            reasoning_chain.append(f"AI model suggests {ai_result['intent']} operations")
        
        # Add NLP-suggested types
        if nlp_result:
            nlp_suggested = self._map_nlp_command_to_pentest_types(nlp_result.primary_command.value)
            all_suggested_types.update(nlp_suggested)
            reasoning_chain.append(f"NLP processor identified {nlp_result.primary_command.value} command")
        
        # Order execution based on dependencies
        ordered_types = self.reasoning_engine.reason_about_execution_order(list(all_suggested_types))
        reasoning_chain.append(f"Determined execution order: {[t.value for t in ordered_types]}")
        
        # Create individual tasks
        tasks = []
        total_time = 0
        
        for i, pentest_type in enumerate(ordered_types):
            for j, target_analysis in enumerate(target_analyses):
                task = PentestTask(
                    task_id=f"{plan_id}_task_{i}_{j}",
                    pentest_type=pentest_type,
                    target=target_analysis["target"],
                    parameters=self._get_task_parameters(pentest_type, target_analysis, request),
                    priority=i + 1,
                    risk_level=self.reasoning_engine.knowledge_base[pentest_type.value]["risk_level"],
                    dependencies=[f"{plan_id}_task_{k}_{j}" for k in range(i)],
                    estimated_duration=self._estimate_task_duration(pentest_type, target_analysis),
                    reasoning=f"Target {target_analysis['target']} requires {pentest_type.value} due to {target_analysis['target_type']}"
                )
                tasks.append(task)
                total_time += task.estimated_duration
        
        # Risk assessment
        risk_assessment = self._assess_overall_risk(tasks, target_analyses)
        reasoning_chain.append(f"Overall risk level: {risk_assessment['level']}")
        
        return ExecutionPlan(
            plan_id=plan_id,
            original_request=request,
            classified_intent={
                "ai_result": ai_result,
                "nlp_result": asdict(nlp_result) if nlp_result else None,
                "target_analyses": target_analyses
            },
            tasks=tasks,
            execution_order=[task.task_id for task in tasks],
            total_estimated_time=total_time,
            risk_assessment=risk_assessment,
            reasoning_chain=reasoning_chain
        )
    
    def _map_ai_intent_to_pentest_types(self, intent: str) -> List[PentestType]:
        """Map AI intent to penetration testing types"""
        mapping = {
            "recon": [PentestType.RECONNAISSANCE],
            "vuln": [PentestType.VULNERABILITY_SCANNING],
            "network": [PentestType.NETWORK_ASSESSMENT],
            "web": [PentestType.WEB_APPLICATION],
            "mobile": [PentestType.MOBILE_APPLICATION],
            "wireless": [PentestType.WIRELESS_SECURITY],
            "cloud": [PentestType.CLOUD_SECURITY],
            "iot": [PentestType.IOT_SECURITY],
            "social": [PentestType.SOCIAL_ENGINEERING],
            "payload": [PentestType.PAYLOAD_GENERATION],
            "redteam": [PentestType.RED_TEAM_OPERATIONS],
            "complex": [PentestType.RECONNAISSANCE, PentestType.VULNERABILITY_SCANNING, PentestType.NETWORK_ASSESSMENT]
        }
        return mapping.get(intent, [PentestType.RECONNAISSANCE])
    
    def _map_nlp_command_to_pentest_types(self, command: str) -> List[PentestType]:
        """Map NLP command to penetration testing types"""
        mapping = {
            "recon": [PentestType.RECONNAISSANCE],
            "scan": [PentestType.RECONNAISSANCE, PentestType.VULNERABILITY_SCANNING],
            "vuln": [PentestType.VULNERABILITY_SCANNING],
            "web": [PentestType.WEB_APPLICATION],
            "network": [PentestType.NETWORK_ASSESSMENT],
            "mobile": [PentestType.MOBILE_APPLICATION],
            "wireless": [PentestType.WIRELESS_SECURITY],
            "cloud": [PentestType.CLOUD_SECURITY],
            "iot": [PentestType.IOT_SECURITY],
            "payload": [PentestType.PAYLOAD_GENERATION]
        }
        return mapping.get(command, [PentestType.RECONNAISSANCE])
    
    def _get_task_parameters(self, pentest_type: PentestType, target_analysis: Dict, request: str) -> Dict[str, Any]:
        """Generate parameters for specific task"""
        base_params = {
            "target": target_analysis["target"],
            "target_type": target_analysis["target_type"]
        }
        
        # Add type-specific parameters
        if pentest_type == PentestType.WEB_APPLICATION:
            base_params.update({
                "tools": ["nuclei", "nikto", "sqlmap"],
                "scan_depth": "comprehensive" if "comprehensive" in request.lower() else "standard"
            })
        elif pentest_type == PentestType.NETWORK_ASSESSMENT:
            base_params.update({
                "scan_type": "syn",
                "port_range": "top-1000",
                "timing": "aggressive" if "quick" in request.lower() else "normal"
            })
        elif pentest_type == PentestType.RECONNAISSANCE:
            base_params.update({
                "passive": "stealth" in request.lower(),
                "depth": "deep" if "comprehensive" in request.lower() else "standard"
            })
        
        return base_params
    
    def _estimate_task_duration(self, pentest_type: PentestType, target_analysis: Dict) -> int:
        """Estimate task duration in seconds"""
        base_durations = {
            PentestType.RECONNAISSANCE: 300,
            PentestType.VULNERABILITY_SCANNING: 600,
            PentestType.NETWORK_ASSESSMENT: 450,
            PentestType.WEB_APPLICATION: 900,
            PentestType.MOBILE_APPLICATION: 1200,
            PentestType.WIRELESS_SECURITY: 1800,
            PentestType.CLOUD_SECURITY: 600,
            PentestType.IOT_SECURITY: 900,
            PentestType.SOCIAL_ENGINEERING: 300,
            PentestType.PAYLOAD_GENERATION: 180
        }
        return base_durations.get(pentest_type, 300)
    
    def _assess_overall_risk(self, tasks: List[PentestTask], target_analyses: List[Dict]) -> Dict[str, Any]:
        """Assess overall risk of the operation"""
        risk_levels = [task.risk_level for task in tasks]
        
        if RiskLevel.CRITICAL in risk_levels:
            level = "CRITICAL"
        elif RiskLevel.HIGH in risk_levels:
            level = "HIGH"
        elif RiskLevel.MEDIUM in risk_levels:
            level = "MEDIUM"
        else:
            level = "LOW"
        
        return {
            "level": level,
            "factors": [f"{task.pentest_type.value}: {task.risk_level.value}" for task in tasks],
            "mitigation": "Ensure proper authorization and testing environment",
            "estimated_impact": "System disruption possible" if level in ["HIGH", "CRITICAL"] else "Minimal impact expected"
        }
    
    async def execute_plan(self, plan: ExecutionPlan, progress_callback=None) -> Dict[str, Any]:
        """Execute the complete penetration testing plan"""
        self.logger.info(f"Executing plan {plan.plan_id}")
        
        execution_results = {
            "plan_id": plan.plan_id,
            "start_time": datetime.now().isoformat(),
            "status": "running",
            "completed_tasks": [],
            "failed_tasks": [],
            "results": {},
            "overall_findings": []
        }
        
        try:
            for i, task in enumerate(plan.tasks):
                if progress_callback:
                    progress_callback(i, len(plan.tasks), f"Executing {task.pentest_type.value}")
                
                self.logger.info(f"Executing task {task.task_id}: {task.pentest_type.value}")
                
                # Execute individual task
                task_result = await self._execute_task(task)
                
                if task_result["success"]:
                    execution_results["completed_tasks"].append(task.task_id)
                    execution_results["results"][task.task_id] = task_result
                    
                    # Extract findings
                    findings = self._extract_findings(task_result, task.pentest_type)
                    execution_results["overall_findings"].extend(findings)
                else:
                    execution_results["failed_tasks"].append(task.task_id)
                    self.logger.error(f"Task {task.task_id} failed: {task_result.get('error', 'Unknown error')}")
            
            execution_results["status"] = "completed"
            execution_results["end_time"] = datetime.now().isoformat()
            
            # Generate comprehensive report
            report = self._generate_final_report(execution_results, plan)
            execution_results["report"] = report
            
        except Exception as e:
            execution_results["status"] = "failed"
            execution_results["error"] = str(e)
            self.logger.error(f"Plan execution failed: {e}")
        
        return execution_results
    
    async def _execute_task(self, task: PentestTask) -> Dict[str, Any]:
        """Execute individual penetration testing task"""
        try:
            module = self.modules.get(task.pentest_type)
            
            if not module:
                # Simulation mode
                self.logger.info(f"Simulating {task.pentest_type.value} for {task.target}")
                await asyncio.sleep(2)  # Simulate execution time
                
                return {
                    "success": True,
                    "simulated": True,
                    "task_id": task.task_id,
                    "pentest_type": task.pentest_type.value,
                    "target": task.target,
                    "findings": [f"Simulated {task.pentest_type.value} finding for {task.target}"],
                    "execution_time": 2,
                    "timestamp": datetime.now().isoformat()
                }
            
            # Real execution
            if task.pentest_type == PentestType.RECONNAISSANCE:
                result = module.scan(task.target)
            elif task.pentest_type == PentestType.VULNERABILITY_SCANNING:
                result = module.scan(task.target)
            elif task.pentest_type == PentestType.NETWORK_ASSESSMENT:
                result = module.scan(task.target, task.parameters.get("mode", "external"))
            elif task.pentest_type == PentestType.WEB_APPLICATION:
                result = module.scan(task.target, task.parameters.get("tools", ["nuclei", "nikto"]))
            elif task.pentest_type == PentestType.MOBILE_APPLICATION:
                result = module.analyze(task.target)
            elif task.pentest_type == PentestType.WIRELESS_SECURITY:
                result = module.scan(task.parameters.get("interface", "wlan0"))
            elif task.pentest_type == PentestType.CLOUD_SECURITY:
                result = module.assess(task.parameters.get("provider", "aws"))
            elif task.pentest_type == PentestType.IOT_SECURITY:
                result = module.scan(task.target)
            elif task.pentest_type == PentestType.PAYLOAD_GENERATION:
                result = module.generate(task.parameters.get("payload_type", "reverse_shell"))
            else:
                result = {"error": f"Unsupported pentest type: {task.pentest_type}"}
            
            return {
                "success": True,
                "task_id": task.task_id,
                "pentest_type": task.pentest_type.value,
                "target": task.target,
                "result": result,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                "success": False,
                "task_id": task.task_id,
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }
    
    def _extract_findings(self, task_result: Dict[str, Any], pentest_type: PentestType) -> List[Dict[str, Any]]:
        """Extract security findings from task results"""
        findings = []
        
        if task_result.get("simulated"):
            return [{
                "type": "simulated",
                "severity": "INFO",
                "description": f"Simulated finding for {pentest_type.value}",
                "target": task_result["target"]
            }]
        
        # Extract real findings based on pentest type
        result_data = task_result.get("result", {})
        
        # This would be expanded based on actual module outputs
        if "vulnerabilities" in str(result_data).lower():
            findings.append({
                "type": "vulnerability",
                "severity": "MEDIUM",
                "description": "Potential vulnerability identified",
                "target": task_result["target"],
                "pentest_type": pentest_type.value
            })
        
        return findings
    
    def _generate_final_report(self, execution_results: Dict[str, Any], plan: ExecutionPlan) -> Dict[str, Any]:
        """Generate comprehensive final report"""
        return {
            "executive_summary": f"Executed {len(plan.tasks)} penetration testing tasks",
            "methodology": [pt.value for pt in set(task.pentest_type for task in plan.tasks)],
            "targets_tested": list(set(task.target for task in plan.tasks)),
            "total_findings": len(execution_results["overall_findings"]),
            "risk_level": plan.risk_assessment["level"],
            "recommendations": self._generate_recommendations(execution_results),
            "technical_details": execution_results
        }
    
    def _generate_recommendations(self, execution_results: Dict[str, Any]) -> List[str]:
        """Generate security recommendations based on findings"""
        recommendations = [
            "Implement regular security assessments",
            "Monitor for new vulnerabilities and threats",
            "Ensure proper access controls and authentication",
            "Keep systems and applications updated"
        ]
        
        # Add specific recommendations based on findings
        findings = execution_results.get("overall_findings", [])
        if any(f.get("type") == "vulnerability" for f in findings):
            recommendations.insert(0, "Address identified vulnerabilities immediately")
        
        return recommendations

def main():
    """Main demonstration function"""
    print("""
╔══════════════════════════════════════════════════════════════════════╗
║               🤖 AI-POWERED PENTESTING ORCHESTRATOR 🤖                ║
║                    Advanced LLM-Driven Security Testing              ║
╚══════════════════════════════════════════════════════════════════════╝
    """)
    
    orchestrator = AIPentestOrchestrator()
    
    # Example requests
    test_requests = [
        "Perform comprehensive security assessment of example.com",
        "Test mobile application security.apk for vulnerabilities",
        "Scan 192.168.1.0/24 network for security issues",
        "Find all vulnerabilities in https://webapp.com and generate exploits",
        "Conduct red team operation against target-corp.com"
    ]
    
    for request in test_requests:
        print(f"\n{'='*80}")
        print(f"🔍 Processing: {request}")
        print('='*80)
        
        try:
            # Create execution plan
            plan = orchestrator.process_natural_language_request(request)
            
            print(f"📋 Plan ID: {plan.plan_id}")
            print(f"🎯 Targets: {list(set(task.target for task in plan.tasks))}")
            print(f"🛠️ Pentest Types: {list(set(task.pentest_type.value for task in plan.tasks))}")
            print(f"⏱️ Estimated Time: {plan.total_estimated_time} seconds")
            print(f"⚠️ Risk Level: {plan.risk_assessment['level']}")
            
            print(f"\n🧠 Reasoning Chain:")
            for i, reasoning in enumerate(plan.reasoning_chain, 1):
                print(f"   {i}. {reasoning}")
            
            print(f"\n📝 Tasks ({len(plan.tasks)}):")
            for task in plan.tasks:
                print(f"   • {task.pentest_type.value} on {task.target} (Risk: {task.risk_level.value})")
            
            # Ask if user wants to execute
            choice = input(f"\n🚀 Execute this plan? (y/n): ").strip().lower()
            if choice == 'y':
                print("🔄 Executing plan...")
                
                # Execute plan (async)
                async def run_execution():
                    def progress_callback(current, total, status):
                        print(f"   Progress: {current+1}/{total} - {status}")
                    
                    results = await orchestrator.execute_plan(plan, progress_callback)
                    
                    print(f"\n📊 Execution Results:")
                    print(f"   Status: {results['status']}")
                    print(f"   Completed Tasks: {len(results['completed_tasks'])}")
                    print(f"   Failed Tasks: {len(results['failed_tasks'])}")
                    print(f"   Total Findings: {len(results['overall_findings'])}")
                    
                    if results['overall_findings']:
                        print(f"\n🔍 Key Findings:")
                        for finding in results['overall_findings'][:5]:
                            print(f"   • {finding.get('description', 'Unknown finding')}")
                
                # Run async execution
                asyncio.run(run_execution())
            
        except Exception as e:
            print(f"❌ Error: {e}")
        
        input("\nPress Enter to continue to next example...")
    
    print("\n🎉 AI Pentesting Orchestrator demonstration complete!")

if __name__ == "__main__":
    main()
