#!/usr/bin/env python3
"""
AI-Powered Automated Penetration Testing GUI
Professional desktop application for comprehensive security assessments
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
import threading
import asyncio
import sys
import os
import json
import time
from datetime import datetime
from pathlib import Path

# Add src to Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

class PentestGUI:
    def __init__(self, root):
        self.root = root
        self.setup_main_window()
        
        # Application state
        self.current_session = None
        self.assessment_running = False
        self.results_data = {}
        
        # AI components (lazy loaded)
        self.ai_agent = None
        self.ai_manager = None
        self.nlp_processor = None
        
        # Create main interface
        self.create_widgets()
        self.create_menu()
        
        # Load initial data
        self.load_settings()
        
    def setup_main_window(self):
        """Setup the main window properties"""
        self.root.title("ü§ñ AI-Powered Automated Penetration Testing Orchestrator")
        self.root.geometry("1400x900")
        self.root.minsize(1200, 800)
        
        # Configure style
        style = ttk.Style()
        style.theme_use('clam')
        
        # Custom colors
        self.colors = {
            'primary': '#2c3e50',
            'secondary': '#3498db', 
            'success': '#27ae60',
            'warning': '#f39c12',
            'danger': '#e74c3c',
            'dark': '#34495e',
            'light': '#ecf0f1'
        }
        
        # Configure custom styles
        style.configure('Title.TLabel', font=('Arial', 16, 'bold'))
        style.configure('Header.TLabel', font=('Arial', 12, 'bold'))
        style.configure('Success.TLabel', foreground=self.colors['success'])
        style.configure('Warning.TLabel', foreground=self.colors['warning'])
        style.configure('Danger.TLabel', foreground=self.colors['danger'])
        
    def create_menu(self):
        """Create the application menu"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="New Session", command=self.new_session)
        file_menu.add_command(label="Load Targets", command=self.load_targets_file)
        file_menu.add_command(label="Save Results", command=self.save_results)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit)
        
        # Tools menu
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Tools", menu=tools_menu)
        tools_menu.add_command(label="AI Model Manager", command=self.open_ai_manager)
        tools_menu.add_command(label="Settings", command=self.open_settings)
        tools_menu.add_command(label="View Logs", command=self.view_logs)
        
        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Documentation", command=self.show_help)
        help_menu.add_command(label="About", command=self.show_about)
    
    def create_widgets(self):
        """Create the main application widgets"""
        # Main container with padding
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # Header
        self.create_header(main_frame)
        
        # Main content area (notebook with tabs)
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=10)
        
        # Create tabs
        self.create_assessment_tab()
        self.create_targets_tab() 
        self.create_ai_analysis_tab()
        self.create_results_tab()
        self.create_reports_tab()
        self.create_monitoring_tab()
        
        # Status bar
        self.create_status_bar(main_frame)
    
    def create_header(self, parent):
        """Create the application header"""
        header_frame = ttk.Frame(parent)
        header_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        header_frame.columnconfigure(1, weight=1)
        
        # Logo/Icon (placeholder)
        icon_label = ttk.Label(header_frame, text="ü§ñ", font=('Arial', 24))
        icon_label.grid(row=0, column=0, padx=(0, 10))
        
        # Title and description
        title_frame = ttk.Frame(header_frame)
        title_frame.grid(row=0, column=1, sticky=(tk.W, tk.E))
        
        title_label = ttk.Label(title_frame, text="AI-Powered Automated Penetration Testing", 
                               style='Title.TLabel')
        title_label.grid(row=0, column=0, sticky=tk.W)
        
        desc_label = ttk.Label(title_frame, 
                              text="Comprehensive multi-platform security assessment with agentic AI")
        desc_label.grid(row=1, column=0, sticky=tk.W)
        
        # Quick stats
        stats_frame = ttk.LabelFrame(header_frame, text="System Status", padding="5")
        stats_frame.grid(row=0, column=2, padx=(10, 0))
        
        self.ai_status_var = tk.StringVar(value="Initializing...")
        ttk.Label(stats_frame, text="AI Status:").grid(row=0, column=0, sticky=tk.W)
        self.ai_status_label = ttk.Label(stats_frame, textvariable=self.ai_status_var)
        self.ai_status_label.grid(row=0, column=1, sticky=tk.W, padx=(5, 0))
        
        self.session_var = tk.StringVar(value="No active session")
        ttk.Label(stats_frame, text="Session:").grid(row=1, column=0, sticky=tk.W)
        ttk.Label(stats_frame, textvariable=self.session_var).grid(row=1, column=1, sticky=tk.W, padx=(5, 0))
    
    def create_assessment_tab(self):
        """Create the main assessment configuration tab"""
        assessment_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(assessment_frame, text="üéØ Assessment")
        
        # Configure grid
        assessment_frame.columnconfigure(1, weight=1)
        
        # Assessment type selection
        type_frame = ttk.LabelFrame(assessment_frame, text="Assessment Configuration", padding="10")
        type_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        type_frame.columnconfigure(1, weight=1)
        
        ttk.Label(type_frame, text="Assessment Type:").grid(row=0, column=0, sticky=tk.W, padx=(0, 10))
        self.assessment_type = ttk.Combobox(type_frame, values=[
            "ü§ñ Agentic AI Assessment", 
            "üîç Intelligence Gathering",
            "üõ°Ô∏è Vulnerability Assessment",
            "‚öîÔ∏è Penetration Testing",
            "üìä Compliance Testing",
            "üö® Red Team Exercise"
        ], state="readonly")
        self.assessment_type.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=10)
        self.assessment_type.set("ü§ñ Agentic AI Assessment")
        
        ttk.Label(type_frame, text="Automation Level:").grid(row=1, column=0, sticky=tk.W, padx=(0, 10), pady=(10, 0))
        self.automation_level = ttk.Combobox(type_frame, values=[
            "Manual (Human approval required)",
            "Semi-Automatic (Approve high-risk actions)", 
            "Automatic (Fully automated)",
            "Aggressive (Maximum automation)"
        ], state="readonly")
        self.automation_level.grid(row=1, column=1, sticky=(tk.W, tk.E), padx=10, pady=(10, 0))
        self.automation_level.set("Semi-Automatic (Approve high-risk actions)")
        
        # Platform selection
        platform_frame = ttk.LabelFrame(assessment_frame, text="Target Platforms", padding="10")
        platform_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        self.platforms = {}
        platforms_list = [
            ("üåê Network Infrastructure", "network"),
            ("üåç Web Applications", "web"), 
            ("üì± Mobile Applications", "mobile"),
            ("üì° Wireless Networks", "wireless"),
            ("‚òÅÔ∏è Cloud Infrastructure", "cloud"),
            ("üîå IoT Devices", "iot"),
            ("üë• Social Engineering", "social"),
            ("üè¢ Physical Security", "physical")
        ]
        
        for i, (name, key) in enumerate(platforms_list):
            var = tk.BooleanVar(value=True)
            self.platforms[key] = var
            ttk.Checkbutton(platform_frame, text=name, variable=var).grid(
                row=i//2, column=i%2, sticky=tk.W, padx=10, pady=2
            )
        
        # Quick start buttons
        action_frame = ttk.Frame(assessment_frame)
        action_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=10)
        
        ttk.Button(action_frame, text="üöÄ Start Assessment", 
                  command=self.start_assessment, style='Accent.TButton').pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(action_frame, text="üîç AI Analysis Only", 
                  command=self.start_ai_analysis).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(action_frame, text="‚õî Emergency Stop", 
                  command=self.emergency_stop).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(action_frame, text="üìä Generate Report", 
                  command=self.generate_report).pack(side=tk.RIGHT)
    
    def create_targets_tab(self):
        """Create the targets management tab"""
        targets_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(targets_frame, text="üéØ Targets")
        
        # Configure grid
        targets_frame.columnconfigure(0, weight=1)
        targets_frame.rowconfigure(1, weight=1)
        
        # Target input
        input_frame = ttk.LabelFrame(targets_frame, text="Target Configuration", padding="10")
        input_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        input_frame.columnconfigure(1, weight=1)
        
        ttk.Label(input_frame, text="Add Target:").grid(row=0, column=0, sticky=tk.W)
        self.target_entry = ttk.Entry(input_frame, width=50)
        self.target_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(10, 0))
        self.target_entry.bind('<Return>', self.add_target_from_entry)
        
        button_frame = ttk.Frame(input_frame)
        button_frame.grid(row=0, column=2, padx=(10, 0))
        
        ttk.Button(button_frame, text="Add", command=self.add_target_from_entry).pack(side=tk.LEFT)
        ttk.Button(button_frame, text="Load File", command=self.load_targets_file).pack(side=tk.LEFT, padx=(5, 0))
        
        # Target list
        list_frame = ttk.LabelFrame(targets_frame, text="Target List", padding="10")
        list_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        # Treeview for targets
        columns = ("Target", "Platform", "Priority", "Status", "Last Assessed")
        self.targets_tree = ttk.Treeview(list_frame, columns=columns, show='headings', height=15)
        
        # Configure columns
        for col in columns:
            self.targets_tree.heading(col, text=col)
            self.targets_tree.column(col, width=150)
        
        self.targets_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Scrollbar for treeview
        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.targets_tree.yview)
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        self.targets_tree.configure(yscrollcommand=scrollbar.set)
        
        # Target management buttons
        mgmt_frame = ttk.Frame(targets_frame)
        mgmt_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(10, 0))
        
        ttk.Button(mgmt_frame, text="Remove Selected", command=self.remove_target).pack(side=tk.LEFT)
        ttk.Button(mgmt_frame, text="Clear All", command=self.clear_targets).pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(mgmt_frame, text="Import CSV", command=self.import_csv).pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(mgmt_frame, text="Export CSV", command=self.export_csv).pack(side=tk.RIGHT)
    
    def create_ai_analysis_tab(self):
        """Create the AI analysis and configuration tab"""
        ai_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(ai_frame, text="ü§ñ AI Analysis")
        
        # Configure grid
        ai_frame.columnconfigure(1, weight=1)
        ai_frame.rowconfigure(2, weight=1)
        
        # AI Model Status
        model_frame = ttk.LabelFrame(ai_frame, text="AI Model Status", padding="10")
        model_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        model_frame.columnconfigure(1, weight=1)
        
        self.model_status_text = scrolledtext.ScrolledText(model_frame, height=6, width=80)
        self.model_status_text.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E))
        
        # AI Configuration
        config_frame = ttk.LabelFrame(ai_frame, text="AI Configuration", padding="10")
        config_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # AI settings
        ttk.Label(config_frame, text="Confidence Threshold:").grid(row=0, column=0, sticky=tk.W)
        self.confidence_scale = ttk.Scale(config_frame, from_=0.1, to=1.0, orient=tk.HORIZONTAL)
        self.confidence_scale.set(0.6)
        self.confidence_scale.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(10, 0))
        
        self.confidence_var = tk.StringVar(value="0.6")
        ttk.Label(config_frame, textvariable=self.confidence_var).grid(row=0, column=2, padx=(10, 0))
        self.confidence_scale.configure(command=self.update_confidence_label)
        
        ttk.Label(config_frame, text="Learning Rate:").grid(row=1, column=0, sticky=tk.W, pady=(10, 0))
        self.learning_scale = ttk.Scale(config_frame, from_=0.01, to=0.5, orient=tk.HORIZONTAL)
        self.learning_scale.set(0.1)
        self.learning_scale.grid(row=1, column=1, sticky=(tk.W, tk.E), padx=(10, 0), pady=(10, 0))
        
        # AI Analysis Results
        results_frame = ttk.LabelFrame(ai_frame, text="AI Analysis Results", padding="10")
        results_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
        results_frame.columnconfigure(0, weight=1)
        results_frame.rowconfigure(0, weight=1)
        
        self.ai_results_text = scrolledtext.ScrolledText(results_frame, height=15, width=80)
        self.ai_results_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # AI Control buttons
        ai_control_frame = ttk.Frame(ai_frame)
        ai_control_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))
        
        ttk.Button(ai_control_frame, text="üß† Initialize AI Models", 
                  command=self.initialize_ai_models).pack(side=tk.LEFT)
        ttk.Button(ai_control_frame, text="üìä Run AI Analysis", 
                  command=self.run_ai_analysis_tab).pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(ai_control_frame, text="üíæ Save AI State", 
                  command=self.save_ai_state).pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(ai_control_frame, text="üîÑ Reset AI Models", 
                  command=self.reset_ai_models).pack(side=tk.RIGHT)
    
    def create_results_tab(self):
        """Create the results visualization tab"""
        results_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(results_frame, text="üìä Results")
        
        # Configure grid
        results_frame.columnconfigure(0, weight=1)
        results_frame.rowconfigure(1, weight=1)
        
        # Results summary
        summary_frame = ttk.LabelFrame(results_frame, text="Assessment Summary", padding="10")
        summary_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Summary statistics
        stats_frame = ttk.Frame(summary_frame)
        stats_frame.pack(fill=tk.X)
        
        self.stats_vars = {
            'targets_processed': tk.StringVar(value="0"),
            'vulnerabilities_found': tk.StringVar(value="0"),
            'high_risk': tk.StringVar(value="0"),
            'success_rate': tk.StringVar(value="0%")
        }
        
        stats_labels = [
            ("Targets Processed:", 'targets_processed'),
            ("Vulnerabilities Found:", 'vulnerabilities_found'),
            ("High Risk Issues:", 'high_risk'),
            ("Success Rate:", 'success_rate')
        ]
        
        for i, (label, var_key) in enumerate(stats_labels):
            ttk.Label(stats_frame, text=label).grid(row=i//2, column=(i%2)*2, sticky=tk.W, padx=10, pady=5)
            ttk.Label(stats_frame, textvariable=self.stats_vars[var_key], 
                     style='Header.TLabel').grid(row=i//2, column=(i%2)*2+1, sticky=tk.W, padx=10, pady=5)
        
        # Results details
        details_frame = ttk.LabelFrame(results_frame, text="Detailed Results", padding="10")
        details_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        details_frame.columnconfigure(0, weight=1)
        details_frame.rowconfigure(0, weight=1)
        
        # Results treeview
        result_columns = ("Target", "Severity", "Finding", "Recommendation", "Status")
        self.results_tree = ttk.Treeview(details_frame, columns=result_columns, show='headings', height=20)
        
        for col in result_columns:
            self.results_tree.heading(col, text=col)
            self.results_tree.column(col, width=150)
        
        self.results_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Results scrollbar
        results_scrollbar = ttk.Scrollbar(details_frame, orient=tk.VERTICAL, command=self.results_tree.yview)
        results_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        self.results_tree.configure(yscrollcommand=results_scrollbar.set)
        
        # Results actions
        results_actions = ttk.Frame(results_frame)
        results_actions.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(10, 0))
        
        ttk.Button(results_actions, text="üìÑ Export Results", 
                  command=self.export_results).pack(side=tk.LEFT)
        ttk.Button(results_actions, text="üîç View Details", 
                  command=self.view_result_details).pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(results_actions, text="üìä Generate Chart", 
                  command=self.generate_chart).pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(results_actions, text="üîÑ Refresh", 
                  command=self.refresh_results).pack(side=tk.RIGHT)
    
    def create_reports_tab(self):
        """Create the reports generation tab"""
        reports_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(reports_frame, text="üìã Reports")
        
        # Configure grid
        reports_frame.columnconfigure(0, weight=1)
        reports_frame.rowconfigure(1, weight=1)
        
        # Report configuration
        config_frame = ttk.LabelFrame(reports_frame, text="Report Configuration", padding="10")
        config_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Report type selection
        ttk.Label(config_frame, text="Report Type:").grid(row=0, column=0, sticky=tk.W)
        self.report_type = ttk.Combobox(config_frame, values=[
            "Executive Summary",
            "Technical Report", 
            "Vulnerability Assessment",
            "Penetration Testing Report",
            "Compliance Report",
            "Custom Report"
        ], state="readonly")
        self.report_type.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(10, 0))
        self.report_type.set("Technical Report")
        
        ttk.Label(config_frame, text="Output Format:").grid(row=1, column=0, sticky=tk.W, pady=(10, 0))
        self.report_format = ttk.Combobox(config_frame, values=[
            "PDF", "HTML", "Word (DOCX)", "Excel (XLSX)", "JSON", "XML"
        ], state="readonly")
        self.report_format.grid(row=1, column=1, sticky=(tk.W, tk.E), padx=(10, 0), pady=(10, 0))
        self.report_format.set("PDF")
        
        # Report preview/content
        preview_frame = ttk.LabelFrame(reports_frame, text="Report Preview", padding="10")
        preview_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        preview_frame.columnconfigure(0, weight=1)
        preview_frame.rowconfigure(0, weight=1)
        
        self.report_preview = scrolledtext.ScrolledText(preview_frame, height=20, width=80)
        self.report_preview.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Report actions
        report_actions = ttk.Frame(reports_frame)
        report_actions.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(10, 0))
        
        ttk.Button(report_actions, text="üìä Generate Report", 
                  command=self.generate_full_report).pack(side=tk.LEFT)
        ttk.Button(report_actions, text="üëÅÔ∏è Preview Report", 
                  command=self.preview_report).pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(report_actions, text="üì§ Export Report", 
                  command=self.export_report).pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(report_actions, text="‚úâÔ∏è Email Report", 
                  command=self.email_report).pack(side=tk.RIGHT)
    
    def create_monitoring_tab(self):
        """Create the real-time monitoring tab"""
        monitoring_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(monitoring_frame, text="üì° Monitoring")
        
        # Configure grid
        monitoring_frame.columnconfigure(0, weight=1)
        monitoring_frame.rowconfigure(1, weight=1)
        
        # System monitoring
        system_frame = ttk.LabelFrame(monitoring_frame, text="System Monitoring", padding="10")
        system_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        system_frame.columnconfigure(1, weight=1)
        
        # System stats
        self.system_vars = {
            'cpu_usage': tk.StringVar(value="0%"),
            'memory_usage': tk.StringVar(value="0%"),
            'active_threads': tk.StringVar(value="0"),
            'network_activity': tk.StringVar(value="Idle")
        }
        
        system_labels = [
            ("CPU Usage:", 'cpu_usage'),
            ("Memory Usage:", 'memory_usage'),
            ("Active Threads:", 'active_threads'),
            ("Network Activity:", 'network_activity')
        ]
        
        for i, (label, var_key) in enumerate(system_labels):
            ttk.Label(system_frame, text=label).grid(row=i//2, column=(i%2)*2, sticky=tk.W, padx=10, pady=5)
            ttk.Label(system_frame, textvariable=self.system_vars[var_key]).grid(
                row=i//2, column=(i%2)*2+1, sticky=tk.W, padx=10, pady=5)
        
        # Activity log
        log_frame = ttk.LabelFrame(monitoring_frame, text="Activity Log", padding="10")
        log_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)
        
        self.activity_log = scrolledtext.ScrolledText(log_frame, height=20, width=80)
        self.activity_log.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Log controls
        log_controls = ttk.Frame(monitoring_frame)
        log_controls.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(10, 0))
        
        ttk.Button(log_controls, text="üîÑ Refresh", command=self.refresh_monitoring).pack(side=tk.LEFT)
        ttk.Button(log_controls, text="üíæ Save Log", command=self.save_log).pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(log_controls, text="üóëÔ∏è Clear Log", command=self.clear_log).pack(side=tk.LEFT, padx=(10, 0))
        
        # Auto-refresh checkbox
        self.auto_refresh_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(log_controls, text="Auto-refresh", 
                       variable=self.auto_refresh_var).pack(side=tk.RIGHT)
    
    def create_status_bar(self, parent):
        """Create the status bar"""
        status_frame = ttk.Frame(parent)
        status_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))
        status_frame.columnconfigure(1, weight=1)
        
        # Status message
        self.status_var = tk.StringVar(value="Ready")
        ttk.Label(status_frame, textvariable=self.status_var).grid(row=0, column=0, sticky=tk.W)
        
        # Progress bar
        self.progress = ttk.Progressbar(status_frame, mode='determinate')
        self.progress.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(20, 20))
        
        # Connection status
        self.connection_var = tk.StringVar(value="üî¥ Offline")
        ttk.Label(status_frame, textvariable=self.connection_var).grid(row=0, column=2, sticky=tk.E)
        
    # === Event Handlers ===
    
    def load_settings(self):
        """Load application settings"""
        self.log_activity("Application started - Loading settings...")
        self.update_status("Loading settings...")
        
        # Initialize AI status check
        threading.Thread(target=self.check_ai_status, daemon=True).start()
        
    def check_ai_status(self):
        """Check AI system status in background"""
        try:
            # Try to import and initialize core components
            from src.agentic_ai import AgenticPentestAI
            from src.enhanced_nlp_processor import EnhancedNLPProcessor
            
            self.root.after(0, lambda: self.ai_status_var.set("üü¢ AI Ready"))
            self.root.after(0, lambda: self.connection_var.set("üü¢ Online"))
            self.root.after(0, lambda: self.log_activity("AI systems initialized successfully"))
            
        except Exception as e:
            self.root.after(0, lambda: self.ai_status_var.set("üü° Partial"))
            self.root.after(0, lambda: self.log_activity(f"AI initialization warning: {str(e)}"))
    
    def new_session(self):
        """Create a new assessment session"""
        if messagebox.askyesno("New Session", "Start a new assessment session? This will clear current data."):
            self.clear_targets()
            self.clear_results()
            self.current_session = f"session_{int(time.time())}"
            self.session_var.set(f"Session: {self.current_session}")
            self.log_activity("New session started")
            self.update_status("New session created")
    
    def add_target_from_entry(self, event=None):
        """Add target from the entry field"""
        target = self.target_entry.get().strip()
        if target:
            self.add_target(target)
            self.target_entry.delete(0, tk.END)
    
    def add_target(self, target):
        """Add a target to the list"""
        # Determine platform automatically
        platform = self.detect_platform(target)
        
        # Insert into treeview
        self.targets_tree.insert('', tk.END, values=(
            target, platform, "Medium", "Not Assessed", "Never"
        ))
        
        self.log_activity(f"Added target: {target} ({platform})")
    
    def detect_platform(self, target):
        """Auto-detect target platform"""
        if target.startswith(('http://', 'https://')):
            return "üåç Web"
        elif target.endswith(('.apk', '.ipa')):
            return "üì± Mobile"
        elif '/' in target and any(c.isdigit() for c in target):
            return "üåê Network"
        elif 'aws' in target.lower() or 'azure' in target.lower() or 'gcp' in target.lower():
            return "‚òÅÔ∏è Cloud"
        else:
            return "üîß Generic"
    
    def remove_target(self):
        """Remove selected target"""
        selected = self.targets_tree.selection()
        if selected:
            for item in selected:
                target = self.targets_tree.item(item)['values'][0]
                self.targets_tree.delete(item)
                self.log_activity(f"Removed target: {target}")
    
    def clear_targets(self):
        """Clear all targets"""
        if self.targets_tree.get_children():
            if messagebox.askyesno("Clear Targets", "Remove all targets?"):
                for item in self.targets_tree.get_children():
                    self.targets_tree.delete(item)
                self.log_activity("All targets cleared")
    
    def start_assessment(self):
        """Start the main assessment"""
        if not self.targets_tree.get_children():
            messagebox.showwarning("No Targets", "Please add at least one target before starting assessment.")
            return
        
        if self.assessment_running:
            messagebox.showinfo("Assessment Running", "An assessment is already in progress.")
            return
        
        self.assessment_running = True
        self.update_status("Starting assessment...")
        self.log_activity("Assessment started")
        
        # Get targets
        targets = []
        for item in self.targets_tree.get_children():
            target = self.targets_tree.item(item)['values'][0]
            targets.append(target)
        
        # Start assessment in background thread
        threading.Thread(target=self.run_assessment, args=(targets,), daemon=True).start()
    
    def run_assessment(self, targets):
        """Run assessment in background thread"""
        try:
            from src.agentic_ai import AgenticPentestAI
            
            # Initialize agent
            self.root.after(0, lambda: self.progress.configure(value=10))
            agent = AgenticPentestAI()
            
            total_targets = len(targets)
            
            for i, target in enumerate(targets):
                progress = int(((i + 1) / total_targets) * 90)  # Leave 10% for finalization
                
                self.root.after(0, lambda p=progress: self.progress.configure(value=p))
                self.root.after(0, lambda t=target: self.update_status(f"Analyzing: {t}"))
                self.root.after(0, lambda t=target: self.log_activity(f"Processing target: {t}"))
                
                # Process target
                request = f"Perform comprehensive security assessment of {target}"
                result = agent.process_request(request)
                
                # Update UI with results
                self.root.after(0, lambda t=target, r=result: self.add_assessment_result(t, r))
                
                # Update target status
                for item in self.targets_tree.get_children():
                    if self.targets_tree.item(item)['values'][0] == target:
                        values = list(self.targets_tree.item(item)['values'])
                        values[3] = "‚úÖ Assessed"  # Status
                        values[4] = datetime.now().strftime("%Y-%m-%d %H:%M")  # Last assessed
                        self.root.after(0, lambda item=item, vals=values: 
                                      self.targets_tree.item(item, values=vals))
                        break
            
            # Finalization
            self.root.after(0, lambda: self.progress.configure(value=100))
            self.root.after(0, lambda: self.update_status("Assessment completed"))
            self.root.after(0, lambda: self.log_activity("Assessment completed successfully"))
            self.root.after(0, lambda: messagebox.showinfo("Complete", f"Assessment completed for {len(targets)} targets"))
            
        except Exception as e:
            self.root.after(0, lambda: self.log_activity(f"Assessment failed: {str(e)}"))
            self.root.after(0, lambda: messagebox.showerror("Error", f"Assessment failed: {str(e)}"))
        finally:
            self.assessment_running = False
            self.root.after(0, lambda: self.progress.configure(value=0))
    
    def add_assessment_result(self, target, result):
        """Add assessment result to results tree"""
        # Simulate some findings
        findings = [
            (target, "High", "Open SSH Port", "Restrict SSH access", "New"),
            (target, "Medium", "Outdated SSL Certificate", "Update certificate", "New"), 
            (target, "Low", "Information Disclosure", "Remove version headers", "New")
        ]
        
        for finding in findings:
            self.results_tree.insert('', tk.END, values=finding)
        
        # Update summary stats
        current_vulns = int(self.stats_vars['vulnerabilities_found'].get())
        self.stats_vars['vulnerabilities_found'].set(str(current_vulns + len(findings)))
        
        current_targets = int(self.stats_vars['targets_processed'].get())
        self.stats_vars['targets_processed'].set(str(current_targets + 1))
    
    def start_ai_analysis(self):
        """Start AI-only analysis"""
        if not self.targets_tree.get_children():
            messagebox.showwarning("No Targets", "Please add targets first.")
            return
            
        targets = []
        for item in self.targets_tree.get_children():
            target = self.targets_tree.item(item)['values'][0]
            targets.append(target)
        
        threading.Thread(target=self.run_ai_analysis, args=(targets,), daemon=True).start()
    
    def run_ai_analysis(self, targets):
        """Run AI analysis in background"""
        try:
            from src.enhanced_nlp_processor import EnhancedNLPProcessor
            
            nlp = EnhancedNLPProcessor()
            
            analysis_results = []
            
            for target in targets:
                request = f"analyze security of {target}"
                intent = nlp.process_request(request)
                
                result = {
                    'target': target,
                    'intent': intent.primary_command.value,
                    'confidence': intent.confidence,
                    'targets_found': intent.targets,
                    'modifiers': intent.modifiers
                }
                analysis_results.append(result)
            
            # Update UI with results
            self.root.after(0, lambda: self.display_ai_analysis_results(analysis_results))
            
        except Exception as e:
            self.root.after(0, lambda: self.log_activity(f"AI Analysis failed: {str(e)}"))
    
    def display_ai_analysis_results(self, results):
        """Display AI analysis results"""
        self.ai_results_text.delete(1.0, tk.END)
        
        output = "ü§ñ AI ANALYSIS RESULTS\n" + "="*50 + "\n\n"
        
        for result in results:
            output += f"üéØ Target: {result['target']}\n"
            output += f"   Intent: {result['intent']}\n"
            output += f"   Confidence: {result['confidence']:.2%}\n"
            output += f"   Targets Found: {', '.join(result['targets_found']) if result['targets_found'] else 'None'}\n"
            output += f"   Modifiers: {', '.join(result['modifiers']) if result['modifiers'] else 'None'}\n"
            output += "\n"
        
        output += "‚úÖ AI Analysis Complete!\n"
        
        self.ai_results_text.insert(tk.END, output)
        
        # Switch to AI analysis tab
        self.notebook.select(2)  # AI Analysis tab
        
        self.log_activity(f"AI analysis completed for {len(results)} targets")
    
    def emergency_stop(self):
        """Emergency stop of all operations"""
        if messagebox.askyesno("Emergency Stop", "Stop all running assessments?"):
            self.assessment_running = False
            self.update_status("Emergency stop activated")
            self.log_activity("EMERGENCY STOP - All operations halted")
            messagebox.showinfo("Stopped", "All operations have been stopped.")
    
    def initialize_ai_models(self):
        """Initialize AI models"""
        self.update_status("Initializing AI models...")
        self.model_status_text.delete(1.0, tk.END)
        
        def init_models():
            try:
                status_text = "ü§ñ Initializing AI Models...\n\n"
                self.root.after(0, lambda: self.model_status_text.insert(tk.END, status_text))
                
                # Try to initialize AI components
                from src.ai_model_manager import AIModelManager
                from src.agentic_ai import AgenticPentestAI
                
                status_text = "‚úÖ AI Model Manager: Loaded\n"
                self.root.after(0, lambda: self.model_status_text.insert(tk.END, status_text))
                
                status_text = "‚úÖ Agentic AI: Loaded\n"  
                self.root.after(0, lambda: self.model_status_text.insert(tk.END, status_text))
                
                status_text = "‚úÖ NLP Processor: Loaded\n"
                self.root.after(0, lambda: self.model_status_text.insert(tk.END, status_text))
                
                status_text = "\nüéâ All AI models initialized successfully!\n"
                self.root.after(0, lambda: self.model_status_text.insert(tk.END, status_text))
                
                self.root.after(0, lambda: self.ai_status_var.set("üü¢ AI Ready"))
                self.root.after(0, lambda: self.log_activity("AI models initialized"))
                
            except Exception as e:
                error_text = f"\n‚ùå Error initializing AI models: {str(e)}\n"
                self.root.after(0, lambda: self.model_status_text.insert(tk.END, error_text))
                self.root.after(0, lambda: self.ai_status_var.set("üî¥ Error"))
        
        threading.Thread(target=init_models, daemon=True).start()
    
    def run_ai_analysis_tab(self):
        """Run AI analysis from the AI tab"""
        if not self.targets_tree.get_children():
            messagebox.showwarning("No Targets", "Please add targets first.")
            return
        
        targets = []
        for item in self.targets_tree.get_children():
            target = self.targets_tree.item(item)['values'][0]
            targets.append(target)
        
        self.run_ai_analysis(targets)
    
    # === Utility Methods ===
    
    def log_activity(self, message):
        """Log activity to the monitoring tab"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {message}\n"
        
        if hasattr(self, 'activity_log'):
            self.activity_log.insert(tk.END, log_entry)
            self.activity_log.see(tk.END)
    
    def update_status(self, message):
        """Update status bar message"""
        self.status_var.set(message)
    
    def update_confidence_label(self, value):
        """Update confidence threshold label"""
        self.confidence_var.set(f"{float(value):.2f}")
    
    # === Placeholder Methods (implement as needed) ===
    
    def load_targets_file(self): 
        messagebox.showinfo("Feature", "Load targets from file - Feature coming soon!")
    
    def save_results(self): 
        messagebox.showinfo("Feature", "Save results - Feature coming soon!")
    
    def open_ai_manager(self): 
        messagebox.showinfo("Feature", "AI Model Manager - Feature coming soon!")
    
    def open_settings(self): 
        messagebox.showinfo("Feature", "Settings - Feature coming soon!")
    
    def view_logs(self): 
        messagebox.showinfo("Feature", "View logs - Feature coming soon!")
    
    def show_help(self): 
        messagebox.showinfo("Help", "Documentation - Feature coming soon!")
    
    def show_about(self):
        messagebox.showinfo("About", 
                           "AI-Powered Automated Penetration Testing Orchestrator v1.0\n\n"
                           "ü§ñ Advanced AI-driven security assessment platform\n"
                           "üîß Multi-platform penetration testing capabilities\n"
                           "üöÄ Autonomous agentic AI system\n\n"
                           "Built with Python and powered by machine learning")
    
    def generate_report(self): 
        messagebox.showinfo("Feature", "Generate report - Feature coming soon!")
    
    def import_csv(self): 
        messagebox.showinfo("Feature", "Import CSV - Feature coming soon!")
    
    def export_csv(self): 
        messagebox.showinfo("Feature", "Export CSV - Feature coming soon!")
    
    def save_ai_state(self): 
        messagebox.showinfo("Feature", "Save AI state - Feature coming soon!")
    
    def reset_ai_models(self): 
        messagebox.showinfo("Feature", "Reset AI models - Feature coming soon!")
    
    def export_results(self): 
        messagebox.showinfo("Feature", "Export results - Feature coming soon!")
    
    def view_result_details(self): 
        messagebox.showinfo("Feature", "View result details - Feature coming soon!")
    
    def generate_chart(self): 
        messagebox.showinfo("Feature", "Generate chart - Feature coming soon!")
    
    def refresh_results(self): 
        self.log_activity("Results refreshed")
    
    def clear_results(self):
        """Clear all results"""
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        for var in self.stats_vars.values():
            var.set("0" if var != self.stats_vars['success_rate'] else "0%")
    
    def generate_full_report(self): 
        messagebox.showinfo("Feature", "Generate full report - Feature coming soon!")
    
    def preview_report(self): 
        self.report_preview.delete(1.0, tk.END)
        preview_text = """
ü§ñ AI-POWERED PENETRATION TESTING REPORT
========================================

Executive Summary
-----------------
This assessment was conducted using advanced AI-driven automated penetration testing
techniques across multiple platforms and attack surfaces.

Assessment Scope
---------------
‚Ä¢ Network Infrastructure Testing
‚Ä¢ Web Application Security Assessment  
‚Ä¢ Mobile Application Analysis
‚Ä¢ Wireless Security Testing
‚Ä¢ Cloud Infrastructure Review

Key Findings
-----------
‚Ä¢ Total vulnerabilities identified: 12
‚Ä¢ High-risk issues: 3
‚Ä¢ Medium-risk issues: 6  
‚Ä¢ Low-risk issues: 3

Recommendations
--------------
1. Immediate attention required for high-risk vulnerabilities
2. Implement security hardening measures
3. Regular security assessments recommended
4. Staff security awareness training

Technical Details
----------------
[Detailed technical findings would appear here...]

Conclusion
---------
The AI-powered assessment identified several security issues that require
immediate attention. Follow-up assessments recommended in 3-6 months.
        """
        self.report_preview.insert(tk.END, preview_text)
    
    def export_report(self): 
        messagebox.showinfo("Feature", "Export report - Feature coming soon!")
    
    def email_report(self): 
        messagebox.showinfo("Feature", "Email report - Feature coming soon!")
    
    def refresh_monitoring(self): 
        self.log_activity("Monitoring data refreshed")
    
    def save_log(self): 
        messagebox.showinfo("Feature", "Save log - Feature coming soon!")
    
    def clear_log(self):
        """Clear activity log"""
        if messagebox.askyesno("Clear Log", "Clear all activity log entries?"):
            self.activity_log.delete(1.0, tk.END)
            self.log_activity("Activity log cleared")

def main():
    """Main application entry point"""
    root = tk.Tk()
    app = PentestGUI(root)
    
    # Handle window close
    def on_closing():
        if messagebox.askokcancel("Quit", "Do you want to quit?"):
            root.destroy()
    
    root.protocol("WM_DELETE_WINDOW", on_closing)
    
    # Start the application
    root.mainloop()

if __name__ == "__main__":
    main()
