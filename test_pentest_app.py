#!/usr/bin/env python3
"""
Comprehensive Test Script for Automatic Pentesting Application
Tests all major components with realistic sample target data
"""

import os
import sys
import json
import time
from pathlib import Path
from datetime import datetime

# Add project to path
sys.path.insert(0, str(Path(__file__).parent))

from src.config import Config
from src.reconnaissance import ReconnaissanceModule
from src.vulnerability_scanner import VulnerabilityScanner
from src.service_analyzer import ServiceAnalyzer
from src.payload_generator import PayloadGenerator
from src.report_generator import ReportGenerator
from src.network_assessor import NetworkAssessor
from src.web_assessor import WebAssessor
from src.target_classifier import TargetClassifier
from src.exploit_prioritizer import ExploitPrioritizer

# Rich console for formatted output
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import track

console = Console()

# Sample target configurations with realistic details
SAMPLE_TARGETS = {
    "web_application": {
        "target": "scanme.nmap.org",  # Public test server allowed for scanning
        "type": "web",
        "description": "Public test web server (Nmap project)",
        "expected_services": ["http", "ssh"],
        "scan_type": "quick"
    },
    "network_range": {
        "target": "192.168.1.0/24",  # Private network range (safe for testing)
        "type": "network",
        "description": "Private network range scan simulation",
        "scan_type": "comprehensive"
    },
    "api_endpoint": {
        "target": "httpbin.org",  # Public API testing service
        "type": "api",
        "description": "Public API testing endpoint",
        "endpoints": ["/get", "/post", "/headers", "/status/200"],
        "scan_type": "api"
    },
    "vulnerable_app": {
        "target": "testphp.vulnweb.com",  # Intentionally vulnerable test site
        "type": "vulnerable_web",
        "description": "Intentionally vulnerable test application",
        "vulnerabilities": ["SQL Injection", "XSS", "Directory Traversal"],
        "scan_type": "comprehensive"
    }
}

class PentestAppTester:
    """Comprehensive testing class for pentesting application"""
    
    def __init__(self):
        """Initialize tester with configuration"""
        self.console = console
        self.results = {}
        self.test_start_time = datetime.now()
        
        # Ensure output directories exist
        Config.create_output_dirs()
        Config.setup_logging()
        
        # Test output directory
        self.test_output_dir = Config.OUTPUT_DIR / f"test_run_{self.test_start_time.strftime('%Y%m%d_%H%M%S')}"
        self.test_output_dir.mkdir(parents=True, exist_ok=True)
        
    def print_header(self):
        """Print test header"""
        self.console.print(Panel.fit(
            "[bold cyan]Automatic Pentesting Application - Comprehensive Test Suite[/bold cyan]\n"
            "[dim]Testing all major components with realistic sample data[/dim]",
            title="üß™ Test Suite",
            border_style="cyan"
        ))
        
    def test_configuration(self):
        """Test configuration and tool availability"""
        self.console.print("\n[bold]1Ô∏è‚É£ Testing Configuration & Tool Availability[/bold]")
        
        config_results = {
            "api_keys": {},
            "tools": {},
            "directories": {}
        }
        
        # Check API keys
        api_keys_table = Table(title="API Keys Status")
        api_keys_table.add_column("Service", style="cyan")
        api_keys_table.add_column("Status", style="magenta")
        
        api_keys = {
            "Shodan": Config.SHODAN_API_KEY,
            "VirusTotal": Config.VIRUSTOTAL_API_KEY,
            "MobSF": Config.MOBSF_API_KEY,
            "OpenAI": Config.OPENAI_API_KEY
        }
        
        for service, key in api_keys.items():
            status = "‚úÖ Configured" if key else "‚ö†Ô∏è Not configured"
            api_keys_table.add_row(service, status)
            config_results["api_keys"][service] = bool(key)
        
        self.console.print(api_keys_table)
        
        # Check critical tools
        tools_table = Table(title="Tool Availability")
        tools_table.add_column("Tool", style="cyan")
        tools_table.add_column("Path", style="yellow")
        tools_table.add_column("Available", style="magenta")
        
        critical_tools = {
            "Nmap": Config.NMAP_PATH,
            "Nuclei": Config.NUCLEI_PATH,
            "Nikto": Config.NIKTO_PATH,
            "SQLMap": Config.SQLMAP_PATH
        }
        
        for tool_name, tool_path in critical_tools.items():
            # Check if tool exists
            from src.utils import check_tool_available
            available = check_tool_available(tool_path)
            status = "‚úÖ Yes" if available else "‚ùå No"
            tools_table.add_row(tool_name, tool_path, status)
            config_results["tools"][tool_name] = available
        
        self.console.print(tools_table)
        
        # Check directories
        self.console.print(f"\n[bold]Output Directory:[/bold] {Config.OUTPUT_DIR}")
        self.console.print(f"[bold]Test Output:[/bold] {self.test_output_dir}")
        
        self.results["configuration"] = config_results
        return config_results
    
    def test_target_classification(self, target_info):
        """Test target classification"""
        self.console.print(f"\n[bold]2Ô∏è‚É£ Testing Target Classification: {target_info['target']}[/bold]")
        
        try:
            classifier = TargetClassifier()
            classification = classifier.classify(target_info['target'])
            
            # Display classification results
            class_table = Table(title="Target Classification")
            class_table.add_column("Property", style="cyan")
            class_table.add_column("Value", style="magenta")
            
            class_table.add_row("Target Type", classification.get('type', 'Unknown'))
            class_table.add_row("Subtype", classification.get('subtype', 'Unknown'))
            class_table.add_row("Is Web Target", "‚úÖ" if classification.get('is_web_target') else "‚ùå")
            class_table.add_row("Is Network Target", "‚úÖ" if classification.get('is_network_target') else "‚ùå")
            
            self.console.print(class_table)
            
            if classification.get('recommended_scans'):
                self.console.print("\n[bold]Recommended Scans:[/bold]")
                for scan in classification['recommended_scans']:
                    self.console.print(f"  ‚Ä¢ {scan.replace('_', ' ').title()}")
            
            return classification
            
        except Exception as e:
            self.console.print(f"[red]‚ùå Classification failed: {e}[/red]")
            return None
    
    def test_reconnaissance(self, target_info):
        """Test reconnaissance module"""
        self.console.print(f"\n[bold]3Ô∏è‚É£ Testing Reconnaissance: {target_info['target']}[/bold]")
        
        try:
            recon_module = ReconnaissanceModule()
            
            with self.console.status("[bold green]Running reconnaissance scan...[/bold green]"):
                results = recon_module.scan_target(target_info['target'])
            
            # Save results
            output_file = recon_module.save_results(results, self.test_output_dir)
            
            # Display summary
            summary_table = Table(title="Reconnaissance Results")
            summary_table.add_column("Metric", style="cyan")
            summary_table.add_column("Count", style="magenta")
            
            # Count open ports
            port_count = 0
            if results.get('nmap_scan', {}).get('hosts'):
                for host_data in results['nmap_scan']['hosts'].values():
                    for protocol_ports in host_data.get('protocols', {}).values():
                        port_count += len(protocol_ports)
            
            summary_table.add_row("Open Ports", str(port_count))
            summary_table.add_row("Subdomains", str(len(results.get('subdomains', []))))
            summary_table.add_row("DNS Records", str(len(results.get('dns_records', {}))))
            
            self.console.print(summary_table)
            self.console.print(f"[green]‚úÖ Results saved to: {output_file}[/green]")
            
            return results
            
        except Exception as e:
            self.console.print(f"[red]‚ùå Reconnaissance failed: {e}[/red]")
            return None
    
    def test_vulnerability_scanning(self, target_info):
        """Test vulnerability scanning"""
        self.console.print(f"\n[bold]4Ô∏è‚É£ Testing Vulnerability Scanning: {target_info['target']}[/bold]")
        
        try:
            vuln_scanner = VulnerabilityScanner()
            
            with self.console.status("[bold yellow]Scanning for vulnerabilities...[/bold yellow]"):
                results = vuln_scanner.scan_target(
                    target_info['target'], 
                    scan_type=target_info.get('scan_type', 'quick')
                )
            
            # Save results
            output_file = vuln_scanner.save_results(results, self.test_output_dir)
            
            # Display summary
            summary = results.get('summary', {})
            severity = summary.get('severity_breakdown', {})
            
            vuln_table = Table(title="Vulnerability Summary")
            vuln_table.add_column("Severity", style="cyan")
            vuln_table.add_column("Count", style="magenta")
            
            for level in ['critical', 'high', 'medium', 'low', 'info']:
                count = severity.get(level, 0)
                color = {'critical': 'red', 'high': 'orange1', 'medium': 'yellow', 
                        'low': 'green', 'info': 'blue'}.get(level, 'white')
                vuln_table.add_row(f"[{color}]{level.title()}[/{color}]", str(count))
            
            self.console.print(vuln_table)
            self.console.print(f"[bold]Total Vulnerabilities:[/bold] {summary.get('total_vulnerabilities', 0)}")
            self.console.print(f"[green]‚úÖ Results saved to: {output_file}[/green]")
            
            return results
            
        except Exception as e:
            self.console.print(f"[red]‚ùå Vulnerability scanning failed: {e}[/red]")
            return None
    
    def test_service_analysis(self, target_info, recon_data):
        """Test service analysis"""
        self.console.print(f"\n[bold]5Ô∏è‚É£ Testing Service Analysis: {target_info['target']}[/bold]")
        
        try:
            service_analyzer = ServiceAnalyzer()
            
            # Extract open ports from recon data
            open_ports = {}
            if recon_data and recon_data.get('nmap_scan', {}).get('hosts'):
                for host_data in recon_data['nmap_scan']['hosts'].values():
                    for protocol, ports in host_data.get('protocols', {}).get('tcp', {}).items():
                        if isinstance(ports, dict):
                            open_ports.update(ports)
            
            if not open_ports:
                # Use default common ports for testing
                open_ports = {80: {'state': 'open', 'service': 'http'},
                             443: {'state': 'open', 'service': 'https'}}
            
            with self.console.status("[bold blue]Analyzing services...[/bold blue]"):
                results = service_analyzer.analyze_services(target_info['target'], open_ports)
            
            # Save results
            output_file = service_analyzer.save_results(results, self.test_output_dir)
            
            # Display summary
            summary = results.get('summary', {})
            service_table = Table(title="Service Analysis")
            service_table.add_column("Metric", style="cyan")
            service_table.add_column("Value", style="magenta")
            
            service_table.add_row("Total Services", str(summary.get('total_services', 0)))
            service_table.add_row("Vulnerable Services", str(summary.get('vulnerable_services', 0)))
            service_table.add_row("Attack Vectors", str(summary.get('attack_vectors_found', 0)))
            
            self.console.print(service_table)
            self.console.print(f"[green]‚úÖ Results saved to: {output_file}[/green]")
            
            return results
            
        except Exception as e:
            self.console.print(f"[red]‚ùå Service analysis failed: {e}[/red]")
            return None
    
    def test_payload_generation(self, target_info):
        """Test payload generation"""
        self.console.print(f"\n[bold]6Ô∏è‚É£ Testing Payload Generation[/bold]")
        
        try:
            payload_generator = PayloadGenerator()
            
            # Generate test payloads
            test_payloads = []
            platforms = ['linux', 'windows', 'web']
            payload_types = ['reverse_shell', 'bind_shell']
            
            for platform in platforms:
                for payload_type in payload_types:
                    with self.console.status(f"[bold red]Generating {platform} {payload_type}...[/bold red]"):
                        options = {'LHOST': '10.10.10.10', 'LPORT': 4444}
                        payload = payload_generator.generate_custom_payloads(
                            payload_type, platform, options
                        )
                        if payload:
                            test_payloads.extend(payload)
            
            # Display results
            payload_table = Table(title="Generated Payloads")
            payload_table.add_column("Platform", style="cyan")
            payload_table.add_column("Type", style="yellow")
            payload_table.add_column("Generated", style="magenta")
            
            payload_count = {}
            for payload in test_payloads:
                key = f"{payload.get('platform', 'unknown')}_{payload.get('type', 'unknown')}"
                payload_count[key] = payload_count.get(key, 0) + 1
            
            for key, count in payload_count.items():
                platform, ptype = key.split('_', 1)
                payload_table.add_row(platform, ptype, str(count))
            
            self.console.print(payload_table)
            self.console.print(f"[bold]Total Payloads Generated:[/bold] {len(test_payloads)}")
            
            # Save payload data
            payload_data = {
                'target': target_info['target'],
                'payloads': test_payloads,
                'timestamp': datetime.now().isoformat()
            }
            output_file = payload_generator.save_payloads(payload_data, self.test_output_dir)
            self.console.print(f"[green]‚úÖ Payloads saved to: {output_file}[/green]")
            
            return test_payloads
            
        except Exception as e:
            self.console.print(f"[red]‚ùå Payload generation failed: {e}[/red]")
            return None
    
    def test_exploit_prioritization(self, vuln_data):
        """Test exploit prioritization"""
        self.console.print(f"\n[bold]7Ô∏è‚É£ Testing Exploit Prioritization[/bold]")
        
        try:
            prioritizer = ExploitPrioritizer()
            
            # Extract vulnerabilities for prioritization
            all_vulns = []
            if vuln_data:
                for source in ['nuclei_results', 'nikto_results']:
                    if vuln_data.get(source):
                        all_vulns.extend(vuln_data[source])
            
            if not all_vulns:
                # Create sample vulnerabilities for testing
                all_vulns = [
                    {'severity': 'critical', 'name': 'Remote Code Execution', 'cvss': 9.8},
                    {'severity': 'high', 'name': 'SQL Injection', 'cvss': 8.5},
                    {'severity': 'medium', 'name': 'XSS', 'cvss': 6.1},
                    {'severity': 'low', 'name': 'Information Disclosure', 'cvss': 3.7}
                ]
            
            with self.console.status("[bold purple]Prioritizing exploits...[/bold purple]"):
                prioritized = prioritizer.prioritize_exploits(all_vulns)
            
            # Display results
            exploit_table = Table(title="Prioritized Exploits")
            exploit_table.add_column("Rank", style="dim")
            exploit_table.add_column("Vulnerability", style="cyan")
            exploit_table.add_column("Severity", style="yellow")
            exploit_table.add_column("Priority Score", style="magenta")
            
            for i, exploit in enumerate(prioritized[:5], 1):
                severity = exploit.get('severity', 'unknown')
                color = {'critical': 'red', 'high': 'orange1', 'medium': 'yellow', 
                        'low': 'green'}.get(severity, 'white')
                exploit_table.add_row(
                    str(i),
                    exploit.get('name', 'Unknown'),
                    f"[{color}]{severity}[/{color}]",
                    f"{exploit.get('priority_score', 0):.2f}"
                )
            
            self.console.print(exploit_table)
            
            return prioritized
            
        except Exception as e:
            self.console.print(f"[red]‚ùå Exploit prioritization failed: {e}[/red]")
            return None
    
    def test_report_generation(self, target_info, recon_data, vuln_data, payload_data):
        """Test report generation"""
        self.console.print(f"\n[bold]8Ô∏è‚É£ Testing Report Generation[/bold]")
        
        try:
            report_generator = ReportGenerator()
            
            with self.console.status("[bold blue]Generating comprehensive report...[/bold blue]"):
                report_data = report_generator.generate_comprehensive_report(
                    target_info['target'],
                    recon_data or {},
                    vuln_data or {},
                    {'payloads': payload_data or []} if payload_data else {}
                )
            
            # Save reports in multiple formats
            formats = ['html', 'markdown', 'json']
            saved_files = []
            
            for format_type in formats:
                if format_type == 'json':
                    output_file = report_generator.save_json_report(report_data, self.test_output_dir)
                else:
                    output_file = report_generator.save_report(report_data, self.test_output_dir, format_type)
                saved_files.append((format_type, output_file))
            
            # Display summary
            report_table = Table(title="Generated Reports")
            report_table.add_column("Format", style="cyan")
            report_table.add_column("File Path", style="magenta")
            
            for format_type, file_path in saved_files:
                report_table.add_row(format_type.upper(), str(file_path))
            
            self.console.print(report_table)
            
            # Show executive summary
            exec_summary = report_data.get('executive_summary', {})
            self.console.print(Panel.fit(
                f"[bold]Risk Level:[/bold] {exec_summary.get('overall_risk_level', 'Unknown')}\n"
                f"[bold]Total Vulnerabilities:[/bold] {exec_summary.get('total_vulnerabilities', 0)}\n"
                f"[bold]Critical Findings:[/bold] {exec_summary.get('critical_findings', 0)}",
                title="Executive Summary",
                border_style="green"
            ))
            
            return report_data
            
        except Exception as e:
            self.console.print(f"[red]‚ùå Report generation failed: {e}[/red]")
            return None
    
    def run_comprehensive_test(self):
        """Run comprehensive test suite"""
        self.print_header()
        
        # Test configuration first
        config_results = self.test_configuration()
        
        # Select appropriate test target based on available tools
        if config_results['tools'].get('Nmap'):
            # Use public test server if nmap is available
            target_info = SAMPLE_TARGETS['web_application']
        else:
            # Use API endpoint if network tools aren't available
            target_info = SAMPLE_TARGETS['api_endpoint']
        
        self.console.print(f"\n[bold cyan]üéØ Testing with target: {target_info['target']}[/bold cyan]")
        self.console.print(f"[dim]{target_info['description']}[/dim]\n")
        
        # Run test modules
        test_results = {
            'configuration': config_results,
            'target': target_info['target'],
            'timestamp': self.test_start_time.isoformat()
        }
        
        # 1. Target Classification
        classification = self.test_target_classification(target_info)
        test_results['classification'] = classification
        
        # 2. Reconnaissance
        recon_data = self.test_reconnaissance(target_info)
        test_results['reconnaissance'] = bool(recon_data)
        
        # 3. Vulnerability Scanning
        vuln_data = self.test_vulnerability_scanning(target_info)
        test_results['vulnerability_scanning'] = bool(vuln_data)
        
        # 4. Service Analysis
        service_data = self.test_service_analysis(target_info, recon_data)
        test_results['service_analysis'] = bool(service_data)
        
        # 5. Payload Generation
        payload_data = self.test_payload_generation(target_info)
        test_results['payload_generation'] = bool(payload_data)
        
        # 6. Exploit Prioritization
        prioritized = self.test_exploit_prioritization(vuln_data)
        test_results['exploit_prioritization'] = bool(prioritized)
        
        # 7. Report Generation
        report_data = self.test_report_generation(target_info, recon_data, vuln_data, payload_data)
        test_results['report_generation'] = bool(report_data)
        
        # Calculate test duration
        test_duration = (datetime.now() - self.test_start_time).total_seconds()
        test_results['duration_seconds'] = test_duration
        
        # Save test results
        self.save_test_results(test_results)
        
        # Display final summary
        self.display_test_summary(test_results)
        
        return test_results
    
    def save_test_results(self, results):
        """Save test results to file"""
        output_file = self.test_output_dir / "test_results.json"
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2, default=str)
        self.console.print(f"\n[green]üíæ Test results saved to: {output_file}[/green]")
    
    def display_test_summary(self, results):
        """Display test summary"""
        self.console.print("\n" + "="*60)
        self.console.print(Panel.fit(
            "[bold green]üéâ Test Suite Completed![/bold green]",
            title="Summary",
            border_style="green"
        ))
        
        # Module test results
        module_table = Table(title="Module Test Results")
        module_table.add_column("Module", style="cyan")
        module_table.add_column("Status", style="magenta")
        
        modules = [
            ('Configuration', results.get('configuration', {}).get('tools', {}).get('Nmap', False)),
            ('Target Classification', results.get('classification') is not None),
            ('Reconnaissance', results.get('reconnaissance', False)),
            ('Vulnerability Scanning', results.get('vulnerability_scanning', False)),
            ('Service Analysis', results.get('service_analysis', False)),
            ('Payload Generation', results.get('payload_generation', False)),
            ('Exploit Prioritization', results.get('exploit_prioritization', False)),
            ('Report Generation', results.get('report_generation', False))
        ]
        
        passed = 0
        for module_name, status in modules:
            status_icon = "‚úÖ Passed" if status else "‚ùå Failed"
            module_table.add_row(module_name, status_icon)
            if status:
                passed += 1
        
        self.console.print(module_table)
        
        # Overall statistics
        stats_table = Table(title="Test Statistics")
        stats_table.add_column("Metric", style="cyan")
        stats_table.add_column("Value", style="magenta")
        
        stats_table.add_row("Total Modules Tested", str(len(modules)))
        stats_table.add_row("Modules Passed", str(passed))
        stats_table.add_row("Modules Failed", str(len(modules) - passed))
        stats_table.add_row("Success Rate", f"{(passed/len(modules)*100):.1f}%")
        stats_table.add_row("Test Duration", f"{results.get('duration_seconds', 0):.2f} seconds")
        stats_table.add_row("Test Output Directory", str(self.test_output_dir))
        
        self.console.print(stats_table)
        
        # Recommendations
        if passed < len(modules):
            self.console.print("\n[yellow]‚ö†Ô∏è Some tests failed. Recommendations:[/yellow]")
            if not results.get('configuration', {}).get('tools', {}).get('Nmap'):
                self.console.print("  ‚Ä¢ Install Nmap for network scanning: sudo apt install nmap")
            if not results.get('configuration', {}).get('tools', {}).get('Nuclei'):
                self.console.print("  ‚Ä¢ Install Nuclei for vulnerability scanning")
            if not results.get('configuration', {}).get('api_keys', {}).get('Shodan'):
                self.console.print("  ‚Ä¢ Add Shodan API key to .env file for OSINT")


def main():
    """Main function to run tests"""
    tester = PentestAppTester()
    
    try:
        results = tester.run_comprehensive_test()
        
        # Exit with appropriate code
        if all([
            results.get('reconnaissance'),
            results.get('vulnerability_scanning'),
            results.get('report_generation')
        ]):
            console.print("\n[bold green]‚úÖ All critical systems working![/bold green]")
            sys.exit(0)
        else:
            console.print("\n[yellow]‚ö†Ô∏è Some systems need attention[/yellow]")
            sys.exit(1)
            
    except KeyboardInterrupt:
        console.print("\n[yellow]Test interrupted by user[/yellow]")
        sys.exit(130)
    except Exception as e:
        console.print(f"\n[red]‚ùå Test suite failed: {e}[/red]")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
